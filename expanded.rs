#![feature(prelude_import)]
/*!
Multi robot simulator with multi-threading and without ticking time

This crate provides a multi-robots simulator where each robot is executed in a separated thread.
The time is not linear, the simulator jump to the next time step as soon as possible, letting
the possibility to run faster than time, but also to take more time if needed.

All the simulator execution is based on the configuration file given. The configuration documentation is available below.

The simulator is modular and external modules can be used (through the [`plugin_api`]). There
are three main components:
- The [`physics`] module manages the real state of the robot. An external can be a real robot,
but the ground truth should be provided.
- The [`navigators`] module manages the definition of the trajectory, and calls the controller
which is part of the [`controllers`] module.
- The [`state_estimators`] module propose algorithms to estimate the state of the robot. It's
the module which was first considered as external, to test localization algorithms. To estimate
the state of the robot, this module uses the data produced by the [`sensors`] modules.

The entry-point for the simulator is [`simulator`], which provides a [`simulator::Simulator`]
struct to load a configuration, run the simulation, save the results and process the results.

For example, the simulator can be used as follows:
```no_run
use std::path::Path;
use simba::simulator::Simulator;

fn main() {
    // Initialize the environment
    Simulator::init_environment();
    println!("Load configuration...");
    let mut simulator = Simulator::from_config_path(
        Path::new("config_example/config.yaml"),
        &None, //<- plugin API, to load external modules
    );

    // Show the simulator loaded configuration
    simulator.show();

    // Run the simulator for the time given in the configuration
    // It also save the results to json
    simulator.run();

    simulator.compute_results();
}

```

*/
/*!# Configuration file documentation
This documentation is auto-generated.

To get more information on the parameter, check the documentation (or follow the links).

List of parameters:
- `log`: [LoggerConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/logger/struct.LoggerConfig.html)
	- `included_nodes`: String, List
	- `excluded_nodes`: String, List
	- `log_level`: [LogLevel](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/logger/enum.LogLevel.html), Enum
		- `Off`
		- `Error`
		- `Warn`
		- `Info`
		- `Debug`
		- `Internal`: [InternalLog](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/logger/enum.InternalLog.html), List, Enum
			- `All`
			- `NetworkMessages`
			- `ServiceHandling`
			- `SetupSteps`
			- `SetupStepsDetailed`
			- `SensorManager`
			- `SensorManagerDetailed`
			- `NodeRunning`
			- `NodeRunningDetailed`
			- `NodeSyncDetailed`
			- `API`
			- `NavigatorDetailed`
- `results`: [ResultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/simulator/struct.ResultConfig.html), Optional
	- `result_path`: String
	- `show_figures`: Boolean
	- `analyse_script`: String, Optional
	- `figures_path`: String, Optional
	- `python_params`: User-specific struct
- `base_path`: String
- `max_time`: Float
- `time_mode`: [TimeMode](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/simulator/enum.TimeMode.html), Enum
	- `Centralized`
	- `Decentralized`
- `time_analysis`: [TimeAnalysisConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/time_analysis/struct.TimeAnalysisConfig.html)
	- `exporter`: [ProfileExporterConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/time_analysis/enum.ProfileExporterConfig.html), Enum
		- `TraceEventExporter`
	- `keep_last`: Boolean
	- `output_path`: String
	- `analysis_unit`: String
- `random_seed`: Float, Optional
- `robots`: [RobotConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/node_factory/struct.RobotConfig.html), List
	- `name`: String
	- `navigator`: [NavigatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/navigators/navigator/enum.NavigatorConfig.html), Enum
		- `TrajectoryFollower`: [TrajectoryFollowerConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/navigators/trajectory_follower/struct.TrajectoryFollowerConfig.html)
			- `trajectory_path`: String
			- `forward_distance`: Float
			- `target_speed`: Float
		- `External`: [ExternalNavigatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/navigators/external_navigator/struct.ExternalNavigatorConfig.html)
			- `config`: User-specific struct
	- `controller`: [ControllerConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/controllers/controller/enum.ControllerConfig.html), Enum
		- `PID`: [PIDConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/controllers/pid/struct.PIDConfig.html)
			- `kp_v`: Float
			- `kd_v`: Float
			- `ki_v`: Float
			- `kp_theta`: Float
			- `kd_theta`: Float
			- `ki_theta`: Float
			- `wheel_distance`: Float
		- `External`: [ExternalControllerConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/controllers/external_controller/struct.ExternalControllerConfig.html)
			- `config`: User-specific struct
	- `physic`: [PhysicConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/physics/physic/enum.PhysicConfig.html), Enum
		- `Perfect`: [PerfectPhysicConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/physics/perfect_physic/struct.PerfectPhysicConfig.html)
			- `wheel_distance`: Float
			- `initial_state`: [StateConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/state_estimator/struct.StateConfig.html)
				- `pose`: Float, List
				- `velocity`: Float
		- `External`: [ExternalPhysicConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/physics/external_physic/struct.ExternalPhysicConfig.html)
			- `config`: User-specific struct
	- `state_estimator`: [StateEstimatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/state_estimator/enum.StateEstimatorConfig.html), Enum
		- `Perfect`: [PerfectEstimatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/perfect_estimator/struct.PerfectEstimatorConfig.html)
			- `prediction_period`: Float
			- `targets`: String, List
		- `External`: [ExternalEstimatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/external_estimator/struct.ExternalEstimatorConfig.html)
			- `config`: User-specific struct
	- `sensor_manager`: [SensorManagerConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/sensor_manager/struct.SensorManagerConfig.html)
		- `sensors`: [ManagedSensorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/sensor_manager/struct.ManagedSensorConfig.html), List
			- `name`: String
			- `send_to`: String, List
			- `config`: [SensorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/sensor/enum.SensorConfig.html), Enum
				- `OrientedLandmarkSensor`: [OrientedLandmarkSensorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/oriented_landmark_sensor/struct.OrientedLandmarkSensorConfig.html)
					- `detection_distance`: Float
					- `map_path`: String
					- `period`: Float
					- `faults`: [FaultModelConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/fault_model/enum.FaultModelConfig.html), List, Enum
						- `AdditiveRobotCentered`: [AdditiveRobotCenteredFaultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/additive_robot_centered/struct.AdditiveRobotCenteredFaultConfig.html)
							- `apparition`: [BernouilliRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/bernouilli/struct.BernouilliRandomVariableConfig.html)
								- `unique_seed`: Float
								- `probability`: Float, List
							- `distributions`: [RandomVariableTypeConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/determinist_random_variable/enum.RandomVariableTypeConfig.html), List, Enum
								- `None`
								- `Fixed`: [FixedRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/fixed/struct.FixedRandomVariableConfig.html)
									- `values`: Float, List
								- `Uniform`: [UniformRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/uniform/struct.UniformRandomVariableConfig.html)
									- `unique_seed`: Float
									- `min`: Float, List
									- `max`: Float, List
								- `Normal`: [NormalRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/normal/struct.NormalRandomVariableConfig.html)
									- `unique_seed`: Float
									- `mean`: Float, List
									- `covariance`: Float, List
								- `Poisson`: [PoissonRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/poisson/struct.PoissonRandomVariableConfig.html)
									- `unique_seed`: Float
									- `lambda`: Float, List
								- `Exponential`: [ExponentialRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/exponential/struct.ExponentialRandomVariableConfig.html)
									- `unique_seed`: Float
									- `lambda`: Float, List
							- `variable_order`: String, List
						- `AdditiveRobotCenteredPolar`: [AdditiveRobotCenteredPolarFaultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/additive_robot_centered_polar/struct.AdditiveRobotCenteredPolarFaultConfig.html)
							- `apparition`: [BernouilliRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/bernouilli/struct.BernouilliRandomVariableConfig.html), See above
							- `distributions`: [RandomVariableTypeConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/determinist_random_variable/enum.RandomVariableTypeConfig.html), See above, List
							- `variable_order`: String, List
						- `AdditiveObservationCenteredPolar`: [AdditiveObservationCenteredPolarFaultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/additive_observation_centered_polar/struct.AdditiveObservationCenteredPolarFaultConfig.html)
							- `apparition`: [BernouilliRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/bernouilli/struct.BernouilliRandomVariableConfig.html), See above
							- `distributions`: [RandomVariableTypeConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/determinist_random_variable/enum.RandomVariableTypeConfig.html), See above, List
							- `variable_order`: String, List
						- `Clutter`: [ClutterFaultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/clutter/struct.ClutterFaultConfig.html)
							- `apparition`: [RandomVariableTypeConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/determinist_random_variable/enum.RandomVariableTypeConfig.html), See above
							- `distributions`: [RandomVariableTypeConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/determinist_random_variable/enum.RandomVariableTypeConfig.html), See above, List
							- `variable_order`: String, List
							- `observation_id`: String
						- `Misdetection`: [MisdetectionFaultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/misdetection/struct.MisdetectionFaultConfig.html)
							- `apparition`: [BernouilliRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/bernouilli/struct.BernouilliRandomVariableConfig.html), See above
						- `Misassociation`: [MisassociationFaultConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/misassociation/struct.MisassociationFaultConfig.html)
							- `apparition`: [BernouilliRandomVariableConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/distributions/bernouilli/struct.BernouilliRandomVariableConfig.html), See above
							- `distribution`: [RandomVariableTypeConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/utils/determinist_random_variable/enum.RandomVariableTypeConfig.html), See above
							- `sort`: [Sort](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/misassociation/enum.Sort.html), Enum
								- `None`
								- `Random`
								- `Distance`
							- `source`: [Source](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/misassociation/enum.Source.html), Enum
								- `Map`: String
								- `Robots`
				- `OdometrySensor`: [OdometrySensorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/odometry_sensor/struct.OdometrySensorConfig.html)
					- `period`: Float
					- `faults`: [FaultModelConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/fault_model/enum.FaultModelConfig.html), See above, List
				- `GNSSSensor`: [GNSSSensorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/gnss_sensor/struct.GNSSSensorConfig.html)
					- `period`: Float
					- `faults`: [FaultModelConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/fault_model/enum.FaultModelConfig.html), See above, List
				- `RobotSensor`: [RobotSensorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/robot_sensor/struct.RobotSensorConfig.html)
					- `detection_distance`: Float
					- `period`: Float
					- `faults`: [FaultModelConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/sensors/fault_models/fault_model/enum.FaultModelConfig.html), See above, List
	- `network`: [NetworkConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/networking/network/struct.NetworkConfig.html)
		- `range`: Float
		- `reception_delay`: Float
	- `state_estimator_bench`: [BenchStateEstimatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/state_estimator/struct.BenchStateEstimatorConfig.html), List
		- `name`: String
		- `config`: [StateEstimatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/state_estimator/enum.StateEstimatorConfig.html), See above
- `computation_units`: [ComputationUnitConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/node_factory/struct.ComputationUnitConfig.html), List
	- `name`: String
	- `network`: [NetworkConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/networking/network/struct.NetworkConfig.html), See above
	- `state_estimators`: [BenchStateEstimatorConfig](https://homepages.laas.fr/mescourrou/Recherche/Logiciels/multi-robot-simulator/doc/simba/state_estimators/state_estimator/struct.BenchStateEstimatorConfig.html), See above, List
*/
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use pyo3::prelude::*;
pub mod controllers {
    /*!
Module providing the [`Controller`](controller::Controller) strategy, which computes the
[`Command`](crate::physics::physic::Command) sent to the [`Physic`](crate::physics::physic::Physic).
*/
    pub mod controller {
        /*!
Module defining the [Controller]
*/
        use crate::{
            stateful::Stateful,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use std::sync::{Arc, RwLock};
        use crate::{
            physics::physic::Command, plugin_api::PluginAPI, simulator::SimulatorConfig,
        };
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        /// Errors used by the controllers: lateral, orientation and velocity.
        pub struct ControllerError {
            /// Lateral error.
            pub lateral: f32,
            /// Orientation error.
            pub theta: f32,
            /// Velocity error.
            pub velocity: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ControllerError {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ControllerError",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "lateral",
                        &self.lateral,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "theta",
                        &self.theta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "velocity",
                        &self.velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ControllerError {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lateral" => _serde::__private::Ok(__Field::__field0),
                                "theta" => _serde::__private::Ok(__Field::__field1),
                                "velocity" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lateral" => _serde::__private::Ok(__Field::__field0),
                                b"theta" => _serde::__private::Ok(__Field::__field1),
                                b"velocity" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ControllerError>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ControllerError;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ControllerError",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ControllerError with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ControllerError with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ControllerError with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ControllerError {
                                lateral: __field0,
                                theta: __field1,
                                velocity: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "lateral",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("theta"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "velocity",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lateral")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("theta")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("velocity")?
                                }
                            };
                            _serde::__private::Ok(ControllerError {
                                lateral: __field0,
                                theta: __field1,
                                velocity: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "lateral",
                        "theta",
                        "velocity",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ControllerError",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ControllerError>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ControllerError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ControllerError",
                    "lateral",
                    &self.lateral,
                    "theta",
                    &self.theta,
                    "velocity",
                    &&self.velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ControllerError {
            #[inline]
            fn clone(&self) -> ControllerError {
                ControllerError {
                    lateral: ::core::clone::Clone::clone(&self.lateral),
                    theta: ::core::clone::Clone::clone(&self.theta),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                }
            }
        }
        impl ControllerError {
            pub fn default() -> Self {
                Self {
                    lateral: 0.,
                    theta: 0.,
                    velocity: 0.,
                }
            }
        }
        use super::{external_controller, pid};
        /// Enumerates the strategies configurations.
        #[serde(deny_unknown_fields)]
        pub enum ControllerConfig {
            PID(Box<pid::PIDConfig>),
            External(Box<external_controller::ExternalControllerConfig>),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ControllerConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ControllerConfig::PID(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ControllerConfig",
                                0u32,
                                "PID",
                                __field0,
                            )
                        }
                        ControllerConfig::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ControllerConfig",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ControllerConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "PID" => _serde::__private::Ok(__Field::__field0),
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"PID" => _serde::__private::Ok(__Field::__field0),
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ControllerConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ControllerConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ControllerConfig",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<pid::PIDConfig>,
                                        >(__variant),
                                        ControllerConfig::PID,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<external_controller::ExternalControllerConfig>,
                                        >(__variant),
                                        ControllerConfig::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["PID", "External"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ControllerConfig",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ControllerConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ControllerConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ControllerConfig::PID(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "PID",
                            &__self_0,
                        )
                    }
                    ControllerConfig::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ControllerConfig {
            #[inline]
            fn clone(&self) -> ControllerConfig {
                match self {
                    ControllerConfig::PID(__self_0) => {
                        ControllerConfig::PID(::core::clone::Clone::clone(__self_0))
                    }
                    ControllerConfig::External(__self_0) => {
                        ControllerConfig::External(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for ControllerConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                match &self {
                    ControllerConfig::PID(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "PID",
                                        "ControllerConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    ControllerConfig::External(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "External",
                                        "ControllerConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    _ => {}
                };
                ret
            }
        }
        /// Enumerates the strategies records.
        pub enum ControllerRecord {
            PID(pid::PIDRecord),
            External(external_controller::ExternalControllerRecord),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ControllerRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ControllerRecord::PID(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ControllerRecord",
                                0u32,
                                "PID",
                                __field0,
                            )
                        }
                        ControllerRecord::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ControllerRecord",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ControllerRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "PID" => _serde::__private::Ok(__Field::__field0),
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"PID" => _serde::__private::Ok(__Field::__field0),
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ControllerRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ControllerRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ControllerRecord",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            pid::PIDRecord,
                                        >(__variant),
                                        ControllerRecord::PID,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            external_controller::ExternalControllerRecord,
                                        >(__variant),
                                        ControllerRecord::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["PID", "External"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ControllerRecord",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ControllerRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ControllerRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ControllerRecord::PID(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "PID",
                            &__self_0,
                        )
                    }
                    ControllerRecord::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ControllerRecord {
            #[inline]
            fn clone(&self) -> ControllerRecord {
                match self {
                    ControllerRecord::PID(__self_0) => {
                        ControllerRecord::PID(::core::clone::Clone::clone(__self_0))
                    }
                    ControllerRecord::External(__self_0) => {
                        ControllerRecord::External(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        use crate::node::Node;
        /// Controller strategy, which compute the [`Command`] to be sent to the
        /// [`Physic`](crate::physics::physic::Physic) module, from the given `error`.
        pub trait Controller: std::fmt::Debug + std::marker::Send + std::marker::Sync + Stateful<
                ControllerRecord,
            > {
            /// Compute the command from the given error.
            ///
            /// ## Arguments
            /// * `robot` - Reference to the robot to access modules.
            /// * `error` - Error to be corrected.
            /// * `time` - Current time.
            ///
            /// ## Return
            /// Command to apply to the [`Physic`](crate::physics::physic::Physic).
            fn make_command(
                &mut self,
                robot: &mut Node,
                error: &ControllerError,
                time: f32,
            ) -> Command;
        }
        /// Helper function to make the right [`Controller`] from the given configuration.
        ///
        /// ## Arguments
        /// * `config` - Configuration to use to make the controller.
        /// * `plugin_api` - Optional PluginAPI to transmit to the controller.
        /// * `meta_config` - Meta configuration of the simulator.
        /// * `va_factory` - Random variables factory for determinist behavior.
        pub fn make_controller_from_config(
            config: &ControllerConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
            va_factory: &DeterministRandomVariableFactory,
        ) -> Arc<RwLock<Box<dyn Controller>>> {
            Arc::new(
                RwLock::new(
                    match config {
                        ControllerConfig::PID(c) => {
                            Box::new(
                                pid::PID::from_config(
                                    c,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ) as Box<dyn Controller>
                        }
                        ControllerConfig::External(c) => {
                            Box::new(
                                external_controller::ExternalController::from_config(
                                    c,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ) as Box<dyn Controller>
                        }
                    },
                ),
            )
        }
    }
    pub mod external_controller {
        /*!
Module providing the interface to use external [`Controller`].

To make your own external controller strategy, the simulator should
be used as a library (see [dedicated page](crate::plugin_api)).

Your own external controller strategy is made using the
[`PluginAPI::get_controller`] function.

For the [`Stateful`] trait, the generic type is [`ControllerRecord`],
and your implementation should return a [`ControllerRecord::External`]
type. The value inside is a [`serde_json::Value`]. Use [`serde_json::to_value`]
and [`serde_json::from_value`] to make the bridge to your own Record struct.
*/
        use config_checker::macros::Check;
        use pyo3::{pyclass, pymethods};
        use serde_json::Value;
        use crate::physics::physic::Command;
        use crate::simulator::SimulatorConfig;
        use crate::stateful::Stateful;
        use crate::{
            plugin_api::PluginAPI,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use super::controller::{Controller, ControllerError, ControllerRecord};
        use serde_derive::{Deserialize, Serialize};
        /// Config for the external controller (generic).
        ///
        /// The config for [`ExternalController`] uses a [`serde_json::Value`] to
        /// integrate your own configuration inside the full simulator config.
        ///
        /// In the yaml file, the config could be:
        /// ```YAML
        /// controller:
        ///     External:
        ///         parameter_of_my_own_controller: true
        /// ```
        #[serde(default)]
        pub struct ExternalControllerConfig {
            /// Config serialized.
            #[serde(flatten)]
            pub config: Value,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalControllerConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.config,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalControllerConfig
            where
                ExternalControllerConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        ExternalControllerConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<ExternalControllerConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        ExternalControllerConfig: _serde::__private::Default,
                    {
                        type Value = ExternalControllerConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalControllerConfig",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalControllerConfig {
                                config: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalControllerConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalControllerConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalControllerConfig",
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalControllerConfig {
            #[inline]
            fn clone(&self) -> ExternalControllerConfig {
                ExternalControllerConfig {
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for ExternalControllerConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                ret
            }
        }
        impl Default for ExternalControllerConfig {
            fn default() -> Self {
                Self { config: Value::Null }
            }
        }
        /// Record for the external controller (generic).
        ///
        /// Like [`ExternalControllerConfig`], [`ExternalController`] uses a [`serde_json::Value`]
        /// to take every record.
        ///
        /// The record is not automatically cast to your own type, the cast should be done
        /// in [`Stateful::from_record`] and [`Stateful::record`] implementations.
        pub struct ExternalControllerRecord {
            /// Record serialized.
            #[serde(flatten)]
            pub record: Value,
        }
        impl ::pyo3::types::DerefToPyAny for ExternalControllerRecord {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for ExternalControllerRecord {
            const NAME: &'static str = "ExternalControllerRecord";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <ExternalControllerRecord as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for ExternalControllerRecord {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a ExternalControllerRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRef<'py, ExternalControllerRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut ExternalControllerRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRefMut<'py, ExternalControllerRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for ExternalControllerRecord {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for ExternalControllerRecord {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                ExternalControllerRecord,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <ExternalControllerRecord as ::pyo3::PyTypeInfo>::NAME,
                                c"Record for the external controller (generic).\n\nLike [`ExternalControllerConfig`], [`ExternalController`] uses a [`serde_json::Value`]\nto take every record.\n\nThe record is not automatically cast to your own type, the cast should be done\nin [`Stateful::from_record`] and [`Stateful::record`] implementations.",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ExternalControllerRecord> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalControllerRecord {}
        impl ExternalControllerRecord {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalControllerRecord {}
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalControllerRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.record,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalControllerRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ExternalControllerRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ExternalControllerRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalControllerRecord",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalControllerRecord {
                                record: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalControllerRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalControllerRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalControllerRecord",
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalControllerRecord {
            #[inline]
            fn clone(&self) -> ExternalControllerRecord {
                ExternalControllerRecord {
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        impl Default for ExternalControllerRecord {
            fn default() -> Self {
                Self { record: Value::Null }
            }
        }
        impl ExternalControllerRecord {
            fn record(&self) -> String {
                self.record.to_string()
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<ExternalControllerRecord>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<ExternalControllerRecord> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                            ::pyo3::class::PyMethodDefType::Getter(
                                ::pyo3::class::PyGetterDef::new(
                                    c"record",
                                    ExternalControllerRecord::__pymethod_get_record__,
                                    c"",
                                ),
                            ),
                        ),
                    ],
                    slots: &[],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalControllerRecord {
            unsafe fn __pymethod_get_record__(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let result = ::pyo3::callback::convert(
                    py,
                    ExternalControllerRecord::record(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            ExternalControllerRecord,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_0,
                        )?,
                    ),
                );
                result
            }
        }
        use crate::node::Node;
        /// External controller strategy, which does the bridge with your own strategy.
        pub struct ExternalController {
            /// External controller.
            controller: Box<dyn Controller>,
        }
        impl ExternalController {
            /// Creates a new [`ExternalController`]
            pub fn new() -> Self {
                Self::from_config(
                    &ExternalControllerConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Creates a new [`ExternalController`] from the given config.
            ///
            /// <div class="warning">The `plugin_api` is required here !</div>
            ///
            ///  ## Arguments
            /// * `config` -- Scenario config of the External controller.
            /// * `plugin_api` -- Required [`PluginAPI`] implementation.
            /// * `global_config` -- Simulator config.
            /// * `_va_factory` -- Factory for Determinists random variables
            pub fn from_config(
                config: &ExternalControllerConfig,
                plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                {
                    ::std::io::_print(format_args!("Config given: {0:?}\n", config));
                };
                Self {
                    controller: plugin_api
                        .as_ref()
                        .expect("Plugin API not set!")
                        .get_controller(&config.config, global_config),
                }
            }
        }
        impl std::fmt::Debug for ExternalController {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("ExternalController {{}}"))
            }
        }
        impl Controller for ExternalController {
            fn make_command(
                &mut self,
                robot: &mut Node,
                error: &ControllerError,
                time: f32,
            ) -> Command {
                self.controller.make_command(robot, error, time)
            }
        }
        impl Stateful<ControllerRecord> for ExternalController {
            fn record(&self) -> ControllerRecord {
                self.controller.record()
            }
            fn from_record(&mut self, record: ControllerRecord) {
                self.controller.from_record(record);
            }
        }
    }
    pub mod pid {
        /*!
Module providing the [`PID`] specification for the [`Controller`] strategy.

The [`PID`] controller uses three derivative of the error:
- `Proportional` - error itself
- `Integral` - integration of the error
- `Derivative` - derivative of the error

Each component has a gain, which can be set in [`PIDConfig`].
*/
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use config_checker::macros::Check;
        use log::error;
        use serde_derive::{Deserialize, Serialize};
        /// Configuration of the [`PID`], it contains the 3 gains for the velocity
        /// control, 3 gain for the orientation control, and the wheel distance.
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct PIDConfig {
            #[check(ge(0.))]
            pub kp_v: f32,
            #[check(ge(0.))]
            pub kd_v: f32,
            #[check(ge(0.))]
            pub ki_v: f32,
            #[check(ge(0.))]
            pub kp_theta: f32,
            #[check(ge(0.))]
            pub kd_theta: f32,
            #[check(ge(0.))]
            pub ki_theta: f32,
            #[check(ge(0.))]
            pub wheel_distance: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PIDConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PIDConfig",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kp_v",
                        &self.kp_v,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kd_v",
                        &self.kd_v,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "ki_v",
                        &self.ki_v,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kp_theta",
                        &self.kp_theta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kd_theta",
                        &self.kd_theta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "ki_theta",
                        &self.ki_theta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "wheel_distance",
                        &self.wheel_distance,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PIDConfig
            where
                PIDConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 7",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "kp_v" => _serde::__private::Ok(__Field::__field0),
                                "kd_v" => _serde::__private::Ok(__Field::__field1),
                                "ki_v" => _serde::__private::Ok(__Field::__field2),
                                "kp_theta" => _serde::__private::Ok(__Field::__field3),
                                "kd_theta" => _serde::__private::Ok(__Field::__field4),
                                "ki_theta" => _serde::__private::Ok(__Field::__field5),
                                "wheel_distance" => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"kp_v" => _serde::__private::Ok(__Field::__field0),
                                b"kd_v" => _serde::__private::Ok(__Field::__field1),
                                b"ki_v" => _serde::__private::Ok(__Field::__field2),
                                b"kp_theta" => _serde::__private::Ok(__Field::__field3),
                                b"kd_theta" => _serde::__private::Ok(__Field::__field4),
                                b"ki_theta" => _serde::__private::Ok(__Field::__field5),
                                b"wheel_distance" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        PIDConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<PIDConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        PIDConfig: _serde::__private::Default,
                    {
                        type Value = PIDConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PIDConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.kp_v,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.kd_v,
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.ki_v,
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.kp_theta,
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.kd_theta,
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.ki_theta,
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.wheel_distance,
                            };
                            _serde::__private::Ok(PIDConfig {
                                kp_v: __field0,
                                kd_v: __field1,
                                ki_v: __field2,
                                kp_theta: __field3,
                                kd_theta: __field4,
                                ki_theta: __field5,
                                wheel_distance: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("kp_v"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("kd_v"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("ki_v"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "kp_theta",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "kd_theta",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "ki_theta",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "wheel_distance",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.kp_v,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.kd_v,
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => __default.ki_v,
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => __default.kp_theta,
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => __default.kd_theta,
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => __default.ki_theta,
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => __default.wheel_distance,
                            };
                            _serde::__private::Ok(PIDConfig {
                                kp_v: __field0,
                                kd_v: __field1,
                                ki_v: __field2,
                                kp_theta: __field3,
                                kd_theta: __field4,
                                ki_theta: __field5,
                                wheel_distance: __field6,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "kp_v",
                        "kd_v",
                        "ki_v",
                        "kp_theta",
                        "kd_theta",
                        "ki_theta",
                        "wheel_distance",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PIDConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PIDConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PIDConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "kp_v",
                    "kd_v",
                    "ki_v",
                    "kp_theta",
                    "kd_theta",
                    "ki_theta",
                    "wheel_distance",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.kp_v,
                    &self.kd_v,
                    &self.ki_v,
                    &self.kp_theta,
                    &self.kd_theta,
                    &self.ki_theta,
                    &&self.wheel_distance,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PIDConfig",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PIDConfig {
            #[inline]
            fn clone(&self) -> PIDConfig {
                PIDConfig {
                    kp_v: ::core::clone::Clone::clone(&self.kp_v),
                    kd_v: ::core::clone::Clone::clone(&self.kd_v),
                    ki_v: ::core::clone::Clone::clone(&self.ki_v),
                    kp_theta: ::core::clone::Clone::clone(&self.kp_theta),
                    kd_theta: ::core::clone::Clone::clone(&self.kd_theta),
                    ki_theta: ::core::clone::Clone::clone(&self.ki_theta),
                    wheel_distance: ::core::clone::Clone::clone(&self.wheel_distance),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for PIDConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.kp_v >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "kp_v",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.kd_v >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "kd_v",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.ki_v >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "ki_v",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.kp_theta >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "kp_theta",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.kd_theta >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "kd_theta",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.ki_theta >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "ki_theta",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.wheel_distance >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "wheel_distance",
                                "PIDConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                ret
            }
        }
        impl Default for PIDConfig {
            /// Defaut PID configuration.
            ///
            /// - Velocity: Proportionnal 1, others 0
            /// - Orientation: P=1., D=0.1
            /// - Wheel distance: 0.25
            fn default() -> Self {
                Self {
                    kp_v: 1.0,
                    kd_v: 0.,
                    ki_v: 0.,
                    kp_theta: 1.,
                    kd_theta: 0.1,
                    ki_theta: 0.,
                    wheel_distance: 0.25,
                }
            }
        }
        /// Record of the [`PID`] controller.
        pub struct PIDRecord {
            pub v_integral: f32,
            pub theta_integral: f32,
            pub velocity: f32,
            pub command: Command,
            pub last_command_time: f32,
            pub previous_velocity_error: f32,
            pub previous_theta_error: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PIDRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PIDRecord",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "v_integral",
                        &self.v_integral,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "theta_integral",
                        &self.theta_integral,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "velocity",
                        &self.velocity,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "command",
                        &self.command,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_command_time",
                        &self.last_command_time,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "previous_velocity_error",
                        &self.previous_velocity_error,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "previous_theta_error",
                        &self.previous_theta_error,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PIDRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "v_integral" => _serde::__private::Ok(__Field::__field0),
                                "theta_integral" => _serde::__private::Ok(__Field::__field1),
                                "velocity" => _serde::__private::Ok(__Field::__field2),
                                "command" => _serde::__private::Ok(__Field::__field3),
                                "last_command_time" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "previous_velocity_error" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "previous_theta_error" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"v_integral" => _serde::__private::Ok(__Field::__field0),
                                b"theta_integral" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"velocity" => _serde::__private::Ok(__Field::__field2),
                                b"command" => _serde::__private::Ok(__Field::__field3),
                                b"last_command_time" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"previous_velocity_error" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"previous_theta_error" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PIDRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PIDRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PIDRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Command,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct PIDRecord with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PIDRecord {
                                v_integral: __field0,
                                theta_integral: __field1,
                                velocity: __field2,
                                command: __field3,
                                last_command_time: __field4,
                                previous_velocity_error: __field5,
                                previous_theta_error: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Command> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "v_integral",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "theta_integral",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "velocity",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "command",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Command>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_command_time",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "previous_velocity_error",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "previous_theta_error",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("v_integral")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("theta_integral")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("velocity")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("command")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_command_time")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "previous_velocity_error",
                                    )?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "previous_theta_error",
                                    )?
                                }
                            };
                            _serde::__private::Ok(PIDRecord {
                                v_integral: __field0,
                                theta_integral: __field1,
                                velocity: __field2,
                                command: __field3,
                                last_command_time: __field4,
                                previous_velocity_error: __field5,
                                previous_theta_error: __field6,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "v_integral",
                        "theta_integral",
                        "velocity",
                        "command",
                        "last_command_time",
                        "previous_velocity_error",
                        "previous_theta_error",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PIDRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PIDRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PIDRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "v_integral",
                    "theta_integral",
                    "velocity",
                    "command",
                    "last_command_time",
                    "previous_velocity_error",
                    "previous_theta_error",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.v_integral,
                    &self.theta_integral,
                    &self.velocity,
                    &self.command,
                    &self.last_command_time,
                    &self.previous_velocity_error,
                    &&self.previous_theta_error,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PIDRecord",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PIDRecord {
            #[inline]
            fn clone(&self) -> PIDRecord {
                PIDRecord {
                    v_integral: ::core::clone::Clone::clone(&self.v_integral),
                    theta_integral: ::core::clone::Clone::clone(&self.theta_integral),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                    command: ::core::clone::Clone::clone(&self.command),
                    last_command_time: ::core::clone::Clone::clone(
                        &self.last_command_time,
                    ),
                    previous_velocity_error: ::core::clone::Clone::clone(
                        &self.previous_velocity_error,
                    ),
                    previous_theta_error: ::core::clone::Clone::clone(
                        &self.previous_theta_error,
                    ),
                }
            }
        }
        impl Default for PIDRecord {
            fn default() -> Self {
                Self {
                    v_integral: 0.,
                    theta_integral: 0.,
                    velocity: 0.,
                    command: Command {
                        left_wheel_speed: 0.,
                        right_wheel_speed: 0.,
                    },
                    last_command_time: 0.,
                    previous_velocity_error: 0.,
                    previous_theta_error: 0.,
                }
            }
        }
        /// Proportional-integral-derivative controller for velocity and angle.
        pub struct PID {
            /// Velocity proportional gain
            kp_v: f32,
            /// Velocity derivative gain
            kd_v: f32,
            /// Velocity integral gain
            ki_v: f32,
            /// Orientation proportional gain
            kp_theta: f32,
            /// Orientation derivative gain
            kd_theta: f32,
            /// Orientation integral gain
            ki_theta: f32,
            /// Distance between the wheels
            wheel_distance: f32,
            /// Time of the last command
            last_command_time: f32,
            /// Current integral of the velocity
            v_integral: f32,
            /// Current integral of the orientation
            theta_integral: f32,
            /// Previous velocity error to compute the derivative
            previous_velocity_error: f32,
            /// Previous orientation error to compute the derivative
            previous_theta_error: f32,
            /// Current velocity
            velocity: f32,
            /// Current record
            current_record: PIDRecord,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PID {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "kp_v",
                    "kd_v",
                    "ki_v",
                    "kp_theta",
                    "kd_theta",
                    "ki_theta",
                    "wheel_distance",
                    "last_command_time",
                    "v_integral",
                    "theta_integral",
                    "previous_velocity_error",
                    "previous_theta_error",
                    "velocity",
                    "current_record",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.kp_v,
                    &self.kd_v,
                    &self.ki_v,
                    &self.kp_theta,
                    &self.kd_theta,
                    &self.ki_theta,
                    &self.wheel_distance,
                    &self.last_command_time,
                    &self.v_integral,
                    &self.theta_integral,
                    &self.previous_velocity_error,
                    &self.previous_theta_error,
                    &self.velocity,
                    &&self.current_record,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PID",
                    names,
                    values,
                )
            }
        }
        impl PID {
            /// Makes a new default PID.
            pub fn new() -> Self {
                Self::from_config(
                    &PIDConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Makes a new [`PID`] from the given `config`.
            pub fn from_config(
                config: &PIDConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                _global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                PID {
                    kp_v: config.kp_v,
                    kd_v: config.kd_v,
                    ki_v: config.ki_v,
                    kp_theta: config.kp_theta,
                    kd_theta: config.kd_theta,
                    ki_theta: config.ki_theta,
                    wheel_distance: config.wheel_distance,
                    last_command_time: 0.,
                    v_integral: 0.,
                    theta_integral: 0.,
                    previous_velocity_error: 0.,
                    previous_theta_error: 0.,
                    velocity: 0.,
                    current_record: PIDRecord::default(),
                }
            }
        }
        use super::controller::{Controller, ControllerRecord};
        use crate::controllers::controller::ControllerError;
        use crate::node::Node;
        use crate::physics::physic::Command;
        impl Controller for PID {
            fn make_command(
                &mut self,
                _robot: &mut Node,
                error: &ControllerError,
                time: f32,
            ) -> Command {
                let dt = time - self.last_command_time;
                if !(dt > 0.) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "PID delta time should be positive: {0} - {1} = {2} > 0",
                                time,
                                self.last_command_time,
                                dt,
                            ),
                        );
                    }
                }
                self.v_integral += error.velocity * dt;
                self.theta_integral += error.theta * dt;
                let v_derivative = (error.velocity - self.previous_velocity_error) / dt;
                let theta_derivative = (error.theta - self.previous_theta_error) / dt;
                let correction_theta = (self.kp_theta * error.theta
                    + self.ki_theta * self.theta_integral
                    + self.kd_theta * theta_derivative) * self.wheel_distance;
                let correction_v = self.kp_v * error.velocity
                    + self.ki_v * self.v_integral + self.kd_v * v_derivative;
                self.velocity = self.velocity + correction_v;
                self.previous_theta_error = error.theta;
                self.previous_velocity_error = error.velocity;
                self.last_command_time = time;
                let command = Command {
                    left_wheel_speed: self.velocity - correction_theta / 2.,
                    right_wheel_speed: self.velocity + correction_theta / 2.,
                };
                self.current_record = PIDRecord {
                    v_integral: self.v_integral,
                    theta_integral: self.theta_integral,
                    velocity: self.velocity,
                    command: command.clone(),
                    last_command_time: self.last_command_time,
                    previous_theta_error: self.previous_theta_error,
                    previous_velocity_error: self.previous_velocity_error,
                };
                command
            }
        }
        impl Stateful<ControllerRecord> for PID {
            fn record(&self) -> ControllerRecord {
                ControllerRecord::PID(self.current_record.clone())
            }
            #[allow(irrefutable_let_patterns)]
            fn from_record(&mut self, record: ControllerRecord) {
                if let ControllerRecord::PID(pid_record) = record {
                    self.current_record = pid_record.clone();
                    self.v_integral = pid_record.v_integral;
                    self.theta_integral = pid_record.theta_integral;
                    self.velocity = pid_record.velocity;
                    self.last_command_time = pid_record.last_command_time;
                    self.previous_theta_error = pid_record.previous_theta_error;
                    self.previous_velocity_error = pid_record.previous_velocity_error;
                } else {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Using a ControllerRecord type which does not match the used Controller (PID)",
                                    ),
                                    lvl,
                                    &(
                                        "simba::controllers::pid",
                                        "simba::controllers::pid",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
        }
    }
    pub mod pybinds {
        use std::{str::FromStr, sync::{mpsc, Arc, Mutex}};
        use log::debug;
        use pyo3::prelude::*;
        use serde_json::Value;
        use crate::{
            controllers::external_controller::ExternalControllerRecord,
            logger::is_enabled, node::Node, node_factory::NodeRecord,
            physics::physic::Command,
            pywrappers::{CommandWrapper, ControllerErrorWrapper},
            stateful::Stateful,
        };
        use super::controller::{Controller, ControllerError, ControllerRecord};
        pub struct PythonControllerAsyncClient {
            pub make_command_request: mpsc::Sender<(ControllerError, f32)>,
            pub make_command_response: Arc<Mutex<mpsc::Receiver<Command>>>,
            pub record_request: mpsc::Sender<()>,
            pub record_response: Arc<Mutex<mpsc::Receiver<ControllerRecord>>>,
            pub from_record_request: mpsc::Sender<ControllerRecord>,
            pub from_record_response: Arc<Mutex<mpsc::Receiver<()>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonControllerAsyncClient {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "make_command_request",
                    "make_command_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.make_command_request,
                    &self.make_command_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonControllerAsyncClient",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PythonControllerAsyncClient {
            #[inline]
            fn clone(&self) -> PythonControllerAsyncClient {
                PythonControllerAsyncClient {
                    make_command_request: ::core::clone::Clone::clone(
                        &self.make_command_request,
                    ),
                    make_command_response: ::core::clone::Clone::clone(
                        &self.make_command_response,
                    ),
                    record_request: ::core::clone::Clone::clone(&self.record_request),
                    record_response: ::core::clone::Clone::clone(&self.record_response),
                    from_record_request: ::core::clone::Clone::clone(
                        &self.from_record_request,
                    ),
                    from_record_response: ::core::clone::Clone::clone(
                        &self.from_record_response,
                    ),
                }
            }
        }
        impl Controller for PythonControllerAsyncClient {
            fn make_command(
                &mut self,
                _node: &mut Node,
                error: &ControllerError,
                time: f32,
            ) -> Command {
                self.make_command_request.send((error.clone(), time)).unwrap();
                self.make_command_response.lock().unwrap().recv().unwrap()
            }
        }
        impl Stateful<ControllerRecord> for PythonControllerAsyncClient {
            fn from_record(&mut self, record: ControllerRecord) {
                self.from_record_request.send(record).unwrap();
                self.from_record_response.lock().unwrap().recv().unwrap();
            }
            fn record(&self) -> ControllerRecord {
                self.record_request.send(()).unwrap();
                self.record_response
                    .lock()
                    .unwrap()
                    .recv()
                    .expect("Error during call of record")
            }
        }
        pub struct PythonController {
            model: Py<PyAny>,
            client: PythonControllerAsyncClient,
            make_command_request: Arc<Mutex<mpsc::Receiver<(ControllerError, f32)>>>,
            make_command_response: mpsc::Sender<Command>,
            record_request: Arc<Mutex<mpsc::Receiver<()>>>,
            record_response: mpsc::Sender<ControllerRecord>,
            from_record_request: Arc<Mutex<mpsc::Receiver<ControllerRecord>>>,
            from_record_response: mpsc::Sender<()>,
        }
        impl ::pyo3::types::DerefToPyAny for PythonController {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for PythonController {
            const NAME: &'static str = "Controller";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <PythonController as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for PythonController {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a PythonController {
            type Holder = ::std::option::Option<::pyo3::PyRef<'py, PythonController>>;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut PythonController {
            type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, PythonController>>;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for PythonController {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for PythonController {
            const IS_BASETYPE: bool = true;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                PythonController,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <PythonController as ::pyo3::PyTypeInfo>::NAME,
                                c"",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<PythonController> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonController {}
        impl PythonController {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonController {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonController {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "model",
                    "client",
                    "make_command_request",
                    "make_command_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.model,
                    &self.client,
                    &self.make_command_request,
                    &self.make_command_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonController",
                    names,
                    values,
                )
            }
        }
        impl PythonController {
            pub fn new(py_model: Py<PyAny>) -> PythonController {
                if is_enabled(crate::logger::InternalLog::API) {
                    Python::with_gil(|py| {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Model got: {0}",
                                            py_model.bind(py).dir().unwrap(),
                                        ),
                                        lvl,
                                        &(
                                            "simba::controllers::pybinds",
                                            "simba::controllers::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    });
                }
                let (make_command_request_tx, make_command_request_rx) = mpsc::channel();
                let (make_command_response_tx, make_command_response_rx) = mpsc::channel();
                let (record_request_tx, record_request_rx) = mpsc::channel();
                let (record_response_tx, record_response_rx) = mpsc::channel();
                let (from_record_request_tx, from_record_request_rx) = mpsc::channel();
                let (from_record_response_tx, from_record_response_rx) = mpsc::channel();
                PythonController {
                    model: py_model,
                    client: PythonControllerAsyncClient {
                        make_command_request: make_command_request_tx,
                        make_command_response: Arc::new(
                            Mutex::new(make_command_response_rx),
                        ),
                        record_request: record_request_tx,
                        record_response: Arc::new(Mutex::new(record_response_rx)),
                        from_record_request: from_record_request_tx,
                        from_record_response: Arc::new(
                            Mutex::new(from_record_response_rx),
                        ),
                    },
                    make_command_request: Arc::new(Mutex::new(make_command_request_rx)),
                    make_command_response: make_command_response_tx,
                    record_request: Arc::new(Mutex::new(record_request_rx)),
                    record_response: record_response_tx,
                    from_record_request: Arc::new(Mutex::new(from_record_request_rx)),
                    from_record_response: from_record_response_tx,
                }
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<PythonController>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<PythonController> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[],
                    slots: &[
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut ::pyo3::ffi::PyTypeObject,
                                    args: *mut ::pyo3::ffi::PyObject,
                                    kwargs: *mut ::pyo3::ffi::PyObject,
                                ) -> *mut ::pyo3::ffi::PyObject {
                                    use ::pyo3::impl_::pyclass::*;
                                    #[allow(unknown_lints, non_local_definitions)]
                                    impl PyClassNewTextSignature<PythonController>
                                    for PyClassImplCollector<PythonController> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str> {
                                            ::std::option::Option::Some("(py_model)")
                                        }
                                    }
                                    ::pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        PythonController::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as ::pyo3::ffi::newfunc as _,
                        },
                    ],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonController {
            unsafe fn __pymethod___new____(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyTypeObject,
                _args: *mut ::pyo3::ffi::PyObject,
                _kwargs: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                use ::pyo3::callback::IntoPyCallbackOutput;
                let _slf_ref = &_slf;
                let function = PythonController::new;
                const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::Some(
                        <PythonController as ::pyo3::type_object::PyTypeInfo>::NAME,
                    ),
                    func_name: "__new__",
                    positional_parameter_names: &["py_model"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) = DESCRIPTION
                    .extract_arguments_tuple_dict::<
                        ::pyo3::impl_::extract_argument::NoVarargs,
                        ::pyo3::impl_::extract_argument::NoVarkeywords,
                    >(py, _args, _kwargs, &mut output)?;
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
                let result = PythonController::new(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "py_model",
                        )?,
                        &gil_refs_checker_0,
                    ),
                );
                let initializer: ::pyo3::PyClassInitializer<PythonController> = result
                    .convert(py)?;
                gil_refs_checker_0.function_arg();
                ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
            }
        }
        impl PythonController {
            pub fn get_client(&self) -> PythonControllerAsyncClient {
                self.client.clone()
            }
            pub fn check_requests(&mut self) {
                if let Ok((error, time)) = self
                    .make_command_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    let command = self.make_command(&error, time);
                    self.make_command_response.send(command).unwrap();
                }
                if let Ok(()) = self.record_request.clone().lock().unwrap().try_recv() {
                    self.record_response.send(self.record()).unwrap();
                }
                if let Ok(record) = self
                    .from_record_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.from_record(record);
                    self.from_record_response.send(()).unwrap();
                }
            }
            fn make_command(&mut self, error: &ControllerError, time: f32) -> Command {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of make_command",
                                    ),
                                    lvl,
                                    &(
                                        "simba::controllers::pybinds",
                                        "simba::controllers::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let result = Python::with_gil(|py| -> CommandWrapper {
                    self.model
                        .bind(py)
                        .call_method(
                            "make_command",
                            (ControllerErrorWrapper::from_rust(error), time),
                            None,
                        )
                        .expect(
                            "PythonController does not have a correct 'make_command' method",
                        )
                        .extract()
                        .expect(
                            "Error during the call of Python implementation of 'make_command'",
                        )
                });
                result.to_rust()
            }
            fn record(&self) -> ControllerRecord {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Calling python implementation of record"),
                                    lvl,
                                    &(
                                        "simba::controllers::pybinds",
                                        "simba::controllers::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let record_str: String = Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("record", (), None)
                        .expect(
                            "Python implementation of PythonController does not have a correct 'record' method",
                        )
                        .extract()
                        .expect(
                            "The 'record' method of PythonController does not return a valid EstimatorRecord type",
                        )
                });
                let record = ExternalControllerRecord {
                    record: Value::from_str(record_str.as_str())
                        .expect(
                            "Impossible to get serde_json::Value from the input serialized python structure",
                        ),
                };
                ControllerRecord::External(record)
            }
            fn from_record(&mut self, record: ControllerRecord) {
                if let ControllerRecord::External(record) = record {
                    if is_enabled(crate::logger::InternalLog::API) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Calling python implementation of from_record",
                                        ),
                                        lvl,
                                        &(
                                            "simba::controllers::pybinds",
                                            "simba::controllers::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    Python::with_gil(|py| {
                        self.model
                            .bind(py)
                            .call_method(
                                "from_record",
                                (serde_json::to_string(&record).unwrap(),),
                                None,
                            )
                            .expect(
                                "Python implementation of PythonController does not have a correct 'from_record' method",
                            );
                    });
                }
            }
        }
    }
}
pub mod logger {
    use std::{fmt::Display, ops::DerefMut, sync::{Arc, Mutex, RwLock}};
    use config_checker::macros::Check;
    use libm::tanhf;
    use serde::{Deserialize, Serialize};
    use simba_macros::ToVec;
    use crate::{
        gui::{
            utils::{enum_checkbox, enum_radio, string_checkbox},
            UIComponent,
        },
        simulator::SimulatorConfig, utils::enum_tools::ToVec,
    };
    static INTERNAL_LOG_LEVEL: RwLock<Vec<InternalLog>> = RwLock::new(Vec::new());
    pub enum LogLevel {
        Off,
        Error,
        Warn,
        Info,
        Debug,
        Internal(Vec<InternalLog>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LogLevel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                LogLevel::Off => ::core::fmt::Formatter::write_str(f, "Off"),
                LogLevel::Error => ::core::fmt::Formatter::write_str(f, "Error"),
                LogLevel::Warn => ::core::fmt::Formatter::write_str(f, "Warn"),
                LogLevel::Info => ::core::fmt::Formatter::write_str(f, "Info"),
                LogLevel::Debug => ::core::fmt::Formatter::write_str(f, "Debug"),
                LogLevel::Internal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Internal",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for LogLevel {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    LogLevel::Off => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "LogLevel",
                            0u32,
                            "Off",
                        )
                    }
                    LogLevel::Error => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "LogLevel",
                            1u32,
                            "Error",
                        )
                    }
                    LogLevel::Warn => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "LogLevel",
                            2u32,
                            "Warn",
                        )
                    }
                    LogLevel::Info => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "LogLevel",
                            3u32,
                            "Info",
                        )
                    }
                    LogLevel::Debug => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "LogLevel",
                            4u32,
                            "Debug",
                        )
                    }
                    LogLevel::Internal(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "LogLevel",
                            5u32,
                            "Internal",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for LogLevel {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 6",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Off" => _serde::__private::Ok(__Field::__field0),
                            "Error" => _serde::__private::Ok(__Field::__field1),
                            "Warn" => _serde::__private::Ok(__Field::__field2),
                            "Info" => _serde::__private::Ok(__Field::__field3),
                            "Debug" => _serde::__private::Ok(__Field::__field4),
                            "Internal" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Off" => _serde::__private::Ok(__Field::__field0),
                            b"Error" => _serde::__private::Ok(__Field::__field1),
                            b"Warn" => _serde::__private::Ok(__Field::__field2),
                            b"Info" => _serde::__private::Ok(__Field::__field3),
                            b"Debug" => _serde::__private::Ok(__Field::__field4),
                            b"Internal" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<LogLevel>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = LogLevel;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum LogLevel",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(LogLevel::Off)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(LogLevel::Error)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(LogLevel::Warn)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(LogLevel::Info)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(LogLevel::Debug)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Vec<InternalLog>,
                                    >(__variant),
                                    LogLevel::Internal,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Off",
                    "Error",
                    "Warn",
                    "Info",
                    "Debug",
                    "Internal",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "LogLevel",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<LogLevel>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for LogLevel {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            match &self {
                LogLevel::Internal(o) => {
                    if !::config_checker::__check_config(o, depth + 1) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "Internal",
                                    "LogLevel",
                                    depth_space,
                                ),
                            );
                        };
                    }
                }
                _ => {}
            };
            ret
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LogLevel {
        #[inline]
        fn clone(&self) -> LogLevel {
            match self {
                LogLevel::Off => LogLevel::Off,
                LogLevel::Error => LogLevel::Error,
                LogLevel::Warn => LogLevel::Warn,
                LogLevel::Info => LogLevel::Info,
                LogLevel::Debug => LogLevel::Debug,
                LogLevel::Internal(__self_0) => {
                    LogLevel::Internal(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LogLevel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LogLevel {
        #[inline]
        fn eq(&self, other: &LogLevel) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (LogLevel::Internal(__self_0), LogLevel::Internal(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => true,
                }
        }
    }
    impl Into<log::LevelFilter> for LogLevel {
        fn into(self) -> log::LevelFilter {
            match self {
                LogLevel::Off => log::LevelFilter::Off,
                LogLevel::Error => log::LevelFilter::Error,
                LogLevel::Warn => log::LevelFilter::Warn,
                LogLevel::Info => log::LevelFilter::Info,
                LogLevel::Debug | LogLevel::Internal(_) => log::LevelFilter::Debug,
            }
        }
    }
    impl Into<&str> for LogLevel {
        fn into(self) -> &'static str {
            match self {
                LogLevel::Off => "Off",
                LogLevel::Error => "Error",
                LogLevel::Warn => "Warn",
                LogLevel::Info => "Info",
                LogLevel::Debug => "Debug",
                LogLevel::Internal(_) => "Internal",
            }
        }
    }
    impl Display for LogLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("{0}", Into::<&str>::into(self.clone())))
        }
    }
    pub enum InternalLog {
        All,
        NetworkMessages,
        ServiceHandling,
        SetupSteps,
        SetupStepsDetailed,
        SensorManager,
        SensorManagerDetailed,
        NodeRunning,
        NodeRunningDetailed,
        NodeSyncDetailed,
        API,
        NavigatorDetailed,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InternalLog {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    InternalLog::All => "All",
                    InternalLog::NetworkMessages => "NetworkMessages",
                    InternalLog::ServiceHandling => "ServiceHandling",
                    InternalLog::SetupSteps => "SetupSteps",
                    InternalLog::SetupStepsDetailed => "SetupStepsDetailed",
                    InternalLog::SensorManager => "SensorManager",
                    InternalLog::SensorManagerDetailed => "SensorManagerDetailed",
                    InternalLog::NodeRunning => "NodeRunning",
                    InternalLog::NodeRunningDetailed => "NodeRunningDetailed",
                    InternalLog::NodeSyncDetailed => "NodeSyncDetailed",
                    InternalLog::API => "API",
                    InternalLog::NavigatorDetailed => "NavigatorDetailed",
                },
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InternalLog {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    InternalLog::All => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            0u32,
                            "All",
                        )
                    }
                    InternalLog::NetworkMessages => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            1u32,
                            "NetworkMessages",
                        )
                    }
                    InternalLog::ServiceHandling => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            2u32,
                            "ServiceHandling",
                        )
                    }
                    InternalLog::SetupSteps => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            3u32,
                            "SetupSteps",
                        )
                    }
                    InternalLog::SetupStepsDetailed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            4u32,
                            "SetupStepsDetailed",
                        )
                    }
                    InternalLog::SensorManager => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            5u32,
                            "SensorManager",
                        )
                    }
                    InternalLog::SensorManagerDetailed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            6u32,
                            "SensorManagerDetailed",
                        )
                    }
                    InternalLog::NodeRunning => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            7u32,
                            "NodeRunning",
                        )
                    }
                    InternalLog::NodeRunningDetailed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            8u32,
                            "NodeRunningDetailed",
                        )
                    }
                    InternalLog::NodeSyncDetailed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            9u32,
                            "NodeSyncDetailed",
                        )
                    }
                    InternalLog::API => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            10u32,
                            "API",
                        )
                    }
                    InternalLog::NavigatorDetailed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalLog",
                            11u32,
                            "NavigatorDetailed",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InternalLog {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 12",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "All" => _serde::__private::Ok(__Field::__field0),
                            "NetworkMessages" => _serde::__private::Ok(__Field::__field1),
                            "ServiceHandling" => _serde::__private::Ok(__Field::__field2),
                            "SetupSteps" => _serde::__private::Ok(__Field::__field3),
                            "SetupStepsDetailed" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "SensorManager" => _serde::__private::Ok(__Field::__field5),
                            "SensorManagerDetailed" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "NodeRunning" => _serde::__private::Ok(__Field::__field7),
                            "NodeRunningDetailed" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "NodeSyncDetailed" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "API" => _serde::__private::Ok(__Field::__field10),
                            "NavigatorDetailed" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"All" => _serde::__private::Ok(__Field::__field0),
                            b"NetworkMessages" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"ServiceHandling" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"SetupSteps" => _serde::__private::Ok(__Field::__field3),
                            b"SetupStepsDetailed" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"SensorManager" => _serde::__private::Ok(__Field::__field5),
                            b"SensorManagerDetailed" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"NodeRunning" => _serde::__private::Ok(__Field::__field7),
                            b"NodeRunningDetailed" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"NodeSyncDetailed" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"API" => _serde::__private::Ok(__Field::__field10),
                            b"NavigatorDetailed" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InternalLog>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InternalLog;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum InternalLog",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::All)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::NetworkMessages)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::ServiceHandling)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::SetupSteps)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::SetupStepsDetailed)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::SensorManager)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::SensorManagerDetailed)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::NodeRunning)
                            }
                            (__Field::__field8, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::NodeRunningDetailed)
                            }
                            (__Field::__field9, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::NodeSyncDetailed)
                            }
                            (__Field::__field10, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::API)
                            }
                            (__Field::__field11, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InternalLog::NavigatorDetailed)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "All",
                    "NetworkMessages",
                    "ServiceHandling",
                    "SetupSteps",
                    "SetupStepsDetailed",
                    "SensorManager",
                    "SensorManagerDetailed",
                    "NodeRunning",
                    "NodeRunningDetailed",
                    "NodeSyncDetailed",
                    "API",
                    "NavigatorDetailed",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "InternalLog",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InternalLog>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for InternalLog {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            match &self {
                _ => {}
            };
            ret
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InternalLog {
        #[inline]
        fn clone(&self) -> InternalLog {
            match self {
                InternalLog::All => InternalLog::All,
                InternalLog::NetworkMessages => InternalLog::NetworkMessages,
                InternalLog::ServiceHandling => InternalLog::ServiceHandling,
                InternalLog::SetupSteps => InternalLog::SetupSteps,
                InternalLog::SetupStepsDetailed => InternalLog::SetupStepsDetailed,
                InternalLog::SensorManager => InternalLog::SensorManager,
                InternalLog::SensorManagerDetailed => InternalLog::SensorManagerDetailed,
                InternalLog::NodeRunning => InternalLog::NodeRunning,
                InternalLog::NodeRunningDetailed => InternalLog::NodeRunningDetailed,
                InternalLog::NodeSyncDetailed => InternalLog::NodeSyncDetailed,
                InternalLog::API => InternalLog::API,
                InternalLog::NavigatorDetailed => InternalLog::NavigatorDetailed,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InternalLog {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InternalLog {
        #[inline]
        fn eq(&self, other: &InternalLog) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[serde(default)]
    #[serde(deny_unknown_fields)]
    pub struct LoggerConfig {
        pub included_nodes: Vec<String>,
        pub excluded_nodes: Vec<String>,
        pub log_level: LogLevel,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LoggerConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LoggerConfig",
                "included_nodes",
                &self.included_nodes,
                "excluded_nodes",
                &self.excluded_nodes,
                "log_level",
                &&self.log_level,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for LoggerConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "LoggerConfig",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "included_nodes",
                    &self.included_nodes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "excluded_nodes",
                    &self.excluded_nodes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "log_level",
                    &self.log_level,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for LoggerConfig
        where
            LoggerConfig: _serde::__private::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "included_nodes" => _serde::__private::Ok(__Field::__field0),
                            "excluded_nodes" => _serde::__private::Ok(__Field::__field1),
                            "log_level" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"included_nodes" => _serde::__private::Ok(__Field::__field0),
                            b"excluded_nodes" => _serde::__private::Ok(__Field::__field1),
                            b"log_level" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    LoggerConfig: _serde::__private::Default,
                {
                    marker: _serde::__private::PhantomData<LoggerConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    LoggerConfig: _serde::__private::Default,
                {
                    type Value = LoggerConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct LoggerConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.included_nodes,
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.excluded_nodes,
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            LogLevel,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.log_level,
                        };
                        _serde::__private::Ok(LoggerConfig {
                            included_nodes: __field0,
                            excluded_nodes: __field1,
                            log_level: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<LogLevel> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "included_nodes",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "excluded_nodes",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "log_level",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<LogLevel>(&mut __map)?,
                                    );
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => __default.included_nodes,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => __default.excluded_nodes,
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => __default.log_level,
                        };
                        _serde::__private::Ok(LoggerConfig {
                            included_nodes: __field0,
                            excluded_nodes: __field1,
                            log_level: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "included_nodes",
                    "excluded_nodes",
                    "log_level",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LoggerConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<LoggerConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for LoggerConfig {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            ret
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LoggerConfig {
        #[inline]
        fn clone(&self) -> LoggerConfig {
            LoggerConfig {
                included_nodes: ::core::clone::Clone::clone(&self.included_nodes),
                excluded_nodes: ::core::clone::Clone::clone(&self.excluded_nodes),
                log_level: ::core::clone::Clone::clone(&self.log_level),
            }
        }
    }
    impl Default for LoggerConfig {
        fn default() -> Self {
            Self {
                included_nodes: Vec::new(),
                excluded_nodes: Vec::new(),
                log_level: LogLevel::Info,
            }
        }
    }
    pub fn init_log(config: &LoggerConfig) {
        if let LogLevel::Internal(v) = &config.log_level {
            *INTERNAL_LOG_LEVEL.write().unwrap() = v.clone();
        }
    }
    pub fn is_enabled(internal_level: InternalLog) -> bool {
        if let InternalLog::All = internal_level {
            return true;
        }
        INTERNAL_LOG_LEVEL.read().unwrap().contains(&InternalLog::All)
            || INTERNAL_LOG_LEVEL.read().unwrap().contains(&internal_level)
    }
}
pub mod navigators {
    /*!
Module providing the [`Navigator`](navigator::Navigator) strategy, which
compute the error from the desired position.

This module also propose a implemented strategy, [`trajectory_follower`].
*/
    pub mod navigator {
        /*!
Provide the [`Navigator`] trait and the configuration and record enumerations.
*/
        extern crate confy;
        use std::sync::{Arc, RwLock};
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        use simba_macros::{EnumFromString, EnumToString, ToVec};
        use super::{external_navigator, trajectory_follower};
        use crate::controllers::controller::ControllerError;
        use crate::gui::utils::string_combobox;
        use crate::gui::UIComponent;
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::State;
        /// Enumerate the configuration of the different strategies.
        #[serde(deny_unknown_fields)]
        pub enum NavigatorConfig {
            TrajectoryFollower(Box<trajectory_follower::TrajectoryFollowerConfig>),
            External(Box<external_navigator::ExternalNavigatorConfig>),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for NavigatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        NavigatorConfig::TrajectoryFollower(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NavigatorConfig",
                                0u32,
                                "TrajectoryFollower",
                                __field0,
                            )
                        }
                        NavigatorConfig::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NavigatorConfig",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for NavigatorConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "TrajectoryFollower" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"TrajectoryFollower" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<NavigatorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = NavigatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum NavigatorConfig",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<trajectory_follower::TrajectoryFollowerConfig>,
                                        >(__variant),
                                        NavigatorConfig::TrajectoryFollower,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<external_navigator::ExternalNavigatorConfig>,
                                        >(__variant),
                                        NavigatorConfig::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "TrajectoryFollower",
                        "External",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "NavigatorConfig",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<NavigatorConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for NavigatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NavigatorConfig::TrajectoryFollower(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TrajectoryFollower",
                            &__self_0,
                        )
                    }
                    NavigatorConfig::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NavigatorConfig {
            #[inline]
            fn clone(&self) -> NavigatorConfig {
                match self {
                    NavigatorConfig::TrajectoryFollower(__self_0) => {
                        NavigatorConfig::TrajectoryFollower(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    NavigatorConfig::External(__self_0) => {
                        NavigatorConfig::External(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for NavigatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                match &self {
                    NavigatorConfig::TrajectoryFollower(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "TrajectoryFollower",
                                        "NavigatorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    NavigatorConfig::External(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "External",
                                        "NavigatorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    _ => {}
                };
                ret
            }
        }
        #[automatically_derived]
        impl ToString for NavigatorConfig {
            #[allow(unreachable_patterns)]
            fn to_string(&self) -> String {
                String::from(
                    match &self {
                        NavigatorConfig::TrajectoryFollower(_) => "TrajectoryFollower",
                        NavigatorConfig::External(_) => "External",
                        _ => ::core::panicking::panic("not implemented"),
                    },
                )
            }
        }
        #[automatically_derived]
        impl crate::utils::enum_tools::ToVec<&'static str> for NavigatorConfig {
            fn to_vec() -> Vec<&'static str> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new(["TrajectoryFollower", "External"]),
                )
            }
        }
        /// Enumeration of the record of the different strategies.
        pub enum NavigatorRecord {
            TrajectoryFollower(trajectory_follower::TrajectoryFollowerRecord),
            External(external_navigator::ExternalNavigatorRecord),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for NavigatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        NavigatorRecord::TrajectoryFollower(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NavigatorRecord",
                                0u32,
                                "TrajectoryFollower",
                                __field0,
                            )
                        }
                        NavigatorRecord::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NavigatorRecord",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for NavigatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "TrajectoryFollower" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"TrajectoryFollower" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<NavigatorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = NavigatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum NavigatorRecord",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            trajectory_follower::TrajectoryFollowerRecord,
                                        >(__variant),
                                        NavigatorRecord::TrajectoryFollower,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            external_navigator::ExternalNavigatorRecord,
                                        >(__variant),
                                        NavigatorRecord::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "TrajectoryFollower",
                        "External",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "NavigatorRecord",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<NavigatorRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for NavigatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NavigatorRecord::TrajectoryFollower(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TrajectoryFollower",
                            &__self_0,
                        )
                    }
                    NavigatorRecord::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NavigatorRecord {
            #[inline]
            fn clone(&self) -> NavigatorRecord {
                match self {
                    NavigatorRecord::TrajectoryFollower(__self_0) => {
                        NavigatorRecord::TrajectoryFollower(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    NavigatorRecord::External(__self_0) => {
                        NavigatorRecord::External(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        use crate::node::Node;
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::enum_tools::ToVec;
        /// Trait managing the path planning, and providing the error to the planned path.
        pub trait Navigator: std::fmt::Debug + std::marker::Send + std::marker::Sync + Stateful<
                NavigatorRecord,
            > {
            /// Compute the error ([`ControllerError`]) between the given `state` to the planned path.
            fn compute_error(
                &mut self,
                robot: &mut Node,
                state: State,
            ) -> ControllerError;
        }
        /// Helper function to create a navigator from the given configuration.
        ///
        /// ## Arguments
        /// - `config`: The configuration of the navigator.
        /// - `plugin_api`: The plugin API, to be used by the navigator.
        /// - `meta_config`: The meta configuration of the simulator.
        /// - `va_factory`: Random variables factory for determinist behavior.
        pub fn make_navigator_from_config(
            config: &NavigatorConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
            va_factory: &DeterministRandomVariableFactory,
        ) -> Arc<RwLock<Box<dyn Navigator>>> {
            Arc::new(
                RwLock::new(
                    match config {
                        NavigatorConfig::TrajectoryFollower(c) => {
                            Box::new(
                                trajectory_follower::TrajectoryFollower::from_config(
                                    c,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ) as Box<dyn Navigator>
                        }
                        NavigatorConfig::External(c) => {
                            Box::new(
                                external_navigator::ExternalNavigator::from_config(
                                    c,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ) as Box<dyn Navigator>
                        }
                    },
                ),
            )
        }
    }
    pub mod trajectory {
        /*!
Trajectory tool.
*/
        extern crate nalgebra as na;
        use config_checker::macros::Check;
        use libm::atan2;
        use log::debug;
        use na::{DMatrix, SVector};
        use nalgebra::Vector2;
        use crate::{logger::is_enabled, stateful::Stateful};
        use crate::utils::geometry::*;
        use serde_derive::{Deserialize, Serialize};
        /// Config of the [`Trajectory`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct TrajectoryConfig {
            /// Ordered list of the points to follow.
            pub point_list: Vec<Vec<f32>>,
            /// Closing the loop or not.
            pub do_loop: bool,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TrajectoryConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TrajectoryConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "point_list",
                        &self.point_list,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "do_loop",
                        &self.do_loop,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TrajectoryConfig
            where
                TrajectoryConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "point_list" => _serde::__private::Ok(__Field::__field0),
                                "do_loop" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"point_list" => _serde::__private::Ok(__Field::__field0),
                                b"do_loop" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        TrajectoryConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<TrajectoryConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        TrajectoryConfig: _serde::__private::Default,
                    {
                        type Value = TrajectoryConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TrajectoryConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<Vec<f32>>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.point_list,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.do_loop,
                            };
                            _serde::__private::Ok(TrajectoryConfig {
                                point_list: __field0,
                                do_loop: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Vec<Vec<f32>>> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "point_list",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<Vec<f32>>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "do_loop",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.point_list,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.do_loop,
                            };
                            _serde::__private::Ok(TrajectoryConfig {
                                point_list: __field0,
                                do_loop: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["point_list", "do_loop"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TrajectoryConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TrajectoryConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for TrajectoryConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TrajectoryConfig",
                    "point_list",
                    &self.point_list,
                    "do_loop",
                    &&self.do_loop,
                )
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for TrajectoryConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                ret
            }
        }
        impl Default for TrajectoryConfig {
            fn default() -> Self {
                Self {
                    point_list: Vec::new(),
                    do_loop: true,
                }
            }
        }
        /// Record for [`Stateful`] trait. The only dynamic element
        /// is the current segment.
        pub struct TrajectoryRecord {
            pub current_segment: usize,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TrajectoryRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TrajectoryRecord",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "current_segment",
                        &self.current_segment,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TrajectoryRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "current_segment" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"current_segment" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TrajectoryRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TrajectoryRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TrajectoryRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TrajectoryRecord with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TrajectoryRecord {
                                current_segment: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "current_segment",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("current_segment")?
                                }
                            };
                            _serde::__private::Ok(TrajectoryRecord {
                                current_segment: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["current_segment"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TrajectoryRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TrajectoryRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for TrajectoryRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "TrajectoryRecord",
                    "current_segment",
                    &&self.current_segment,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TrajectoryRecord {
            #[inline]
            fn clone(&self) -> TrajectoryRecord {
                TrajectoryRecord {
                    current_segment: ::core::clone::Clone::clone(&self.current_segment),
                }
            }
        }
        impl TrajectoryRecord {
            pub fn default() -> Self {
                Self { current_segment: 0 }
            }
        }
        /// Tool to manage a polyline trajectory.
        ///
        /// The matching starts at the segment 0, and continues in the order.
        pub struct Trajectory {
            point_list: DMatrix<f32>,
            do_loop: bool,
            current_segment: usize,
        }
        impl Trajectory {
            /// Creates a new empty trajectory
            pub fn new() -> Self {
                Self {
                    point_list: DMatrix::<
                        f32,
                    >::from_vec(
                        1,
                        2,
                        <[_]>::into_vec(::alloc::boxed::box_new([0., 0.])),
                    ),
                    do_loop: true,
                    current_segment: 0,
                }
            }
            /// Makes a new trajectory from the given config.
            pub fn from_config(config: &TrajectoryConfig) -> Self {
                let mut trajectory = Self::new();
                trajectory.point_list = trajectory
                    .point_list
                    .resize(config.point_list.len(), 2, 0.);
                let mut i: usize = 0;
                for point in &config.point_list {
                    let mut j: usize = 0;
                    for &coord in point {
                        if j >= 2 {
                            continue;
                        }
                        trajectory.point_list[(i, j)] = coord;
                        j += 1;
                    }
                    i += 1;
                }
                trajectory.do_loop = config.do_loop;
                return trajectory;
            }
            /// Match a point on the polyline, and returns the projected point and the segment.
            ///
            /// The segment privilieged is the previous matched segment. If the next segment is
            /// closer, it is taken, but there is no loop to go through all segments.
            ///
            /// ## Arguments
            /// * `point` - Point to match
            /// * `forward_distance` - Curvilinear distance to add
            ///
            /// ## Return
            /// * Matched segment, as a tuple of two points.
            /// * Projected point.
            /// * If the point is on the last segment.
            pub fn map_matching(
                &mut self,
                point: SVector<f32, 2>,
                forward_distance: f32,
            ) -> ((SVector<f32, 2>, SVector<f32, 2>), SVector<f32, 2>, bool) {
                let mut forward_distance = forward_distance;
                let (mut pt1, mut pt2, mut projected_point) = self.project(&point);
                if (pt1 - pt2).norm() < 1e-10 {
                    return ((pt1, pt2), projected_point, true);
                }
                while (projected_point - pt2).norm() < 1e-6 {
                    if self.current_segment + 1 == self.point_list.nrows() {
                        if !self.do_loop {
                            if is_enabled(
                                crate::logger::InternalLog::NavigatorDetailed,
                            ) {
                                {
                                    {
                                        let lvl = ::log::Level::Debug;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api::log(
                                                { ::log::__private_api::GlobalLogger },
                                                format_args!("No loop so give last point"),
                                                lvl,
                                                &(
                                                    "simba::navigators::trajectory",
                                                    "simba::navigators::trajectory",
                                                    ::log::__private_api::loc(),
                                                ),
                                                (),
                                            );
                                        }
                                    }
                                };
                            }
                            return ((pt1, pt2), pt2, true);
                        } else {
                            self.current_segment = 0;
                            (pt1, pt2, projected_point) = self.project(&point);
                        }
                    } else {
                        self.current_segment += 1;
                        (pt1, pt2, projected_point) = self.project(&point);
                    }
                }
                let mut d = ((pt2.x - projected_point.x).powf(2.)
                    + (pt2.y - projected_point.y).powf(2.))
                    .sqrt();
                let mut start_point = projected_point;
                let mut segment = self.current_segment;
                while d < forward_distance {
                    forward_distance -= d;
                    segment += 1;
                    if segment >= self.point_list.nrows() && self.do_loop {
                        segment = 0;
                    }
                    if segment + 1 == self.point_list.nrows() && !self.do_loop {
                        return ((pt1, pt2), pt2, true);
                    }
                    pt1 = pt2;
                    start_point = pt1;
                    pt2 = if segment + 1 >= self.point_list.nrows() {
                        self.point_list.fixed_view::<1, 2>(0, 0).transpose()
                    } else {
                        self.point_list.fixed_view::<1, 2>(segment + 1, 0).transpose()
                    };
                    d = ((pt2.x - pt1.x).powf(2.) + (pt2.y - pt1.y).powf(2.)).sqrt();
                }
                let segment_direction = atan2(
                    (pt2.y - pt1.y).into(),
                    (pt2.x - pt1.x).into(),
                ) as f32;
                let projected_point = start_point
                    + forward_distance
                        * Vector2::new(segment_direction.cos(), segment_direction.sin());
                return ((pt1, pt2), projected_point, false);
            }
            /// Handle the projection of a point on the current segment. Get to the next segment if needed.
            ///
            /// ## Arguments
            /// * `point` - Point to project.
            ///
            /// ## Return
            /// * First point of the segment.
            /// * Second point of the segment.
            /// * Projected point.
            fn project(
                &self,
                point: &SVector<f32, 2>,
            ) -> (SVector<f32, 2>, SVector<f32, 2>, SVector<f32, 2>) {
                let pt1 = self
                    .point_list
                    .fixed_view::<1, 2>(self.current_segment, 0)
                    .transpose();
                if self.point_list.nrows() == 1 {
                    return (pt1, pt1, pt1);
                }
                let pt2 = if self.current_segment + 1 >= self.point_list.nrows() {
                    self.point_list.fixed_view::<1, 2>(0, 0).transpose()
                } else {
                    self.point_list
                        .fixed_view::<1, 2>(self.current_segment + 1, 0)
                        .transpose()
                };
                let projected_point = project_point(point.clone(), pt1, pt2);
                (pt1, pt2, projected_point)
            }
        }
        impl Stateful<TrajectoryRecord> for Trajectory {
            fn record(&self) -> TrajectoryRecord {
                TrajectoryRecord {
                    current_segment: self.current_segment,
                }
            }
            fn from_record(&mut self, record: TrajectoryRecord) {
                self.current_segment = record.current_segment;
            }
        }
        impl std::fmt::Debug for Trajectory {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("Trajectory {{ point_list: [")).unwrap();
                let mut first = true;
                for point in self.point_list.row_iter() {
                    if first {
                        first = false;
                    } else {
                        f.write_fmt(format_args!(", ")).unwrap();
                    }
                    f.write_fmt(format_args!("({0}, {1})", point[0], point[1])).unwrap();
                }
                f.write_fmt(format_args!("], do_loop: {0} }}", self.do_loop))
            }
        }
    }
    pub mod trajectory_follower {
        /*!
Implementation of a [`Navigator`] strategy, which follows a polyline shaped
trajectory.
*/
        use super::navigator::{Navigator, NavigatorRecord};
        use super::trajectory::{Trajectory, TrajectoryConfig, TrajectoryRecord};
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::geometry::{mod2pi, smallest_theta_diff};
        extern crate nalgebra as na;
        use config_checker::macros::Check;
        use libm::atan2;
        use log::error;
        use na::Vector3;
        use serde_derive::{Deserialize, Serialize};
        use std::path::Path;
        /// Configuration of the [`TrajectoryFollower`] strategy.
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct TrajectoryFollowerConfig {
            /// Path to load the path. The file should be compatible with [`TrajectoryConfig`].
            pub trajectory_path: String,
            /// Distance of the point which is projected on the trajectory.
            #[check(ge(0.))]
            pub forward_distance: f32,
            /// Speed to reach, in m/s.
            #[check(ge(0.))]
            pub target_speed: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TrajectoryFollowerConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TrajectoryFollowerConfig",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "trajectory_path",
                        &self.trajectory_path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "forward_distance",
                        &self.forward_distance,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "target_speed",
                        &self.target_speed,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TrajectoryFollowerConfig
            where
                TrajectoryFollowerConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "trajectory_path" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "forward_distance" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "target_speed" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"trajectory_path" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"forward_distance" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"target_speed" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        TrajectoryFollowerConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<TrajectoryFollowerConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        TrajectoryFollowerConfig: _serde::__private::Default,
                    {
                        type Value = TrajectoryFollowerConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TrajectoryFollowerConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.trajectory_path,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.forward_distance,
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.target_speed,
                            };
                            _serde::__private::Ok(TrajectoryFollowerConfig {
                                trajectory_path: __field0,
                                forward_distance: __field1,
                                target_speed: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "trajectory_path",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "forward_distance",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "target_speed",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.trajectory_path,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.forward_distance,
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => __default.target_speed,
                            };
                            _serde::__private::Ok(TrajectoryFollowerConfig {
                                trajectory_path: __field0,
                                forward_distance: __field1,
                                target_speed: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "trajectory_path",
                        "forward_distance",
                        "target_speed",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TrajectoryFollowerConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                TrajectoryFollowerConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for TrajectoryFollowerConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "TrajectoryFollowerConfig",
                    "trajectory_path",
                    &self.trajectory_path,
                    "forward_distance",
                    &self.forward_distance,
                    "target_speed",
                    &&self.target_speed,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TrajectoryFollowerConfig {
            #[inline]
            fn clone(&self) -> TrajectoryFollowerConfig {
                TrajectoryFollowerConfig {
                    trajectory_path: ::core::clone::Clone::clone(&self.trajectory_path),
                    forward_distance: ::core::clone::Clone::clone(
                        &self.forward_distance,
                    ),
                    target_speed: ::core::clone::Clone::clone(&self.target_speed),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for TrajectoryFollowerConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.forward_distance >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "forward_distance",
                                "TrajectoryFollowerConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.target_speed >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "target_speed",
                                "TrajectoryFollowerConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                ret
            }
        }
        impl Default for TrajectoryFollowerConfig {
            fn default() -> Self {
                Self {
                    trajectory_path: String::from(""),
                    forward_distance: 1.0,
                    target_speed: 0.5,
                }
            }
        }
        /// Record of the [`TrajectoryFollower`].
        pub struct TrajectoryFollowerRecord {
            /// Current error
            pub error: ControllerError,
            /// Trajectory dynamic record.
            pub trajectory: TrajectoryRecord,
            pub projected_point: [f32; 2],
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TrajectoryFollowerRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TrajectoryFollowerRecord",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "error",
                        &self.error,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "trajectory",
                        &self.trajectory,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "projected_point",
                        &self.projected_point,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TrajectoryFollowerRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "error" => _serde::__private::Ok(__Field::__field0),
                                "trajectory" => _serde::__private::Ok(__Field::__field1),
                                "projected_point" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"error" => _serde::__private::Ok(__Field::__field0),
                                b"trajectory" => _serde::__private::Ok(__Field::__field1),
                                b"projected_point" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TrajectoryFollowerRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TrajectoryFollowerRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TrajectoryFollowerRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ControllerError,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TrajectoryFollowerRecord with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                TrajectoryRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TrajectoryFollowerRecord with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                [f32; 2],
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct TrajectoryFollowerRecord with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TrajectoryFollowerRecord {
                                error: __field0,
                                trajectory: __field1,
                                projected_point: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ControllerError,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                TrajectoryRecord,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<[f32; 2]> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ControllerError,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "trajectory",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TrajectoryRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "projected_point",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<[f32; 2]>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("error")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("trajectory")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("projected_point")?
                                }
                            };
                            _serde::__private::Ok(TrajectoryFollowerRecord {
                                error: __field0,
                                trajectory: __field1,
                                projected_point: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "error",
                        "trajectory",
                        "projected_point",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TrajectoryFollowerRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                TrajectoryFollowerRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for TrajectoryFollowerRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "TrajectoryFollowerRecord",
                    "error",
                    &self.error,
                    "trajectory",
                    &self.trajectory,
                    "projected_point",
                    &&self.projected_point,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TrajectoryFollowerRecord {
            #[inline]
            fn clone(&self) -> TrajectoryFollowerRecord {
                TrajectoryFollowerRecord {
                    error: ::core::clone::Clone::clone(&self.error),
                    trajectory: ::core::clone::Clone::clone(&self.trajectory),
                    projected_point: ::core::clone::Clone::clone(&self.projected_point),
                }
            }
        }
        impl Default for TrajectoryFollowerRecord {
            fn default() -> Self {
                Self {
                    error: ControllerError::default(),
                    trajectory: TrajectoryRecord::default(),
                    projected_point: [0., 0.],
                }
            }
        }
        /// [`Navigator`] strategy which follows a polyline.
        ///
        /// The lateral error is computed using the projection on the closest
        /// segment.
        ///
        /// The orientation error is computed so that the robot goes to the projected
        /// point.
        pub struct TrajectoryFollower {
            /// Trajectory to follow
            trajectory: Trajectory,
            /// Distance of the point which is projected on the trajectory
            /// to compute the error.
            forward_distance: f32,
            /// Speed to reach in m/s
            target_speed: f32,
            /// Last error, stored to make the [`TrajectoryFollowerRecord`]
            error: ControllerError,
            projected_point: [f32; 2],
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TrajectoryFollower {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "TrajectoryFollower",
                    "trajectory",
                    &self.trajectory,
                    "forward_distance",
                    &self.forward_distance,
                    "target_speed",
                    &self.target_speed,
                    "error",
                    &self.error,
                    "projected_point",
                    &&self.projected_point,
                )
            }
        }
        impl TrajectoryFollower {
            /// Makes a new default [`TrajectoryFollower`].
            pub fn new() -> Self {
                Self {
                    trajectory: Trajectory::new(),
                    forward_distance: 0.2,
                    target_speed: 0.5,
                    error: ControllerError::default(),
                    projected_point: [0., 0.],
                }
            }
            /// Makes a [`TrajectoryFollower`] from the given config.
            ///
            /// ## Arguments
            /// * `config` - Trajectory configuration
            /// * `plugin_api` - Not used there.
            /// * `global_config` - Global configuration of the simulator. Used there to get the
            /// path of the config, used as relative reference for the trajectory path.
            pub fn from_config(
                config: &TrajectoryFollowerConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                let mut path = Path::new(&config.trajectory_path);
                if config.trajectory_path == "" {
                    return Self::new();
                }
                let joined_path = global_config.base_path.join(&config.trajectory_path);
                if path.is_relative() {
                    path = joined_path.as_path();
                }
                TrajectoryFollower {
                    trajectory: Self::load_trajectory_from_path(&path),
                    forward_distance: config.forward_distance,
                    target_speed: config.target_speed,
                    error: ControllerError::default(),
                    projected_point: [0., 0.],
                }
            }
            /// Load the trajectory from the given `path`. This file should be compatible
            /// with [`TrajectoryConfig`].
            fn load_trajectory_from_path(path: &Path) -> Trajectory {
                let trajectory: TrajectoryConfig = match confy::load_path(&path) {
                    Ok(config) => config,
                    Err(error) => {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "Error from Confy while loading the trajectory file {0} : {1}\n",
                                    path.display(),
                                    error,
                                ),
                            );
                        };
                        return Trajectory::new();
                    }
                };
                Trajectory::from_config(&trajectory)
            }
        }
        use crate::controllers::controller::ControllerError;
        use crate::node::Node;
        use crate::state_estimators::state_estimator::State;
        impl Navigator for TrajectoryFollower {
            /// Compute the error between the given `state` and the current trajectory.
            ///
            /// This error is computed through the following steps:
            /// 1. Compute the foward pose, using the `forward_distance`.
            /// 2. Use [`Trajectory::map_matching`] to get the matching segment and the projected
            /// point (no orientation).
            /// 3. Compute the orientation of the point to orient the robot to the projected point.
            /// 4. Compute the lateral error
            /// 5. Compute the velocity error
            fn compute_error(
                &mut self,
                _robot: &mut Node,
                state: State,
            ) -> ControllerError {
                let state = state.theta_modulo();
                let (segment, projected_point, end) = self
                    .trajectory
                    .map_matching(
                        state.pose.fixed_view::<2, 1>(0, 0).into(),
                        self.forward_distance,
                    );
                if end {
                    self.target_speed = self
                        .target_speed
                        .min(
                            (state.pose.fixed_view::<2, 1>(0, 0) - projected_point)
                                .norm(),
                        );
                }
                let segment_angle: f32 = atan2(
                    (segment.1.y - segment.0.y).into(),
                    (segment.1.x - segment.0.x).into(),
                ) as f32;
                let projected_point = Vector3::new(
                    projected_point.x,
                    projected_point.y,
                    segment_angle,
                );
                let mut projected_point_direction = atan2(
                    (projected_point.y - state.pose.y).into(),
                    (projected_point.x - state.pose.x).into(),
                ) as f32;
                self.projected_point = [projected_point.x, projected_point.y];
                projected_point_direction = mod2pi(projected_point_direction);
                let theta_error = smallest_theta_diff(
                    projected_point_direction,
                    state.pose.z,
                );
                let theta_error = mod2pi(theta_error);
                self.error.theta = theta_error;
                let pose_with_segment: f32 = segment_angle
                    - atan2(
                        (state.pose.y - segment.0.y).into(),
                        (state.pose.x - segment.0.x).into(),
                    ) as f32;
                self.error.lateral = ((state.pose.x - projected_point.x).powf(2.)
                    + (state.pose.y - projected_point.y).powf(2.))
                    .sqrt();
                if pose_with_segment < 0. {
                    self.error.lateral *= -1.;
                }
                self.error.velocity = self.target_speed - state.velocity;
                self.error.clone()
            }
        }
        use crate::stateful::Stateful;
        impl Stateful<NavigatorRecord> for TrajectoryFollower {
            fn record(&self) -> NavigatorRecord {
                NavigatorRecord::TrajectoryFollower(TrajectoryFollowerRecord {
                    error: self.error.clone(),
                    trajectory: self.trajectory.record(),
                    projected_point: self.projected_point,
                })
            }
            #[allow(irrefutable_let_patterns)]
            fn from_record(&mut self, record: NavigatorRecord) {
                if let NavigatorRecord::TrajectoryFollower(navigation_record) = record {
                    self.error = navigation_record.error.clone();
                    self.trajectory.from_record(navigation_record.trajectory);
                } else {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Using a NavigatorRecord type which does not match the used Navigator (TrajectoryFollower)",
                                    ),
                                    lvl,
                                    &(
                                        "simba::navigators::trajectory_follower",
                                        "simba::navigators::trajectory_follower",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
        }
    }
    pub mod external_navigator {
        /*!
Module providing the interface to use external [`Navigator`].

To make your own external navigator strategy, the simulator should
be used as a library (see [dedicated page](crate::plugin_api)).

Your own external navigator strategy is made using the
[`PluginAPI::get_navigator`] function.

For the [`Stateful`] trait, the generic type is [`NavigatorRecord`],
and your implementation should return a [`NavigatorRecord::External`]
type. The value inside is a [`serde_json::Value`]. Use [`serde_json::to_value`]
and [`serde_json::from_value`] to make the bridge to your own Record struct.
*/
        use config_checker::macros::Check;
        use pyo3::{pyclass, pymethods};
        use serde_json::Value;
        use crate::controllers::controller::ControllerError;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::State;
        use crate::stateful::Stateful;
        use crate::{
            plugin_api::PluginAPI,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use super::navigator::{Navigator, NavigatorRecord};
        use serde_derive::{Deserialize, Serialize};
        /// Config for the external navigator (generic).
        ///
        /// The config for [`ExternalNavigator`] uses a [`serde_json::Value`] to
        /// integrate your own configuration inside the full simulator config.
        ///
        /// In the yaml file, the config could be:
        /// ```YAML
        /// navigator:
        ///     External:
        ///         parameter_of_my_own_navigator: true
        /// ```
        #[serde(default)]
        pub struct ExternalNavigatorConfig {
            /// Config serialized.
            #[serde(flatten)]
            pub config: Value,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalNavigatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.config,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalNavigatorConfig
            where
                ExternalNavigatorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        ExternalNavigatorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<ExternalNavigatorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        ExternalNavigatorConfig: _serde::__private::Default,
                    {
                        type Value = ExternalNavigatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalNavigatorConfig",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalNavigatorConfig {
                                config: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalNavigatorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalNavigatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalNavigatorConfig",
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalNavigatorConfig {
            #[inline]
            fn clone(&self) -> ExternalNavigatorConfig {
                ExternalNavigatorConfig {
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for ExternalNavigatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                ret
            }
        }
        impl Default for ExternalNavigatorConfig {
            fn default() -> Self {
                Self { config: Value::Null }
            }
        }
        /// Record for the external navigator (generic).
        ///
        /// Like [`ExternalNavigatorConfig`], [`ExternalNavigator`] uses a [`serde_json::Value`]
        /// to take every record.
        ///
        /// The record is not automatically cast to your own type, the cast should be done
        /// in [`Stateful::from_record`] and [`Stateful::record`] implementations.
        pub struct ExternalNavigatorRecord {
            /// Record serialized.
            #[serde(flatten)]
            pub record: Value,
        }
        impl ::pyo3::types::DerefToPyAny for ExternalNavigatorRecord {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for ExternalNavigatorRecord {
            const NAME: &'static str = "ExternalNavigatorRecord";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <ExternalNavigatorRecord as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for ExternalNavigatorRecord {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a ExternalNavigatorRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRef<'py, ExternalNavigatorRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut ExternalNavigatorRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRefMut<'py, ExternalNavigatorRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for ExternalNavigatorRecord {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for ExternalNavigatorRecord {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                ExternalNavigatorRecord,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <ExternalNavigatorRecord as ::pyo3::PyTypeInfo>::NAME,
                                c"Record for the external navigator (generic).\n\nLike [`ExternalNavigatorConfig`], [`ExternalNavigator`] uses a [`serde_json::Value`]\nto take every record.\n\nThe record is not automatically cast to your own type, the cast should be done\nin [`Stateful::from_record`] and [`Stateful::record`] implementations.",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ExternalNavigatorRecord> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalNavigatorRecord {}
        impl ExternalNavigatorRecord {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalNavigatorRecord {}
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalNavigatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.record,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalNavigatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ExternalNavigatorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ExternalNavigatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalNavigatorRecord",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalNavigatorRecord {
                                record: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalNavigatorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalNavigatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalNavigatorRecord",
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalNavigatorRecord {
            #[inline]
            fn clone(&self) -> ExternalNavigatorRecord {
                ExternalNavigatorRecord {
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        impl Default for ExternalNavigatorRecord {
            fn default() -> Self {
                Self { record: Value::Null }
            }
        }
        impl ExternalNavigatorRecord {
            fn record(&self) -> String {
                self.record.to_string()
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<ExternalNavigatorRecord>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<ExternalNavigatorRecord> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                            ::pyo3::class::PyMethodDefType::Getter(
                                ::pyo3::class::PyGetterDef::new(
                                    c"record",
                                    ExternalNavigatorRecord::__pymethod_get_record__,
                                    c"",
                                ),
                            ),
                        ),
                    ],
                    slots: &[],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalNavigatorRecord {
            unsafe fn __pymethod_get_record__(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let result = ::pyo3::callback::convert(
                    py,
                    ExternalNavigatorRecord::record(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            ExternalNavigatorRecord,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_0,
                        )?,
                    ),
                );
                result
            }
        }
        use crate::node::Node;
        /// External navigator strategy, which does the bridge with your own strategy.
        pub struct ExternalNavigator {
            /// External navigator.
            navigator: Box<dyn Navigator>,
        }
        impl ExternalNavigator {
            /// Creates a new [`ExternalNavigator`]
            pub fn new() -> Self {
                Self::from_config(
                    &ExternalNavigatorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Creates a new [`ExternalNavigator`] from the given config.
            ///
            /// <div class="warning">The `plugin_api` is required here !</div>
            ///
            ///  ## Arguments
            /// * `config` -- Scenario config of the External navigator.
            /// * `plugin_api` -- Required [`PluginAPI`] implementation.
            /// * `global_config` -- Simulator config.
            /// * `_va_factory` -- Factory for Determinists random variables
            pub fn from_config(
                config: &ExternalNavigatorConfig,
                plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                {
                    ::std::io::_print(format_args!("Config given: {0:?}\n", config));
                };
                Self {
                    navigator: plugin_api
                        .as_ref()
                        .expect("Plugin API not set!")
                        .get_navigator(&config.config, global_config),
                }
            }
        }
        impl std::fmt::Debug for ExternalNavigator {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("ExternalNavigator {{}}"))
            }
        }
        impl Navigator for ExternalNavigator {
            fn compute_error(
                &mut self,
                robot: &mut Node,
                state: State,
            ) -> ControllerError {
                self.navigator.compute_error(robot, state)
            }
        }
        impl Stateful<NavigatorRecord> for ExternalNavigator {
            fn record(&self) -> NavigatorRecord {
                self.navigator.record()
            }
            fn from_record(&mut self, record: NavigatorRecord) {
                self.navigator.from_record(record);
            }
        }
    }
    pub mod pybinds {
        use std::{str::FromStr, sync::{mpsc, Arc, Mutex}};
        use log::debug;
        use pyo3::prelude::*;
        use serde_json::Value;
        use crate::{
            controllers::controller::ControllerError, logger::is_enabled,
            navigators::external_navigator::ExternalNavigatorRecord, node::Node,
            node_factory::NodeRecord, pywrappers::{ControllerErrorWrapper, StateWrapper},
            state_estimators::state_estimator::State, stateful::Stateful,
        };
        use super::navigator::{Navigator, NavigatorRecord};
        pub struct PythonNavigatorAsyncClient {
            pub compute_error_request: mpsc::Sender<State>,
            pub compute_error_response: Arc<Mutex<mpsc::Receiver<ControllerError>>>,
            pub record_request: mpsc::Sender<()>,
            pub record_response: Arc<Mutex<mpsc::Receiver<NavigatorRecord>>>,
            pub from_record_request: mpsc::Sender<NavigatorRecord>,
            pub from_record_response: Arc<Mutex<mpsc::Receiver<()>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonNavigatorAsyncClient {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "compute_error_request",
                    "compute_error_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.compute_error_request,
                    &self.compute_error_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonNavigatorAsyncClient",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PythonNavigatorAsyncClient {
            #[inline]
            fn clone(&self) -> PythonNavigatorAsyncClient {
                PythonNavigatorAsyncClient {
                    compute_error_request: ::core::clone::Clone::clone(
                        &self.compute_error_request,
                    ),
                    compute_error_response: ::core::clone::Clone::clone(
                        &self.compute_error_response,
                    ),
                    record_request: ::core::clone::Clone::clone(&self.record_request),
                    record_response: ::core::clone::Clone::clone(&self.record_response),
                    from_record_request: ::core::clone::Clone::clone(
                        &self.from_record_request,
                    ),
                    from_record_response: ::core::clone::Clone::clone(
                        &self.from_record_response,
                    ),
                }
            }
        }
        impl Navigator for PythonNavigatorAsyncClient {
            fn compute_error(
                &mut self,
                _node: &mut Node,
                state: State,
            ) -> ControllerError {
                self.compute_error_request.send(state.clone()).unwrap();
                self.compute_error_response.lock().unwrap().recv().unwrap()
            }
        }
        impl Stateful<NavigatorRecord> for PythonNavigatorAsyncClient {
            fn from_record(&mut self, record: NavigatorRecord) {
                self.from_record_request.send(record).unwrap();
                self.from_record_response.lock().unwrap().recv().unwrap();
            }
            fn record(&self) -> NavigatorRecord {
                self.record_request.send(()).unwrap();
                self.record_response
                    .lock()
                    .unwrap()
                    .recv()
                    .expect("Error during call of record")
            }
        }
        pub struct PythonNavigator {
            model: Py<PyAny>,
            client: PythonNavigatorAsyncClient,
            compute_error_request: Arc<Mutex<mpsc::Receiver<State>>>,
            compute_error_response: mpsc::Sender<ControllerError>,
            record_request: Arc<Mutex<mpsc::Receiver<()>>>,
            record_response: mpsc::Sender<NavigatorRecord>,
            from_record_request: Arc<Mutex<mpsc::Receiver<NavigatorRecord>>>,
            from_record_response: mpsc::Sender<()>,
        }
        impl ::pyo3::types::DerefToPyAny for PythonNavigator {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for PythonNavigator {
            const NAME: &'static str = "Navigator";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <PythonNavigator as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for PythonNavigator {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a PythonNavigator {
            type Holder = ::std::option::Option<::pyo3::PyRef<'py, PythonNavigator>>;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut PythonNavigator {
            type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, PythonNavigator>>;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for PythonNavigator {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for PythonNavigator {
            const IS_BASETYPE: bool = true;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                PythonNavigator,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <PythonNavigator as ::pyo3::PyTypeInfo>::NAME,
                                c"",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<PythonNavigator> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonNavigator {}
        impl PythonNavigator {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonNavigator {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonNavigator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "model",
                    "client",
                    "compute_error_request",
                    "compute_error_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.model,
                    &self.client,
                    &self.compute_error_request,
                    &self.compute_error_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonNavigator",
                    names,
                    values,
                )
            }
        }
        impl PythonNavigator {
            pub fn new(py_model: Py<PyAny>) -> PythonNavigator {
                if is_enabled(crate::logger::InternalLog::API) {
                    Python::with_gil(|py| {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Model got: {0}",
                                            py_model.bind(py).dir().unwrap(),
                                        ),
                                        lvl,
                                        &(
                                            "simba::navigators::pybinds",
                                            "simba::navigators::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    });
                }
                let (compute_error_request_tx, compute_error_request_rx) = mpsc::channel();
                let (compute_error_response_tx, compute_error_response_rx) = mpsc::channel();
                let (record_request_tx, record_request_rx) = mpsc::channel();
                let (record_response_tx, record_response_rx) = mpsc::channel();
                let (from_record_request_tx, from_record_request_rx) = mpsc::channel();
                let (from_record_response_tx, from_record_response_rx) = mpsc::channel();
                PythonNavigator {
                    model: py_model,
                    client: PythonNavigatorAsyncClient {
                        compute_error_request: compute_error_request_tx,
                        compute_error_response: Arc::new(
                            Mutex::new(compute_error_response_rx),
                        ),
                        record_request: record_request_tx,
                        record_response: Arc::new(Mutex::new(record_response_rx)),
                        from_record_request: from_record_request_tx,
                        from_record_response: Arc::new(
                            Mutex::new(from_record_response_rx),
                        ),
                    },
                    compute_error_request: Arc::new(
                        Mutex::new(compute_error_request_rx),
                    ),
                    compute_error_response: compute_error_response_tx,
                    record_request: Arc::new(Mutex::new(record_request_rx)),
                    record_response: record_response_tx,
                    from_record_request: Arc::new(Mutex::new(from_record_request_rx)),
                    from_record_response: from_record_response_tx,
                }
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<PythonNavigator>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<PythonNavigator> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[],
                    slots: &[
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut ::pyo3::ffi::PyTypeObject,
                                    args: *mut ::pyo3::ffi::PyObject,
                                    kwargs: *mut ::pyo3::ffi::PyObject,
                                ) -> *mut ::pyo3::ffi::PyObject {
                                    use ::pyo3::impl_::pyclass::*;
                                    #[allow(unknown_lints, non_local_definitions)]
                                    impl PyClassNewTextSignature<PythonNavigator>
                                    for PyClassImplCollector<PythonNavigator> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str> {
                                            ::std::option::Option::Some("(py_model)")
                                        }
                                    }
                                    ::pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        PythonNavigator::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as ::pyo3::ffi::newfunc as _,
                        },
                    ],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonNavigator {
            unsafe fn __pymethod___new____(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyTypeObject,
                _args: *mut ::pyo3::ffi::PyObject,
                _kwargs: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                use ::pyo3::callback::IntoPyCallbackOutput;
                let _slf_ref = &_slf;
                let function = PythonNavigator::new;
                const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::Some(
                        <PythonNavigator as ::pyo3::type_object::PyTypeInfo>::NAME,
                    ),
                    func_name: "__new__",
                    positional_parameter_names: &["py_model"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) = DESCRIPTION
                    .extract_arguments_tuple_dict::<
                        ::pyo3::impl_::extract_argument::NoVarargs,
                        ::pyo3::impl_::extract_argument::NoVarkeywords,
                    >(py, _args, _kwargs, &mut output)?;
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
                let result = PythonNavigator::new(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "py_model",
                        )?,
                        &gil_refs_checker_0,
                    ),
                );
                let initializer: ::pyo3::PyClassInitializer<PythonNavigator> = result
                    .convert(py)?;
                gil_refs_checker_0.function_arg();
                ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
            }
        }
        impl PythonNavigator {
            pub fn get_client(&self) -> PythonNavigatorAsyncClient {
                self.client.clone()
            }
            pub fn check_requests(&mut self) {
                if let Ok(state) = self
                    .compute_error_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    let error = self.compute_error(&state);
                    self.compute_error_response.send(error).unwrap();
                }
                if let Ok(()) = self.record_request.clone().lock().unwrap().try_recv() {
                    self.record_response.send(self.record()).unwrap();
                }
                if let Ok(record) = self
                    .from_record_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.from_record(record);
                    self.from_record_response.send(()).unwrap();
                }
            }
            fn compute_error(&mut self, state: &State) -> ControllerError {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of compute_error",
                                    ),
                                    lvl,
                                    &(
                                        "simba::navigators::pybinds",
                                        "simba::navigators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let result = Python::with_gil(|py| -> ControllerErrorWrapper {
                    self.model
                        .bind(py)
                        .call_method(
                            "compute_error",
                            (StateWrapper::from_rust(state),),
                            None,
                        )
                        .expect(
                            "PythonNavigator does not have a correct 'compute_error' method",
                        )
                        .extract()
                        .expect(
                            "Error during the call of Python implementation of 'compute_error'",
                        )
                });
                result.to_rust()
            }
            fn record(&self) -> NavigatorRecord {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Calling python implementation of record"),
                                    lvl,
                                    &(
                                        "simba::navigators::pybinds",
                                        "simba::navigators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let record_str: String = Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("record", (), None)
                        .expect(
                            "Python implementation of PythonNavigator does not have a correct 'record' method",
                        )
                        .extract()
                        .expect(
                            "The 'record' method of PythonNavigator does not return a valid EstimatorRecord type",
                        )
                });
                let record = ExternalNavigatorRecord {
                    record: Value::from_str(record_str.as_str())
                        .expect(
                            "Impossible to get serde_json::Value from the input serialized python structure",
                        ),
                };
                NavigatorRecord::External(record)
            }
            fn from_record(&mut self, record: NavigatorRecord) {
                if let NavigatorRecord::External(record) = record {
                    if is_enabled(crate::logger::InternalLog::API) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Calling python implementation of from_record",
                                        ),
                                        lvl,
                                        &(
                                            "simba::navigators::pybinds",
                                            "simba::navigators::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    Python::with_gil(|py| {
                        self.model
                            .bind(py)
                            .call_method(
                                "from_record",
                                (serde_json::to_string(&record).unwrap(),),
                                None,
                            )
                            .expect(
                                "Python implementation of PythonNavigator does not have a correct 'from_record' method",
                            );
                    });
                }
            }
        }
    }
}
pub mod networking {
    /*!
Module which provides communication tools between nodes.

Each [`Robot`](crate::node::Robot) includes a [`Network`](network::Network).
The [`NetworkManager`](network_manager::NetworkManager) makes the link between the
[`Network`](network::Network)s and is owned by the [`Simulator`](crate::simulator::Simulator).

There are two main ways to communicate between nodes.

1) One-way communication: A node sends a message to another node. This is done using the
[`Network::send_to`](network::Network::send_to) and
[`Network::broadcast`](network::Network::broadcast) methods. The message is sent to the
receiver [`Network`](network::Network) and is stored in a time ordered buffer. The receiver
unwraps the message when it reaches the time of the message. If the message is sent in the
past, the receiver will go back in time to unwrap the message. The message treatment is done
in [`run_time_step`](crate::node::Robot::run_time_step), at the end. The message is
then passed from one [`MessageHandler`](message_handler::MessageHandler) to the next until
one of them handles the message.

2) Two-way communication: A node sends a request to another node and waits for the response.
This is done using the [`Service`](service::Service) and [`ServiceClient`](service::ServiceClient).
The server node proposes a service, and then a client node need to get a
[`ServiceClient`](service::ServiceClient) instance to be able to make a request. The client
sends a request to the server, and is blocked until the server sends a response. The server
node should handle the requests in [`run_time_step`](crate::node::Robot::run_time_step).
*/
    pub mod message_handler {
        /*!
Provide the [`MessageHandler`] trait.
*/
        use std::fmt::Debug;
        use crate::node::Node;
        use serde_json::Value;
        /// Trait which add a method to handle a message. If the message cannot be handled,
        /// the function returns Err, and it returns Ok if the message was handled.
        pub trait MessageHandler: std::marker::Send + std::marker::Sync + Debug {
            /// Handle the given `message` or not.
            ///
            /// ## Arguments
            /// * `robot` - Reference to the [`Robot`], to access the modules.
            /// * `from` - Emitter of the message.
            /// * `message` - Serialized message using [`serde_json::Value`]/
            /// * `time` - Time of the message.
            ///
            /// ## Return
            /// * `Ok` - The message was handled.
            /// * `Err` - The message was not handled and should be sent to the next handler.
            fn handle_message(
                &mut self,
                robot: &mut Node,
                from: &String,
                message: &Value,
                time: f32,
            ) -> Result<(), ()>;
        }
    }
    pub mod network {
        /*!
Provide the [`Network`] struct, allowing communication between robots, and
the configuration struct [`NetworkConfig`].
*/
        extern crate confy;
        use std::collections::BTreeMap;
        use std::fmt;
        use std::sync::mpsc::{Receiver, Sender};
        use std::sync::{mpsc, Arc, Condvar, Mutex, RwLock};
        use config_checker::macros::Check;
        use log::debug;
        use serde_derive::{Deserialize, Serialize};
        use serde_json::Value;
        use crate::constants::TIME_ROUND;
        use crate::errors::{SimbaError, SimbaErrorTypes, SimbaResult};
        use crate::gui::UIComponent;
        use crate::logger::is_enabled;
        use crate::node::Node;
        use crate::simulator::{SimulatorConfig, TimeCv};
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::time_ordered_data::TimeOrderedData;
        use super::message_handler::MessageHandler;
        use super::network_manager::{MessageSendMethod, NetworkManager, NetworkMessage};
        /// Configuration for the [`Network`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct NetworkConfig {
            /// Limit range communication, 0 for no limit.
            #[check(ge(0.))]
            pub range: f32,
            /// Communication delay (fixed). 0 for no delay (not stable).
            #[check(ge(0.))]
            pub reception_delay: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for NetworkConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "NetworkConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "range",
                        &self.range,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "reception_delay",
                        &self.reception_delay,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for NetworkConfig
            where
                NetworkConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "range" => _serde::__private::Ok(__Field::__field0),
                                "reception_delay" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"range" => _serde::__private::Ok(__Field::__field0),
                                b"reception_delay" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        NetworkConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<NetworkConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        NetworkConfig: _serde::__private::Default,
                    {
                        type Value = NetworkConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct NetworkConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.range,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.reception_delay,
                            };
                            _serde::__private::Ok(NetworkConfig {
                                range: __field0,
                                reception_delay: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("range"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reception_delay",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.range,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.reception_delay,
                            };
                            _serde::__private::Ok(NetworkConfig {
                                range: __field0,
                                reception_delay: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "range",
                        "reception_delay",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "NetworkConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<NetworkConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for NetworkConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NetworkConfig",
                    "range",
                    &self.range,
                    "reception_delay",
                    &&self.reception_delay,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NetworkConfig {
            #[inline]
            fn clone(&self) -> NetworkConfig {
                NetworkConfig {
                    range: ::core::clone::Clone::clone(&self.range),
                    reception_delay: ::core::clone::Clone::clone(&self.reception_delay),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for NetworkConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.range >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "range",
                                "NetworkConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.reception_delay >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "reception_delay",
                                "NetworkConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                ret
            }
        }
        impl Default for NetworkConfig {
            fn default() -> Self {
                Self {
                    range: 0.,
                    reception_delay: TIME_ROUND,
                }
            }
        }
        /// Transmission mode for messages.
        pub enum MessageFlag {
            /// God mode, messages are instaneous.
            God,
            /// Read only: the recipient will do a quick jump in time, and will go back to its time
            ReadOnly,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MessageFlag {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        MessageFlag::God => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "MessageFlag",
                                0u32,
                                "God",
                            )
                        }
                        MessageFlag::ReadOnly => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "MessageFlag",
                                1u32,
                                "ReadOnly",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MessageFlag {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "God" => _serde::__private::Ok(__Field::__field0),
                                "ReadOnly" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"God" => _serde::__private::Ok(__Field::__field0),
                                b"ReadOnly" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MessageFlag>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MessageFlag;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum MessageFlag",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(MessageFlag::God)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(MessageFlag::ReadOnly)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["God", "ReadOnly"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "MessageFlag",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MessageFlag>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for MessageFlag {
            #[inline]
            fn clone(&self) -> MessageFlag {
                match self {
                    MessageFlag::God => MessageFlag::God,
                    MessageFlag::ReadOnly => MessageFlag::ReadOnly,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MessageFlag {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MessageFlag {
            #[inline]
            fn eq(&self, other: &MessageFlag) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MessageFlag {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        MessageFlag::God => "God",
                        MessageFlag::ReadOnly => "ReadOnly",
                    },
                )
            }
        }
        /// Network interface for [`Robot`].
        ///
        /// Each [`Robot`] should have a [`Network`] instance. Through this interface,
        /// the robots can send messages to other robots using pair-to-pair communication,
        /// or broadcast diffusion.
        pub struct Network {
            /// Name of the robot (will be in the 'from' field of the sent messages).
            from: String,
            /// Range limitation (not implemented yet).
            range: f32,
            /// Added delay to the messages.
            reception_delay: f32,
            /// List of handler. First handler returning Ok has priority.
            message_handlers: Vec<Arc<RwLock<dyn MessageHandler>>>,
            to_network_manager: Option<Sender<NetworkMessage>>,
            from_network_manager: Option<Arc<Mutex<Receiver<NetworkMessage>>>>,
            /// Message list
            messages_buffer: TimeOrderedData<(String, Value, Vec<MessageFlag>)>,
            time_cv: Arc<TimeCv>,
        }
        impl fmt::Debug for Network {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("")
                    .field(&self.from)
                    .field(&self.range)
                    .field(&self.reception_delay)
                    .finish()
            }
        }
        impl Network {
            /// Create a new default Network.
            pub fn new(from: String, time_cv: Arc<TimeCv>) -> Network {
                Network::from_config(
                    from,
                    &NetworkConfig::default(),
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                    time_cv,
                )
            }
            /// Makes a new Network from the given config.
            pub fn from_config(
                from: String,
                config: &NetworkConfig,
                _global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
                time_cv: Arc<TimeCv>,
            ) -> Network {
                Network {
                    from,
                    range: config.range,
                    reception_delay: config.reception_delay,
                    message_handlers: Vec::new(),
                    messages_buffer: TimeOrderedData::new(),
                    time_cv,
                    to_network_manager: None,
                    from_network_manager: None,
                }
            }
            /// Set the `network_manager` reference.
            pub fn set_network_manager_link(
                &mut self,
                to_network_manager: Sender<NetworkMessage>,
                from_network_manager: Receiver<NetworkMessage>,
            ) {
                self.to_network_manager = Some(to_network_manager);
                self.from_network_manager = Some(
                    Arc::new(Mutex::new(from_network_manager)),
                );
            }
            /// Send a `message` to the given `recipient`. `time` is the send message time, before delays.
            /// The message is sent if in range.
            pub fn send_to(
                &mut self,
                recipient: String,
                message: Value,
                time: f32,
                message_flags: Vec<MessageFlag>,
            ) -> SimbaResult<()> {
                if self.to_network_manager.is_none() {
                    return Err(
                        SimbaError::new(
                            SimbaErrorTypes::ImplementationError,
                            "Network is not properly setup: `set_network_manager_link` should be called.",
                        ),
                    );
                }
                {
                    let mut circulating_messages = self
                        .time_cv
                        .circulating_messages
                        .lock()
                        .unwrap();
                    *circulating_messages += 1;
                }
                self.to_network_manager
                    .as_ref()
                    .unwrap()
                    .send(NetworkMessage {
                        from: self.from.clone(),
                        range: self.range,
                        time,
                        to: MessageSendMethod::Recipient(recipient),
                        value: message,
                        message_flags,
                    })
                    .unwrap();
                Ok(())
            }
            /// Send a `message` to all available robots. `time` is the send message time, before delays.
            pub fn broadcast(
                &mut self,
                message: Value,
                time: f32,
                message_flags: Vec<MessageFlag>,
            ) -> SimbaResult<()> {
                if self.to_network_manager.is_none() {
                    return Err(
                        SimbaError::new(
                            SimbaErrorTypes::ImplementationError,
                            "Network is not properly setup: `set_network_manager_link` should be called.",
                        ),
                    );
                }
                {
                    let mut circulating_messages = self
                        .time_cv
                        .circulating_messages
                        .lock()
                        .unwrap();
                    *circulating_messages += 1;
                }
                self.to_network_manager
                    .as_ref()
                    .unwrap()
                    .send(NetworkMessage {
                        from: self.from.clone(),
                        range: self.range,
                        time,
                        to: MessageSendMethod::Broadcast,
                        value: message,
                        message_flags,
                    })
                    .unwrap();
                Ok(())
            }
            /// Unstack the waiting messages in the asynchronous receiver and put them in the buffer.
            /// Adds the delay.
            pub fn process_messages(&mut self) -> SimbaResult<usize> {
                if self.from_network_manager.is_none() {
                    return Err(
                        SimbaError::new(
                            SimbaErrorTypes::ImplementationError,
                            "Network is not properly setup: `set_network_manager_link` should be called.",
                        ),
                    );
                }
                for msg in self
                    .from_network_manager
                    .as_ref()
                    .unwrap()
                    .lock()
                    .unwrap()
                    .try_iter()
                {
                    {
                        let mut circulating_messages = self
                            .time_cv
                            .circulating_messages
                            .lock()
                            .unwrap();
                        *circulating_messages -= 1;
                    }
                    let time = if msg.message_flags.contains(&MessageFlag::God) {
                        msg.time
                    } else {
                        msg.time + self.reception_delay
                    };
                    if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Add new message from {0} at time {1}",
                                            msg.from,
                                            time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::networking::network",
                                            "simba::networking::network",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    self.messages_buffer
                        .insert(time, (msg.from, msg.value, msg.message_flags), false);
                }
                Ok(self.messages_buffer.len())
            }
            /// Get the minimal time among all waiting messages. Bool is true if the message is read only.
            pub fn next_message_time(&self) -> Option<(f32, bool)> {
                let tpl_option = self.messages_buffer.min_time();
                match tpl_option {
                    Some(tpl) => Some((tpl.0, tpl.1.2.contains(&MessageFlag::ReadOnly))),
                    None => None,
                }
            }
            /// Handle the messages which are received at the given `time`.
            ///
            /// ## Arguments
            /// * `robot` - Reference to the robot to give to the handlers.
            /// * `time` - Time of the messages to handle.
            pub fn handle_message_at_time(&mut self, robot: &mut Node, time: f32) {
                if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Handling messages at time {0}", time),
                                    lvl,
                                    &(
                                        "simba::networking::network",
                                        "simba::networking::network",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                while let Some((msg_time, (from, message, _message_flags))) = self
                    .messages_buffer
                    .remove(time)
                {
                    if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Receive message from {1}: {0:?}",
                                            message,
                                            from,
                                        ),
                                        lvl,
                                        &(
                                            "simba::networking::network",
                                            "simba::networking::network",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Handler list size: {0}",
                                            self.message_handlers.len(),
                                        ),
                                        lvl,
                                        &(
                                            "simba::networking::network",
                                            "simba::networking::network",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    for handler in &self.message_handlers {
                        if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "Handler available: {0:?}",
                                                handler.try_write().is_ok(),
                                            ),
                                            lvl,
                                            &(
                                                "simba::networking::network",
                                                "simba::networking::network",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                        if handler
                            .write()
                            .unwrap()
                            .handle_message(robot, &from, &message, msg_time)
                            .is_ok()
                        {
                            if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                                {
                                    {
                                        let lvl = ::log::Level::Debug;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api::log(
                                                { ::log::__private_api::GlobalLogger },
                                                format_args!("Found handler"),
                                                lvl,
                                                &(
                                                    "simba::networking::network",
                                                    "simba::networking::network",
                                                    ::log::__private_api::loc(),
                                                ),
                                                (),
                                            );
                                        }
                                    }
                                };
                            }
                            break;
                        }
                    }
                }
                if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "New next_message_time: {0}",
                                        match self.messages_buffer.min_time() {
                                            Some((time, _)) => time,
                                            None => -1.,
                                        },
                                    ),
                                    lvl,
                                    &(
                                        "simba::networking::network",
                                        "simba::networking::network",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Messages remaining: {0}",
                                        self.messages_buffer.len(),
                                    ),
                                    lvl,
                                    &(
                                        "simba::networking::network",
                                        "simba::networking::network",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            /// Add a new handler to the [`Network`].
            pub fn subscribe(&mut self, handler: Arc<RwLock<dyn MessageHandler>>) {
                self.message_handlers.push(handler);
            }
        }
    }
    pub mod network_manager {
        /*!
Provide the Manager of the nodes [`Network`]s. Only one should exist for one
[`Simulator`](crate::simulator::Simulator).
*/
        use log::debug;
        use serde_json::Value;
        use crate::logger::is_enabled;
        use crate::node::Node;
        use crate::simulator::TimeCv;
        use crate::state_estimators::state_estimator::State;
        use crate::utils::time_ordered_data::TimeOrderedData;
        use super::network::{MessageFlag, Network};
        use std::collections::{BTreeMap, BTreeMap};
        use std::sync::mpsc::{self, Receiver, Sender};
        use std::sync::{Arc, Condvar, Mutex, RwLock};
        pub enum MessageSendMethod {
            Broadcast,
            Recipient(String),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MessageSendMethod {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    MessageSendMethod::Broadcast => {
                        ::core::fmt::Formatter::write_str(f, "Broadcast")
                    }
                    MessageSendMethod::Recipient(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Recipient",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MessageSendMethod {
            #[inline]
            fn clone(&self) -> MessageSendMethod {
                match self {
                    MessageSendMethod::Broadcast => MessageSendMethod::Broadcast,
                    MessageSendMethod::Recipient(__self_0) => {
                        MessageSendMethod::Recipient(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        pub struct NetworkMessage {
            pub value: Value,
            pub from: String,
            pub to: MessageSendMethod,
            pub time: f32,
            pub range: f32,
            pub message_flags: Vec<MessageFlag>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NetworkMessage {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "value",
                    "from",
                    "to",
                    "time",
                    "range",
                    "message_flags",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.value,
                    &self.from,
                    &self.to,
                    &self.time,
                    &self.range,
                    &&self.message_flags,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NetworkMessage",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NetworkMessage {
            #[inline]
            fn clone(&self) -> NetworkMessage {
                NetworkMessage {
                    value: ::core::clone::Clone::clone(&self.value),
                    from: ::core::clone::Clone::clone(&self.from),
                    to: ::core::clone::Clone::clone(&self.to),
                    time: ::core::clone::Clone::clone(&self.time),
                    range: ::core::clone::Clone::clone(&self.range),
                    message_flags: ::core::clone::Clone::clone(&self.message_flags),
                }
            }
        }
        /// Manages the [`Network`]s, making the link between them, and keep a list.
        pub struct NetworkManager {
            nodes_senders: BTreeMap<String, Sender<NetworkMessage>>,
            nodes_receivers: BTreeMap<String, Receiver<NetworkMessage>>,
            time_cv: Arc<TimeCv>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NetworkManager {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "NetworkManager",
                    "nodes_senders",
                    &self.nodes_senders,
                    "nodes_receivers",
                    &self.nodes_receivers,
                    "time_cv",
                    &&self.time_cv,
                )
            }
        }
        impl NetworkManager {
            pub fn new(time_cv: Arc<TimeCv>) -> Self {
                Self {
                    nodes_senders: BTreeMap::new(),
                    nodes_receivers: BTreeMap::new(),
                    time_cv,
                }
            }
            /// Add a new [`Network`] node to the network. It creates the links to each existing network.
            ///
            /// ## Argument
            /// * `node` - Reference to the [`Node`].
            /// * `network` - [`Network`] to add.
            pub fn register_node_network(&mut self, node: &mut Node) {
                if let Some(network) = node.network() {
                    let node_name = node.name();
                    let to_node = mpsc::channel();
                    let from_node = mpsc::channel();
                    self.nodes_senders.insert(node_name.clone(), to_node.0);
                    self.nodes_receivers.insert(node_name.clone(), from_node.1);
                    network
                        .write()
                        .unwrap()
                        .set_network_manager_link(from_node.0, to_node.1);
                }
            }
            /// Compute the distance between two nodes at the given time, using their real pose.
            fn distance_between(
                position_history: &BTreeMap<String, TimeOrderedData<State>>,
                node1: &String,
                node2: &String,
                time: f32,
            ) -> f32 {
                let node1_pos = position_history
                    .get(node1)
                    .expect(
                        ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Unknown node {0}", node1),
                                );
                                res
                            })
                            .as_str(),
                    )
                    .get_data_at_time(time)
                    .expect(
                        ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "No state data for node {0} at time {1}",
                                        node1,
                                        time,
                                    ),
                                );
                                res
                            })
                            .as_str(),
                    )
                    .1
                    .pose;
                let node2_pos = position_history
                    .get(node2)
                    .expect(
                        ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Unknown node {0}", node2),
                                );
                                res
                            })
                            .as_str(),
                    )
                    .get_data_at_time(time)
                    .expect(
                        ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "No state data for node {0} at time {1}",
                                        node2,
                                        time,
                                    ),
                                );
                                res
                            })
                            .as_str(),
                    )
                    .1
                    .pose;
                let distance = (node1_pos.rows(0, 2) - node2_pos.rows(0, 2)).norm();
                distance
            }
            pub fn process_messages(
                &self,
                position_history: &BTreeMap<String, TimeOrderedData<State>>,
            ) {
                let mut message_sent = false;
                let mut circulating_messages = self
                    .time_cv
                    .circulating_messages
                    .lock()
                    .unwrap();
                for (node_name, receiver) in self.nodes_receivers.iter() {
                    if let Ok(msg) = receiver.try_recv() {
                        *circulating_messages -= 1;
                        match &msg.to {
                            MessageSendMethod::Recipient(r) => {
                                if msg.range == 0.
                                    || msg.range
                                        >= NetworkManager::distance_between(
                                            position_history,
                                            node_name,
                                            r,
                                            msg.time,
                                        )
                                {
                                    if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                                        {
                                            {
                                                let lvl = ::log::Level::Debug;
                                                if lvl <= ::log::STATIC_MAX_LEVEL
                                                    && lvl <= ::log::max_level()
                                                {
                                                    ::log::__private_api::log(
                                                        { ::log::__private_api::GlobalLogger },
                                                        format_args!(
                                                            "Receiving message from `{0}` for `{1}`... Sending",
                                                            node_name,
                                                            r,
                                                        ),
                                                        lvl,
                                                        &(
                                                            "simba::networking::network_manager",
                                                            "simba::networking::network_manager",
                                                            ::log::__private_api::loc(),
                                                        ),
                                                        (),
                                                    );
                                                }
                                            }
                                        };
                                    }
                                    *circulating_messages += 1;
                                    self.nodes_senders
                                        .get(r)
                                        .expect(
                                            ::alloc::__export::must_use({
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("Unknown node {0}", r),
                                                    );
                                                    res
                                                })
                                                .as_str(),
                                        )
                                        .send(msg)
                                        .unwrap();
                                    message_sent = true;
                                } else {
                                    if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                                        {
                                            {
                                                let lvl = ::log::Level::Debug;
                                                if lvl <= ::log::STATIC_MAX_LEVEL
                                                    && lvl <= ::log::max_level()
                                                {
                                                    ::log::__private_api::log(
                                                        { ::log::__private_api::GlobalLogger },
                                                        format_args!(
                                                            "Receiving message from `{0}` for `{1}`... Out of range",
                                                            node_name,
                                                            r,
                                                        ),
                                                        lvl,
                                                        &(
                                                            "simba::networking::network_manager",
                                                            "simba::networking::network_manager",
                                                            ::log::__private_api::loc(),
                                                        ),
                                                        (),
                                                    );
                                                }
                                            }
                                        };
                                    }
                                }
                            }
                            MessageSendMethod::Broadcast => {
                                for (recipient_name, sender) in self.nodes_senders.iter() {
                                    if msg.range == 0.
                                        || msg.range
                                            >= NetworkManager::distance_between(
                                                position_history,
                                                node_name,
                                                recipient_name,
                                                msg.time,
                                            )
                                    {
                                        if is_enabled(crate::logger::InternalLog::NetworkMessages) {
                                            {
                                                {
                                                    let lvl = ::log::Level::Debug;
                                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                                        && lvl <= ::log::max_level()
                                                    {
                                                        ::log::__private_api::log(
                                                            { ::log::__private_api::GlobalLogger },
                                                            format_args!(
                                                                "Receiving message from `{0}` for broadcast... Sending to `{1}`",
                                                                node_name,
                                                                recipient_name,
                                                            ),
                                                            lvl,
                                                            &(
                                                                "simba::networking::network_manager",
                                                                "simba::networking::network_manager",
                                                                ::log::__private_api::loc(),
                                                            ),
                                                            (),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        *circulating_messages += 1;
                                        sender.send(msg.clone()).unwrap();
                                        message_sent = true;
                                    }
                                }
                            }
                        }
                    }
                }
                std::mem::drop(circulating_messages);
                if message_sent {
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Wait for CV lock"),
                                        lvl,
                                        &(
                                            "simba::networking::network_manager",
                                            "simba::networking::network_manager",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    let lk = self.time_cv.finished_nodes.lock().unwrap();
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Got CV lock"),
                                        lvl,
                                        &(
                                            "simba::networking::network_manager",
                                            "simba::networking::network_manager",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    self.time_cv.condvar.notify_all();
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Release CV lock"),
                                        lvl,
                                        &(
                                            "simba::networking::network_manager",
                                            "simba::networking::network_manager",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    std::mem::drop(lk);
                }
            }
        }
    }
    pub mod service {
        /*!
Provides a service system to handle two-way communication between nodes, with the
client node beeing blocked until the server node sends a response.

The server node should create a [`Service`] and handle the requests in
[`run_time_step`](crate::node::Robot::run_time_step). The client node should get a
[`ServiceClient`] instance to be able to make a request.

To operate a service, two messages types should be defined:
- The request message type, which is sent by the client to the server.
- The response message type, which is sent by the server to the client.
*/
        use core::f32;
        use std::{
            collections::BTreeMap, fmt::Debug, sync::{mpsc, Arc, Condvar, Mutex, RwLock},
        };
        use log::debug;
        use crate::{
            logger::is_enabled, node::Node, simulator::TimeCv,
            utils::time_ordered_data::TimeOrderedData,
        };
        use super::network::MessageFlag;
        pub trait ServiceInterface: Debug + Send + Sync {
            fn process_requests(&self) -> usize;
            fn handle_requests(&self, time: f32);
            fn next_time(&self) -> (f32, bool);
        }
        /// Client to make requests to a service.
        ///
        /// The client is linked to a server, and can make requests to it. The client is blocked until the
        /// server sends a response.
        pub struct ServiceClient<RequestMsg: Debug + Clone, ResponseMsg: Debug + Clone> {
            response_channel: Arc<Mutex<mpsc::Receiver<Result<ResponseMsg, String>>>>,
            request_channel: Arc<
                Mutex<mpsc::Sender<(String, RequestMsg, f32, Vec<MessageFlag>)>>,
            >,
            time_cv: Arc<TimeCv>,
        }
        #[automatically_derived]
        impl<
            RequestMsg: ::core::fmt::Debug + Debug + Clone,
            ResponseMsg: ::core::fmt::Debug + Debug + Clone,
        > ::core::fmt::Debug for ServiceClient<RequestMsg, ResponseMsg> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ServiceClient",
                    "response_channel",
                    &self.response_channel,
                    "request_channel",
                    &self.request_channel,
                    "time_cv",
                    &&self.time_cv,
                )
            }
        }
        #[automatically_derived]
        impl<
            RequestMsg: ::core::clone::Clone + Debug + Clone,
            ResponseMsg: ::core::clone::Clone + Debug + Clone,
        > ::core::clone::Clone for ServiceClient<RequestMsg, ResponseMsg> {
            #[inline]
            fn clone(&self) -> ServiceClient<RequestMsg, ResponseMsg> {
                ServiceClient {
                    response_channel: ::core::clone::Clone::clone(
                        &self.response_channel,
                    ),
                    request_channel: ::core::clone::Clone::clone(&self.request_channel),
                    time_cv: ::core::clone::Clone::clone(&self.time_cv),
                }
            }
        }
        impl<
            RequestMsg: Debug + Clone,
            ResponseMsg: Debug + Clone,
        > ServiceClient<RequestMsg, ResponseMsg> {
            /// Make a request to the server.
            ///
            /// The client is blocked until the server sends a response. The client is linked to a server,
            /// and is made by it through the [`Service::new_client`](crate::networking::service::Service::new_client)
            /// method.
            ///
            /// ## Arguments
            /// * `node` - Reference to the [`Robot`] making the request.
            /// * `req` - Request message to send to the server.
            /// * `time` - Time at which the request is made.
            ///
            /// ## Returns
            /// The response from the server, or an error message if the request failed.
            pub fn send_request(
                &self,
                node_name: String,
                req: RequestMsg,
                time: f32,
                message_flags: Vec<MessageFlag>,
            ) -> Result<(), String> {
                if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Sending a request"),
                                    lvl,
                                    &(
                                        "simba::networking::service",
                                        "simba::networking::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let mut circulating_messages = self
                    .time_cv
                    .circulating_messages
                    .lock()
                    .unwrap();
                *circulating_messages += 1;
                std::mem::drop(circulating_messages);
                match self
                    .request_channel
                    .lock()
                    .unwrap()
                    .send((node_name, req, time, message_flags))
                {
                    Err(e) => {
                        #[cold]
                        #[track_caller]
                        #[inline(never)]
                        #[rustc_const_panic_str]
                        #[rustc_do_not_const_check]
                        const fn panic_cold_display<T: ::core::fmt::Display>(
                            arg: &T,
                        ) -> ! {
                            ::core::panicking::panic_display(arg)
                        }
                        panic_cold_display(&e.to_string());
                    }
                    _ => {}
                }
                if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Sending a request: OK"),
                                    lvl,
                                    &(
                                        "simba::networking::service",
                                        "simba::networking::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let lk = self.time_cv.finished_nodes.lock().unwrap();
                if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Lock acquired in service"),
                                    lvl,
                                    &(
                                        "simba::networking::service",
                                        "simba::networking::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Wake waiting nodes"),
                                    lvl,
                                    &(
                                        "simba::networking::service",
                                        "simba::networking::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                self.time_cv.condvar.notify_all();
                if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Release CV lock"),
                                    lvl,
                                    &(
                                        "simba::networking::service",
                                        "simba::networking::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                std::mem::drop(lk);
                Ok(())
            }
            pub fn try_recv(&self) -> Result<ResponseMsg, String> {
                let result = match self.response_channel.lock().unwrap().try_recv() {
                    Ok(result) => result,
                    Err(e) => return Err(e.to_string()),
                };
                let mut circulating_messages = self
                    .time_cv
                    .circulating_messages
                    .lock()
                    .unwrap();
                *circulating_messages -= 1;
                if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Result received"),
                                    lvl,
                                    &(
                                        "simba::networking::service",
                                        "simba::networking::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                result
            }
        }
        /// Service to handle requests from clients.
        ///
        /// Handles requests from clients, and send responses to them. The server should handle
        /// the requests in [`run_time_step`](crate::node::Robot::run_time_step).
        pub struct Service<
            RequestMsg: Debug + Clone,
            ResponseMsg: Debug + Clone,
            T: HasService<RequestMsg, ResponseMsg> + ?Sized,
        > {
            /// Channel to receive requests from clients.
            request_channel: Arc<
                Mutex<mpsc::Receiver<(String, RequestMsg, f32, Vec<MessageFlag>)>>,
            >,
            /// Channel to send requests to the server, which is cloned to the clients.
            request_channel_give: Arc<
                Mutex<mpsc::Sender<(String, RequestMsg, f32, Vec<MessageFlag>)>>,
            >,
            /// Map of the clients and their sender channel, to send responses.
            clients: BTreeMap<
                String,
                Arc<Mutex<mpsc::Sender<Result<ResponseMsg, String>>>>,
            >,
            /// Buffer to store the requests until it is time to treat them.
            request_buffer: Arc<
                RwLock<TimeOrderedData<(String, RequestMsg, Vec<MessageFlag>)>>,
            >,
            /// Simulator condition variable needed so that all nodes wait the end of others,
            /// and continue to treat messages.
            time_cv: Arc<TimeCv>,
            target: Arc<RwLock<Box<T>>>,
        }
        #[automatically_derived]
        impl<
            RequestMsg: ::core::fmt::Debug + Debug + Clone,
            ResponseMsg: ::core::fmt::Debug + Debug + Clone,
            T: ::core::fmt::Debug + HasService<RequestMsg, ResponseMsg> + ?Sized,
        > ::core::fmt::Debug for Service<RequestMsg, ResponseMsg, T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "request_channel",
                    "request_channel_give",
                    "clients",
                    "request_buffer",
                    "time_cv",
                    "target",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.request_channel,
                    &self.request_channel_give,
                    &self.clients,
                    &self.request_buffer,
                    &self.time_cv,
                    &&self.target,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Service",
                    names,
                    values,
                )
            }
        }
        impl<
            RequestMsg: Debug + Clone,
            ResponseMsg: Debug + Clone,
            T: HasService<RequestMsg, ResponseMsg> + ?Sized,
        > Service<RequestMsg, ResponseMsg, T> {
            /// Create a new service.
            ///
            /// ## Arguments
            /// * `time_cv` - Condition variable of the simulator, to wait the end of the nodes.
            pub fn new(time_cv: Arc<TimeCv>, target: Arc<RwLock<Box<T>>>) -> Self {
                let (tx, rx) = mpsc::channel::<
                    (String, RequestMsg, f32, Vec<MessageFlag>),
                >();
                Self {
                    request_channel_give: Arc::new(Mutex::new(tx)),
                    request_channel: Arc::new(Mutex::new(rx)),
                    clients: BTreeMap::new(),
                    request_buffer: Arc::new(RwLock::new(TimeOrderedData::new())),
                    time_cv,
                    target,
                }
            }
            /// Makes a new client to the service, with the channels already setup.
            ///
            /// ## Arguments
            /// * `node_name` - Name of the client node, to be able to send responses to it.
            pub fn new_client(
                &mut self,
                node_name: &str,
            ) -> ServiceClient<RequestMsg, ResponseMsg> {
                let (tx, rx) = mpsc::channel::<Result<ResponseMsg, String>>();
                self.clients.insert(node_name.to_string(), Arc::new(Mutex::new(tx)));
                ServiceClient {
                    request_channel: self.request_channel_give.clone(),
                    response_channel: Arc::new(Mutex::new(rx)),
                    time_cv: self.time_cv.clone(),
                }
            }
        }
        impl<
            RequestMsg: Clone + Debug + Send + Sync,
            ResponseMsg: Clone + Debug + Send + Sync,
            T: HasService<RequestMsg, ResponseMsg> + ?Sized,
        > ServiceInterface for Service<RequestMsg, ResponseMsg, T> {
            /// Process the requests received from the clients.
            ///
            /// The requests are added to the buffer, to be treated later by
            /// [`handle_service_requests`](Service::handle_service_requests).
            ///
            /// ## Returns
            /// The number of requests remaining in the buffer.
            fn process_requests(&self) -> usize {
                for (from, message, time, message_flags) in self
                    .request_channel
                    .lock()
                    .unwrap()
                    .try_iter()
                {
                    let mut circulating_messages = self
                        .time_cv
                        .circulating_messages
                        .lock()
                        .unwrap();
                    *circulating_messages -= 1;
                    std::mem::drop(circulating_messages);
                    if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Insert request from {0} at time {1}",
                                            from,
                                            time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::networking::service",
                                            "simba::networking::service",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    self.request_buffer
                        .write()
                        .unwrap()
                        .insert(time, (from, message, message_flags), false);
                }
                self.request_buffer.read().unwrap().len()
            }
            /// Handle the requests received from the clients at the given `time`.
            ///
            /// The `closure` is called for each request matching the given `time`, and should
            /// return the response to send to the client. The request is then removed from the
            /// buffer. If no request is matching the given `time`, the method does nothing.
            fn handle_requests(&self, time: f32) {
                while let Some((_msg_time, (from, message, _message_flags))) = self
                    .request_buffer
                    .write()
                    .unwrap()
                    .remove(time)
                {
                    if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Handling message from {0} at time {1}...",
                                            from,
                                            time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::networking::service",
                                            "simba::networking::service",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    let result = self
                        .target
                        .write()
                        .unwrap()
                        .handle_service_requests(message, time);
                    if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Got result"),
                                        lvl,
                                        &(
                                            "simba::networking::service",
                                            "simba::networking::service",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    {
                        let mut circulating_messages = self
                            .time_cv
                            .circulating_messages
                            .lock()
                            .unwrap();
                        *circulating_messages += 1;
                    }
                    self.clients
                        .get(&from)
                        .expect(
                            ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Given sender ({0}) is not known, use \'get_client\' accordingly",
                                            from,
                                        ),
                                    );
                                    res
                                })
                                .as_str(),
                        )
                        .lock()
                        .unwrap()
                        .send(result)
                        .expect("Fail to send response");
                    if is_enabled(crate::logger::InternalLog::ServiceHandling) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Handling message from {0} at time {1}... Response sent",
                                            from,
                                            time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::networking::service",
                                            "simba::networking::service",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                }
            }
            /// Get the minimal time among all waiting requests.
            fn next_time(&self) -> (f32, bool) {
                match self.request_buffer.read().unwrap().min_time() {
                    Some((time, tpl)) => (time, tpl.2.contains(&MessageFlag::ReadOnly)),
                    None => (f32::INFINITY, false),
                }
            }
        }
        /// Trait for specific service handlers, which can be different from
        /// the struct which own the service (e.g. in case of strategy pattern).
        pub trait ServiceHandler<RequestMsg, ResponseMsg>: Sync + Send + Debug {
            fn treat_request(
                &self,
                req: RequestMsg,
                time: f32,
            ) -> Result<ResponseMsg, String>;
        }
        /// Common interface for all struct which manages a service.
        pub trait HasService<RequestMsg, ResponseMsg>: Debug + Sync + Send {
            /// Handle the requests received from the clients at the given `time`.
            fn handle_service_requests(
                &mut self,
                req: RequestMsg,
                time: f32,
            ) -> Result<ResponseMsg, String>;
        }
    }
    pub mod service_manager {
        use std::{collections::BTreeMap, fmt::Debug, sync::{Arc, Condvar, Mutex, RwLock}};
        use log::debug;
        use crate::{
            node::Node, physics::physic::{GetRealStateReq, GetRealStateResp, Physic},
            simulator::TimeCv, state_estimators::state_estimator::State,
        };
        use super::{
            network::MessageFlag, service::{Service, ServiceClient, ServiceInterface},
        };
        pub struct ServiceManager {
            get_real_state: Option<
                Arc<RwLock<Service<GetRealStateReq, GetRealStateResp, dyn Physic>>>,
            >,
            get_real_state_clients: BTreeMap<
                String,
                ServiceClient<GetRealStateReq, GetRealStateResp>,
            >,
            time_cv: Arc<TimeCv>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ServiceManager {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ServiceManager",
                    "get_real_state",
                    &self.get_real_state,
                    "get_real_state_clients",
                    &self.get_real_state_clients,
                    "time_cv",
                    &&self.time_cv,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ServiceManager {
            #[inline]
            fn clone(&self) -> ServiceManager {
                ServiceManager {
                    get_real_state: ::core::clone::Clone::clone(&self.get_real_state),
                    get_real_state_clients: ::core::clone::Clone::clone(
                        &self.get_real_state_clients,
                    ),
                    time_cv: ::core::clone::Clone::clone(&self.time_cv),
                }
            }
        }
        impl ServiceManager {
            pub fn initialize(node: &Node, time_cv: Arc<TimeCv>) -> Self {
                Self {
                    get_real_state: match node.node_type.has_physics() {
                        true => {
                            Some(
                                Arc::new(
                                    RwLock::new(
                                        Service::new(time_cv.clone(), node.physics().unwrap()),
                                    ),
                                ),
                            )
                        }
                        false => None,
                    },
                    get_real_state_clients: BTreeMap::new(),
                    time_cv,
                }
            }
            fn get_real_state_client(
                &self,
                node_name: &str,
            ) -> Option<ServiceClient<GetRealStateReq, GetRealStateResp>> {
                if let Some(get_real_state) = &self.get_real_state {
                    Some(get_real_state.write().unwrap().new_client(node_name))
                } else {
                    None
                }
            }
            pub fn get_real_state(
                &self,
                node_name: &String,
                node: &Node,
                time: f32,
            ) -> Option<State> {
                let client = self.get_real_state_clients.get(node_name);
                if client.is_none() {
                    return None;
                }
                let client = client.unwrap();
                client
                    .send_request(
                        node.name(),
                        GetRealStateReq {},
                        time,
                        <[_]>::into_vec(::alloc::boxed::box_new([MessageFlag::God])),
                    )
                    .unwrap();
                let resp;
                loop {
                    if let Ok(r) = client.try_recv() {
                        resp = r;
                        break;
                    }
                    if self.process_requests() > 0 {
                        self.handle_requests(time);
                    }
                }
                Some(resp.state)
            }
            pub fn make_links(
                &mut self,
                service_managers: &BTreeMap<String, Arc<RwLock<ServiceManager>>>,
                node: &Node,
            ) {
                let my_name = node.name();
                for (name, sm) in service_managers {
                    if name == &my_name {
                        continue;
                    }
                    if let Some(client) = sm
                        .read()
                        .unwrap()
                        .get_real_state_client(&my_name)
                    {
                        self.get_real_state_clients.insert(name.clone(), client);
                    }
                }
            }
            pub fn handle_requests(&self, time: f32) {
                if let Some(get_real_state) = &self.get_real_state {
                    get_real_state.read().unwrap().handle_requests(time);
                }
            }
            pub fn process_requests(&self) -> usize {
                let mut s = 0usize;
                if let Some(get_real_state) = &self.get_real_state {
                    s += get_real_state.read().unwrap().process_requests();
                }
                s
            }
            pub fn next_time(&self) -> (f32, bool) {
                let mut min_time = (f32::INFINITY, false);
                if let Some(get_real_state) = &self.get_real_state {
                    let mt = get_real_state.read().unwrap().next_time();
                    if mt.0 < min_time.0 {
                        min_time = mt;
                    }
                }
                min_time
            }
        }
    }
}
pub mod node {
    /*!
Module providing the main node manager, [`Node`], along with the configuration
[`NodeConfig`] and the record [`NodeRecord`] structures.
*/
    use core::f32;
    use std::collections::BTreeMap;
    use std::sync::{Arc, Condvar, Mutex, RwLock};
    use config_checker::macros::Check;
    use log::{debug, info, warn};
    use serde::{Deserialize, Serialize};
    use super::navigators::navigator::{Navigator, NavigatorConfig, NavigatorRecord};
    use super::navigators::trajectory_follower;
    use crate::api::internal_api::{self, NodeClient, NodeServer};
    use crate::constants::TIME_ROUND;
    use crate::controllers::controller::{
        self, Controller, ControllerConfig, ControllerRecord,
    };
    use crate::logger::is_enabled;
    use crate::networking::network::{Network, NetworkConfig};
    use crate::networking::service_manager::ServiceManager;
    use crate::node_factory::{ComputationUnitRecord, NodeRecord, NodeType, RobotRecord};
    use crate::physics::physic::{Physic, PhysicConfig, PhysicRecord};
    use crate::physics::{perfect_physic, physic};
    use crate::simulator::{SimulatorConfig, TimeCv};
    use crate::state_estimators::state_estimator::{
        BenchStateEstimator, BenchStateEstimatorRecord, StateEstimator,
        StateEstimatorConfig, StateEstimatorRecord,
    };
    use crate::state_estimators::{perfect_estimator, state_estimator};
    use crate::sensors::sensor_manager::{
        SensorManager, SensorManagerConfig, SensorManagerRecord,
    };
    use crate::plugin_api::PluginAPI;
    use crate::stateful::Stateful;
    use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
    use crate::utils::maths::round_precision;
    use crate::utils::time_ordered_data::TimeOrderedData;
    use crate::{node, time_analysis};
    /// Structure managing one node.
    ///
    /// It is composed of modules to manage different aspects:
    /// * `navigator` is of [`Navigator`] trait, and defines the error to be sent
    /// to the [`Controller`] to follow the required trajectory.
    /// * `controller` is of [`Controller`] trait, it defines the command to be sent
    /// to the [`Physic`] module.
    /// * `physic` is of [`Physic`] trait. It simulates the node behaviour, its real
    /// state. It contains a ground truth to evaluate the [`StateEstimator`].
    /// * `state_estimator` is of [`StateEstimator`] trait. It estimates the node
    /// state, and send it to the [`Navigator`].
    ///
    /// * `sensor_manager`, of type [`SensorManager`], manages the [`Sensor`]s. The
    /// observations of the sensors are sent to the [`StateEstimator`].
    /// * `network` is the node [`Network`] interface. It manages the reception and
    /// the send of messages to other nodes.
    ///
    /// The [`Node`] internally manages a history of its states, using [`TimeOrderedData`].
    /// In this way, it can get back to a past state, in order to treat a message sent
    /// from the past. [`Node::run_next_time_step`] does the necessary
    /// so that the required time is reached taking into account all past messages.
    pub struct Node {
        pub(crate) node_type: NodeType,
        /// Name of the node. Should be unique among all [`Simulator`](crate::simulator::Simulator)
        /// nodes.
        pub(crate) name: String,
        /// [`Navigator`] module, implementing the navigation strategy.
        pub(crate) navigator: Option<Arc<RwLock<Box<dyn Navigator>>>>,
        /// [`Controller`] module, implementing the control strategy.
        pub(crate) controller: Option<Arc<RwLock<Box<dyn Controller>>>>,
        /// [`Physic`] module, implementing the physics strategy.
        pub(crate) physic: Option<Arc<RwLock<Box<dyn Physic>>>>,
        /// [`StateEstimator`] module, implementing the state estimation strategy.
        pub(crate) state_estimator: Option<Arc<RwLock<Box<dyn StateEstimator>>>>,
        /// Manages all the [`Sensor`]s and send the observations to `state_estimator`.
        pub(crate) sensor_manager: Option<Arc<RwLock<SensorManager>>>,
        /// [`Network`] interface to receive and send messages with other nodes.
        pub(crate) network: Option<Arc<RwLock<Network>>>,
        /// History of the states ([`NodeRecord`]) of the node, to set the [`Node`]
        /// in a past state.
        pub(crate) state_history: TimeOrderedData<NodeRecord>,
        /// Additional [`StateEstimator`] to be evaluated.
        pub(crate) state_estimator_bench: Option<Arc<RwLock<Vec<BenchStateEstimator>>>>,
        /// Not really an option, but for delayed initialization
        pub(crate) service_manager: Option<Arc<RwLock<ServiceManager>>>,
        pub(crate) node_server: Option<NodeServer>,
        pub(crate) time_cv: Arc<TimeCv>,
        pub other_node_names: Vec<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Node {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "node_type",
                "name",
                "navigator",
                "controller",
                "physic",
                "state_estimator",
                "sensor_manager",
                "network",
                "state_history",
                "state_estimator_bench",
                "service_manager",
                "node_server",
                "time_cv",
                "other_node_names",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.node_type,
                &self.name,
                &self.navigator,
                &self.controller,
                &self.physic,
                &self.state_estimator,
                &self.sensor_manager,
                &self.network,
                &self.state_history,
                &self.state_estimator_bench,
                &self.service_manager,
                &self.node_server,
                &self.time_cv,
                &&self.other_node_names,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Node", names, values)
        }
    }
    impl Node {
        /// Initialize the node after its creation.
        ///
        /// It is used to initialize the sensor manager, which need to know the list of all nodes.
        pub fn post_creation_init(
            &mut self,
            service_manager_list: &BTreeMap<String, Arc<RwLock<ServiceManager>>>,
        ) -> NodeClient {
            if is_enabled(crate::logger::InternalLog::SetupSteps) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Node post-creation initialization"),
                                lvl,
                                &(
                                    "simba::node",
                                    "simba::node",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                }
            }
            let service_manager = self.service_manager();
            service_manager.write().unwrap().make_links(service_manager_list, self);
            if let Some(sensor_manager) = self.sensor_manager() {
                sensor_manager.write().unwrap().init(self);
            }
            self.other_node_names = service_manager_list
                .iter()
                .filter_map(|n| {
                    if n.0 != &self.name { Some(n.0.clone()) } else { None }
                })
                .collect();
            if let Some(network) = &self.network {
                if let Some(sensor_manager) = &self.sensor_manager {
                    network.write().unwrap().subscribe(sensor_manager.clone());
                }
            }
            let (node_server, node_client) = internal_api::make_node_api(
                &self.node_type,
            );
            self.node_server = Some(node_server);
            if is_enabled(crate::logger::InternalLog::SetupStepsDetailed) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Save initial state"),
                                lvl,
                                &(
                                    "simba::node",
                                    "simba::node",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            self.save_state(0.);
            node_client
        }
        /// Run the node to reach the given time.
        ///
        /// It will go back in time if needed by old messages or other asynchronous operations.
        ///
        /// ## Arguments
        /// * `time` -- Time to reach.
        ///
        /// ## Return
        /// Next time step.
        pub fn run_next_time_step(&mut self, time: f32, read_only: bool) {
            self.process_messages();
            self.run_time_step(time, read_only);
        }
        /// Process all the messages: one-way (network) and two-way (services).
        pub fn process_messages(&self) -> usize {
            let mut nb_msg = 0;
            if let Some(network) = self.network() {
                nb_msg += network.write().unwrap().process_messages().unwrap();
            }
            nb_msg
                += self
                    .service_manager
                    .as_ref()
                    .unwrap()
                    .read()
                    .unwrap()
                    .process_requests();
            nb_msg
        }
        /// Run only one time step.
        ///
        /// To run the given `time` step, the node sets itself in the state of this moment
        /// using [`Node::set_in_state`].
        ///
        /// The update step is done in this order:
        /// 1. Update the physics
        /// 2. Generate the observations
        /// 3. Correction step of the state estimator
        /// 4. If it is the time for the state estimator to do its prediction step:
        ///     1. The prediction step is done
        ///     2. The navigator computes the error from the state estimation
        ///     3. The command is computed by the Controller
        ///     4. The command is applied to the Physics.
        /// 5. The network messages are handled
        ///
        /// Then, the node state is saved.
        pub fn run_time_step(&mut self, time: f32, read_only: bool) {
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Run time {0}", time),
                            lvl,
                            &("simba::node", "simba::node", ::log::__private_api::loc()),
                            (),
                        );
                    }
                }
            };
            self.set_in_state(time);
            if let Some(physics) = &self.physic {
                physics.write().unwrap().update_state(time);
                self.node_server
                    .as_ref()
                    .unwrap()
                    .state_update
                    .as_ref()
                    .unwrap()
                    .send((time, physics.read().unwrap().state(time).clone()))
                    .unwrap();
            }
            if let Some(sensor_manager) = &self.sensor_manager() {
                let observations = sensor_manager
                    .write()
                    .unwrap()
                    .get_observations(self, time);
                if is_enabled(crate::logger::InternalLog::SensorManager) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Got {0} observations", observations.len()),
                                    lvl,
                                    &(
                                        "simba::node",
                                        "simba::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                if observations.len() > 0 {
                    if let Some(state_estimator) = &self.state_estimator() {
                        let ta = time_analysis::time_analysis(
                            time,
                            "control_loop_state_estimator_correction_step".to_string(),
                        );
                        state_estimator
                            .write()
                            .unwrap()
                            .correction_step(self, &observations, time);
                        time_analysis::finished_time_analysis(ta);
                    }
                    if let Some(state_estimator_bench) = &self.state_estimator_bench() {
                        for state_estimator in state_estimator_bench
                            .read()
                            .unwrap()
                            .iter()
                        {
                            let ta = time_analysis::time_analysis(
                                time,
                                state_estimator.name.clone() + "_correction_step",
                            );
                            state_estimator
                                .state_estimator
                                .write()
                                .unwrap()
                                .correction_step(self, &observations, time);
                            time_analysis::finished_time_analysis(ta);
                        }
                    }
                }
            }
            if let Some(state_estimator) = &self.state_estimator() {
                if time >= state_estimator.read().unwrap().next_time_step() {
                    let ta = time_analysis::time_analysis(
                        time,
                        "control_loop_state_estimator_prediction_step".to_string(),
                    );
                    state_estimator.write().unwrap().prediction_step(self, time);
                    time_analysis::finished_time_analysis(ta);
                    let state = state_estimator.read().unwrap().state();
                    let ta = time_analysis::time_analysis(
                        time,
                        "control_loop_navigator_compute_error".to_string(),
                    );
                    let error = self
                        .navigator()
                        .as_ref()
                        .unwrap()
                        .write()
                        .unwrap()
                        .compute_error(self, state);
                    time_analysis::finished_time_analysis(ta);
                    let ta = time_analysis::time_analysis(
                        time,
                        "control_loop_controller_make_command".to_string(),
                    );
                    let command = self
                        .controller()
                        .as_ref()
                        .unwrap()
                        .write()
                        .unwrap()
                        .make_command(self, &error, time);
                    time_analysis::finished_time_analysis(ta);
                    self.physic
                        .as_ref()
                        .unwrap()
                        .write()
                        .unwrap()
                        .apply_command(&command, time);
                }
            }
            if let Some(state_estimator_bench) = &self.state_estimator_bench() {
                for state_estimator in state_estimator_bench.read().unwrap().iter() {
                    if time
                        >= state_estimator
                            .state_estimator
                            .read()
                            .unwrap()
                            .next_time_step()
                    {
                        let ta = time_analysis::time_analysis(
                            time,
                            state_estimator.name.clone() + "_prediction_step",
                        );
                        state_estimator
                            .state_estimator
                            .write()
                            .unwrap()
                            .prediction_step(self, time);
                        time_analysis::finished_time_analysis(ta);
                    }
                }
            }
            self.handle_messages(time);
            if !read_only {
                self.save_state(time);
            }
        }
        pub fn handle_messages(&mut self, time: f32) {
            if let Some(network) = self.network() {
                network.write().unwrap().handle_message_at_time(self, time);
            }
            self.service_manager
                .as_ref()
                .unwrap()
                .write()
                .unwrap()
                .handle_requests(time);
        }
        /// Computes the next time step, using state estimator, sensors and received messages.
        pub fn next_time_step(&self) -> (f32, bool) {
            let mut next_time_step = f32::INFINITY;
            if let Some(state_estimator) = &self.state_estimator {
                next_time_step = state_estimator
                    .read()
                    .unwrap()
                    .next_time_step()
                    .min(next_time_step);
                if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Next time after state estimator: {0}",
                                        next_time_step,
                                    ),
                                    lvl,
                                    &(
                                        "simba::node",
                                        "simba::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            if let Some(sensor_manager) = &self.sensor_manager {
                next_time_step = sensor_manager
                    .read()
                    .unwrap()
                    .next_time_step()
                    .unwrap_or(f32::INFINITY)
                    .min(next_time_step);
                if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Next time after sensor manager: {0}",
                                        next_time_step,
                                    ),
                                    lvl,
                                    &(
                                        "simba::node",
                                        "simba::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            let mut read_only = false;
            if let Some(network) = &self.network {
                let message_next_time = network.read().unwrap().next_message_time();
                if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "In node: message_next_time: {0}",
                                        match message_next_time {
                                            Some((time, _)) => time,
                                            None => -1.,
                                        },
                                    ),
                                    lvl,
                                    &(
                                        "simba::node",
                                        "simba::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                if let Some(msg_next_time) = message_next_time {
                    if next_time_step > msg_next_time.0 {
                        read_only = msg_next_time.1;
                        next_time_step = msg_next_time.0;
                    }
                    if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Time step changed with message: {0}",
                                            next_time_step,
                                        ),
                                        lvl,
                                        &(
                                            "simba::node",
                                            "simba::node",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                }
                if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Next time after network: {0}",
                                        next_time_step,
                                    ),
                                    lvl,
                                    &(
                                        "simba::node",
                                        "simba::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            if let Some(state_estimator_bench) = &self.state_estimator_bench {
                for state_estimator in state_estimator_bench.read().unwrap().iter() {
                    next_time_step = next_time_step
                        .min(
                            state_estimator
                                .state_estimator
                                .read()
                                .unwrap()
                                .next_time_step(),
                        );
                }
                if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Next time after state estimator bench: {0}",
                                        next_time_step,
                                    ),
                                    lvl,
                                    &(
                                        "simba::node",
                                        "simba::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            let tpl = self.service_manager.as_ref().unwrap().read().unwrap().next_time();
            if next_time_step > tpl.0 {
                read_only = tpl.1;
                next_time_step = tpl.0;
            }
            if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Next time after service manager: {0}",
                                    next_time_step,
                                ),
                                lvl,
                                &(
                                    "simba::node",
                                    "simba::node",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            next_time_step = round_precision(next_time_step, TIME_ROUND).unwrap();
            if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "next_time_step: {0} (read only: {1})",
                                    next_time_step,
                                    read_only,
                                ),
                                lvl,
                                &(
                                    "simba::node",
                                    "simba::node",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            (next_time_step, read_only)
        }
        /// Save the current state to the given `time`.
        fn save_state(&mut self, time: f32) {
            self.state_history.insert(time, self.record(), true);
        }
        /// Set the node in the state just before `time` (but different).
        ///
        /// It should be called for the minimal time before using [`Node::save_state`].
        pub fn set_in_state(&mut self, time: f32) {
            let state_at_time = self.state_history.get_data_before_time(time);
            if state_at_time.is_none() {
                {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("No state to be set in at time {0}", time),
                                lvl,
                                &(
                                    "simba::node",
                                    "simba::node",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                return;
            }
            let state_at_time = state_at_time.unwrap().1;
            self.from_record(state_at_time.clone());
        }
        /// Returs the current state history.
        pub fn record_history(&self) -> &TimeOrderedData<NodeRecord> {
            &self.state_history
        }
        /// Get the name of the node.
        pub fn name(&self) -> String {
            self.name.clone()
        }
        /// Get a Arc clone of network module.
        pub fn network(&self) -> Option<Arc<RwLock<Network>>> {
            match &self.network {
                Some(n) => Some(Arc::clone(n)),
                None => None,
            }
        }
        /// Get a Arc clone of physics module.
        pub fn physics(&self) -> Option<Arc<RwLock<Box<dyn Physic>>>> {
            match &self.physic {
                Some(p) => Some(Arc::clone(p)),
                None => None,
            }
        }
        /// Get a Arc clone of sensor manager.
        pub fn sensor_manager(&self) -> Option<Arc<RwLock<SensorManager>>> {
            match &self.sensor_manager {
                Some(sm) => Some(Arc::clone(sm)),
                None => None,
            }
        }
        /// Get a Arc clone of state estimator module.
        pub fn state_estimator(&self) -> Option<Arc<RwLock<Box<dyn StateEstimator>>>> {
            match &self.state_estimator {
                Some(se) => Some(Arc::clone(se)),
                None => None,
            }
        }
        /// Get a Arc clone of state estimator module.
        pub fn state_estimator_bench(
            &self,
        ) -> Option<Arc<RwLock<Vec<BenchStateEstimator>>>> {
            match &self.state_estimator_bench {
                Some(se) => Some(Arc::clone(se)),
                None => None,
            }
        }
        /// Get a Arc clone of navigator module.
        pub fn navigator(&self) -> Option<Arc<RwLock<Box<dyn Navigator>>>> {
            match &self.navigator {
                Some(n) => Some(Arc::clone(n)),
                None => None,
            }
        }
        /// Get a Arc clone of controller module.
        pub fn controller(&self) -> Option<Arc<RwLock<Box<dyn Controller>>>> {
            match &self.controller {
                Some(c) => Some(Arc::clone(c)),
                None => None,
            }
        }
        /// Get a Arc clone of Service Manager.
        pub fn service_manager(&self) -> Arc<RwLock<ServiceManager>> {
            self.service_manager.as_ref().unwrap().clone()
        }
        fn robot_record(&self) -> RobotRecord {
            let mut record = RobotRecord {
                name: self.name.clone(),
                navigator: self.navigator.as_ref().unwrap().read().unwrap().record(),
                controller: self.controller.as_ref().unwrap().read().unwrap().record(),
                physic: self.physic.as_ref().unwrap().read().unwrap().record(),
                state_estimator: self
                    .state_estimator
                    .as_ref()
                    .unwrap()
                    .read()
                    .unwrap()
                    .record(),
                state_estimator_bench: Vec::new(),
                sensors: self.sensor_manager.as_ref().unwrap().read().unwrap().record(),
            };
            let other_state_estimators = self.state_estimator_bench.clone();
            for additional_state_estimator in other_state_estimators
                .as_ref()
                .unwrap()
                .read()
                .unwrap()
                .iter()
            {
                record
                    .state_estimator_bench
                    .push(BenchStateEstimatorRecord {
                        name: additional_state_estimator.name.clone(),
                        record: additional_state_estimator
                            .state_estimator
                            .read()
                            .unwrap()
                            .record(),
                    });
            }
            record
        }
        fn computation_unit_record(&self) -> ComputationUnitRecord {
            let mut record = ComputationUnitRecord {
                name: self.name.clone(),
                state_estimators: Vec::new(),
                sensor_manager: self.sensor_manager().unwrap().read().unwrap().record(),
            };
            let other_state_estimators = self.state_estimator_bench.clone();
            for additional_state_estimator in other_state_estimators
                .as_ref()
                .unwrap()
                .read()
                .unwrap()
                .iter()
            {
                record
                    .state_estimators
                    .push(BenchStateEstimatorRecord {
                        name: additional_state_estimator.name.clone(),
                        record: additional_state_estimator
                            .state_estimator
                            .read()
                            .unwrap()
                            .record(),
                    });
            }
            record
        }
    }
    impl Stateful<NodeRecord> for Node {
        /// Generate the current state record.
        fn record(&self) -> NodeRecord {
            match &self.node_type {
                NodeType::Robot => NodeRecord::Robot(self.robot_record()),
                NodeType::ComputationUnit => {
                    NodeRecord::ComputationUnit(self.computation_unit_record())
                }
                _ => ::core::panicking::panic("not implemented"),
            }
        }
        /// Change the node to be in the state of the given `record`.
        fn from_record(&mut self, record: NodeRecord) {
            let node_type = record.as_node_type();
            if !(node_type == self.node_type) {
                ::core::panicking::panic("assertion failed: node_type == self.node_type")
            }
            if node_type.has_navigator() {
                self.navigator()
                    .unwrap()
                    .write()
                    .unwrap()
                    .from_record(record.navigator().unwrap().clone());
            }
            if node_type.has_controller() {
                self.controller()
                    .unwrap()
                    .write()
                    .unwrap()
                    .from_record(record.controller().unwrap().clone());
            }
            if node_type.has_physics() {
                self.physics()
                    .unwrap()
                    .write()
                    .unwrap()
                    .from_record(record.physics().unwrap().clone());
            }
            if node_type.has_state_estimator() {
                self.state_estimator()
                    .unwrap()
                    .write()
                    .unwrap()
                    .from_record(record.state_estimator().unwrap().clone());
            }
            if node_type.has_state_estimator_bench() {
                let other_state_estimators = self.state_estimator_bench.clone();
                let state_estimator_bench_record = record
                    .state_estimator_bench()
                    .unwrap();
                for (i, additional_state_estimator) in other_state_estimators
                    .unwrap()
                    .write()
                    .unwrap()
                    .iter_mut()
                    .enumerate()
                {
                    additional_state_estimator
                        .state_estimator
                        .write()
                        .unwrap()
                        .from_record(state_estimator_bench_record[i].record.clone());
                }
            }
        }
    }
}
pub mod node_factory {
    use std::sync::{Arc, Condvar, Mutex, RwLock};
    use config_checker::macros::Check;
    use log::debug;
    use serde::{Deserialize, Serialize};
    use crate::{
        controllers::{
            controller::{self, ControllerConfig, ControllerRecord},
            pid,
        },
        gui::UIComponent, logger::is_enabled,
        navigators::{
            navigator::{self, NavigatorConfig, NavigatorRecord},
            trajectory_follower,
        },
        networking::{
            network::{Network, NetworkConfig},
            service_manager::ServiceManager,
        },
        node::Node,
        physics::{perfect_physic, physic::{self, PhysicConfig, PhysicRecord}},
        plugin_api::PluginAPI,
        sensors::sensor_manager::{
            SensorManager, SensorManagerConfig, SensorManagerRecord,
        },
        simulator::{SimulatorConfig, TimeCv},
        state_estimators::{
            perfect_estimator,
            state_estimator::{
                self, BenchStateEstimator, BenchStateEstimatorConfig,
                BenchStateEstimatorRecord, StateEstimatorConfig, StateEstimatorRecord,
            },
        },
        utils::{
            determinist_random_variable::DeterministRandomVariableFactory,
            time_ordered_data::TimeOrderedData,
        },
    };
    pub enum NodeType {
        Robot,
        Sensor,
        Object,
        ComputationUnit,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NodeType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    NodeType::Robot => "Robot",
                    NodeType::Sensor => "Sensor",
                    NodeType::Object => "Object",
                    NodeType::ComputationUnit => "ComputationUnit",
                },
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for NodeType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    NodeType::Robot => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "NodeType",
                            0u32,
                            "Robot",
                        )
                    }
                    NodeType::Sensor => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "NodeType",
                            1u32,
                            "Sensor",
                        )
                    }
                    NodeType::Object => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "NodeType",
                            2u32,
                            "Object",
                        )
                    }
                    NodeType::ComputationUnit => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "NodeType",
                            3u32,
                            "ComputationUnit",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NodeType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Robot" => _serde::__private::Ok(__Field::__field0),
                            "Sensor" => _serde::__private::Ok(__Field::__field1),
                            "Object" => _serde::__private::Ok(__Field::__field2),
                            "ComputationUnit" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Robot" => _serde::__private::Ok(__Field::__field0),
                            b"Sensor" => _serde::__private::Ok(__Field::__field1),
                            b"Object" => _serde::__private::Ok(__Field::__field2),
                            b"ComputationUnit" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NodeType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NodeType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum NodeType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(NodeType::Robot)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(NodeType::Sensor)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(NodeType::Object)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(NodeType::ComputationUnit)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Robot",
                    "Sensor",
                    "Object",
                    "ComputationUnit",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "NodeType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NodeType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for NodeType {
        #[inline]
        fn clone(&self) -> NodeType {
            match self {
                NodeType::Robot => NodeType::Robot,
                NodeType::Sensor => NodeType::Sensor,
                NodeType::Object => NodeType::Object,
                NodeType::ComputationUnit => NodeType::ComputationUnit,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NodeType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NodeType {
        #[inline]
        fn eq(&self, other: &NodeType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl NodeType {
        pub fn has_physics(&self) -> bool {
            match self {
                Self::Robot | Self::Object => true,
                Self::Sensor | Self::ComputationUnit => false,
            }
        }
        pub fn has_controller(&self) -> bool {
            match self {
                Self::Robot => true,
                Self::Object | Self::Sensor | Self::ComputationUnit => false,
            }
        }
        pub fn has_navigator(&self) -> bool {
            match self {
                Self::Robot => true,
                Self::Object | Self::Sensor | Self::ComputationUnit => false,
            }
        }
        pub fn has_state_estimator(&self) -> bool {
            match self {
                Self::Robot => true,
                Self::Object | Self::Sensor | Self::ComputationUnit => false,
            }
        }
        pub fn has_state_estimator_bench(&self) -> bool {
            match self {
                Self::Robot | Self::Sensor | Self::ComputationUnit => true,
                Self::Object => false,
            }
        }
        pub fn has_sensors(&self) -> bool {
            match self {
                Self::Robot | Self::Sensor | Self::ComputationUnit => true,
                Self::Object => false,
            }
        }
        pub fn has_network(&self) -> bool {
            match self {
                Self::Robot | Self::Sensor | Self::ComputationUnit => true,
                Self::Object => false,
            }
        }
    }
    pub enum NodeRecord {
        Robot(RobotRecord),
        ComputationUnit(ComputationUnitRecord),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NodeRecord {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NodeRecord::Robot(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Robot",
                        &__self_0,
                    )
                }
                NodeRecord::ComputationUnit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ComputationUnit",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for NodeRecord {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    NodeRecord::Robot(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "NodeRecord",
                            0u32,
                            "Robot",
                            __field0,
                        )
                    }
                    NodeRecord::ComputationUnit(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "NodeRecord",
                            1u32,
                            "ComputationUnit",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NodeRecord {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Robot" => _serde::__private::Ok(__Field::__field0),
                            "ComputationUnit" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Robot" => _serde::__private::Ok(__Field::__field0),
                            b"ComputationUnit" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NodeRecord>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NodeRecord;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum NodeRecord",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        RobotRecord,
                                    >(__variant),
                                    NodeRecord::Robot,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        ComputationUnitRecord,
                                    >(__variant),
                                    NodeRecord::ComputationUnit,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Robot", "ComputationUnit"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "NodeRecord",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NodeRecord>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for NodeRecord {
        #[inline]
        fn clone(&self) -> NodeRecord {
            match self {
                NodeRecord::Robot(__self_0) => {
                    NodeRecord::Robot(::core::clone::Clone::clone(__self_0))
                }
                NodeRecord::ComputationUnit(__self_0) => {
                    NodeRecord::ComputationUnit(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    impl NodeRecord {
        pub fn as_node_type(&self) -> NodeType {
            match &self {
                Self::Robot(_) => NodeType::Robot,
                Self::ComputationUnit(_) => NodeType::ComputationUnit,
            }
        }
        pub fn navigator(&self) -> Option<&NavigatorRecord> {
            match &self {
                Self::Robot(robot_record) => Some(&robot_record.navigator),
                Self::ComputationUnit(_) => None,
            }
        }
        pub fn controller(&self) -> Option<&ControllerRecord> {
            match &self {
                Self::Robot(robot_record) => Some(&robot_record.controller),
                Self::ComputationUnit(_) => None,
            }
        }
        pub fn physics(&self) -> Option<&PhysicRecord> {
            match &self {
                Self::Robot(robot_record) => Some(&robot_record.physic),
                Self::ComputationUnit(_) => None,
            }
        }
        pub fn state_estimator(&self) -> Option<&StateEstimatorRecord> {
            match &self {
                Self::Robot(robot_record) => Some(&robot_record.state_estimator),
                Self::ComputationUnit(_) => None,
            }
        }
        pub fn state_estimator_bench(&self) -> Option<&Vec<BenchStateEstimatorRecord>> {
            match &self {
                Self::Robot(robot_record) => Some(&robot_record.state_estimator_bench),
                Self::ComputationUnit(computation_unit_record) => {
                    Some(&computation_unit_record.state_estimators)
                }
            }
        }
        pub fn sensor_manager(&self) -> Option<&SensorManagerRecord> {
            match &self {
                Self::Robot(robot_record) => Some(&robot_record.sensors),
                Self::ComputationUnit(r) => Some(&r.sensor_manager),
            }
        }
    }
    /// Configuration of the [`NodeType::Robot`].
    #[serde(default)]
    #[serde(deny_unknown_fields)]
    pub struct RobotConfig {
        /// Name of the robot.
        pub name: String,
        /// [`Navigator`] to use, and its configuration.
        #[check]
        pub navigator: NavigatorConfig,
        /// [`Controller`] to use, and its configuration.
        #[check]
        pub controller: ControllerConfig,
        /// [`Physic`] to use, and its configuration.
        #[check]
        pub physic: PhysicConfig,
        /// [`StateEstimator`] to use, and its configuration.
        #[check]
        pub state_estimator: StateEstimatorConfig,
        /// [`SensorManager`] configuration, which defines the [`Sensor`]s used.
        #[check]
        pub sensor_manager: SensorManagerConfig,
        /// [`Network`] configuration.
        #[check]
        pub network: NetworkConfig,
        /// Additional [`StateEstimator`] to be evaluated but without a feedback
        /// loop with the [`Navigator`]
        #[check]
        pub state_estimator_bench: Vec<BenchStateEstimatorConfig>,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RobotConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RobotConfig",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "navigator",
                    &self.navigator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "controller",
                    &self.controller,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "physic",
                    &self.physic,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "state_estimator",
                    &self.state_estimator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sensor_manager",
                    &self.sensor_manager,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "network",
                    &self.network,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "state_estimator_bench",
                    &self.state_estimator_bench,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RobotConfig
        where
            RobotConfig: _serde::__private::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 8",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "navigator" => _serde::__private::Ok(__Field::__field1),
                            "controller" => _serde::__private::Ok(__Field::__field2),
                            "physic" => _serde::__private::Ok(__Field::__field3),
                            "state_estimator" => _serde::__private::Ok(__Field::__field4),
                            "sensor_manager" => _serde::__private::Ok(__Field::__field5),
                            "network" => _serde::__private::Ok(__Field::__field6),
                            "state_estimator_bench" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"navigator" => _serde::__private::Ok(__Field::__field1),
                            b"controller" => _serde::__private::Ok(__Field::__field2),
                            b"physic" => _serde::__private::Ok(__Field::__field3),
                            b"state_estimator" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"sensor_manager" => _serde::__private::Ok(__Field::__field5),
                            b"network" => _serde::__private::Ok(__Field::__field6),
                            b"state_estimator_bench" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    RobotConfig: _serde::__private::Default,
                {
                    marker: _serde::__private::PhantomData<RobotConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    RobotConfig: _serde::__private::Default,
                {
                    type Value = RobotConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RobotConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.name,
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            NavigatorConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.navigator,
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ControllerConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.controller,
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            PhysicConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.physic,
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            StateEstimatorConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.state_estimator,
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            SensorManagerConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.sensor_manager,
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            NetworkConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.network,
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Vec<BenchStateEstimatorConfig>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.state_estimator_bench,
                        };
                        _serde::__private::Ok(RobotConfig {
                            name: __field0,
                            navigator: __field1,
                            controller: __field2,
                            physic: __field3,
                            state_estimator: __field4,
                            sensor_manager: __field5,
                            network: __field6,
                            state_estimator_bench: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<NavigatorConfig> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<ControllerConfig> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<PhysicConfig> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            StateEstimatorConfig,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            SensorManagerConfig,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<NetworkConfig> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<
                            Vec<BenchStateEstimatorConfig>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "navigator",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            NavigatorConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "controller",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ControllerConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("physic"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PhysicConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "state_estimator",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            StateEstimatorConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sensor_manager",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SensorManagerConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "network",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            NetworkConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "state_estimator_bench",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<BenchStateEstimatorConfig>,
                                        >(&mut __map)?,
                                    );
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => __default.name,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => __default.navigator,
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => __default.controller,
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => __default.physic,
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => __default.state_estimator,
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => __default.sensor_manager,
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => __default.network,
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => __default.state_estimator_bench,
                        };
                        _serde::__private::Ok(RobotConfig {
                            name: __field0,
                            navigator: __field1,
                            controller: __field2,
                            physic: __field3,
                            state_estimator: __field4,
                            sensor_manager: __field5,
                            network: __field6,
                            state_estimator_bench: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "navigator",
                    "controller",
                    "physic",
                    "state_estimator",
                    "sensor_manager",
                    "network",
                    "state_estimator_bench",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RobotConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<RobotConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for RobotConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "navigator",
                "controller",
                "physic",
                "state_estimator",
                "sensor_manager",
                "network",
                "state_estimator_bench",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.navigator,
                &self.controller,
                &self.physic,
                &self.state_estimator,
                &self.sensor_manager,
                &self.network,
                &&self.state_estimator_bench,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "RobotConfig",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RobotConfig {
        #[inline]
        fn clone(&self) -> RobotConfig {
            RobotConfig {
                name: ::core::clone::Clone::clone(&self.name),
                navigator: ::core::clone::Clone::clone(&self.navigator),
                controller: ::core::clone::Clone::clone(&self.controller),
                physic: ::core::clone::Clone::clone(&self.physic),
                state_estimator: ::core::clone::Clone::clone(&self.state_estimator),
                sensor_manager: ::core::clone::Clone::clone(&self.sensor_manager),
                network: ::core::clone::Clone::clone(&self.network),
                state_estimator_bench: ::core::clone::Clone::clone(
                    &self.state_estimator_bench,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for RobotConfig {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            if !::config_checker::__check_config(&self.navigator, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "navigator",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.controller, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "controller",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.physic, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "physic",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.state_estimator, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "state_estimator",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.sensor_manager, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "sensor_manager",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.network, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "network",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(
                &self.state_estimator_bench,
                depth + 1,
            ) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "state_estimator_bench",
                            "RobotConfig",
                            depth_space,
                        ),
                    );
                };
            }
            ret
        }
    }
    impl Default for RobotConfig {
        /// Default configuration, using:
        /// * Default [`TrajectoryFollower`](trajectory_follower::TrajectoryFollower) navigator.
        /// * Default [`PID`](pid::PID) controller.
        /// * Default [`PerfectPhysic`](perfect_physic::PerfectPhysic) physics.
        /// * Default [`PerfectEstimator`](perfect_estimator::PerfectEstimator) state estimator.
        /// * Default [`SensorManager`] config (no sensors).
        /// * Default [`Network`] config.
        fn default() -> Self {
            RobotConfig {
                name: String::from("NoName"),
                navigator: NavigatorConfig::TrajectoryFollower(
                    Box::new(trajectory_follower::TrajectoryFollowerConfig::default()),
                ),
                controller: ControllerConfig::PID(Box::new(pid::PIDConfig::default())),
                physic: PhysicConfig::Perfect(
                    Box::new(perfect_physic::PerfectPhysicConfig::default()),
                ),
                state_estimator: StateEstimatorConfig::Perfect(
                    perfect_estimator::PerfectEstimatorConfig::default(),
                ),
                sensor_manager: SensorManagerConfig::default(),
                network: NetworkConfig::default(),
                state_estimator_bench: Vec::new(),
            }
        }
    }
    /// State record of [`NodeType::Robot`].
    ///
    /// It contains the dynamic elements and the elements we want to save.
    pub struct RobotRecord {
        /// Name of the robot.
        pub name: String,
        /// Record of the [`Navigator`] module.
        pub navigator: NavigatorRecord,
        /// Record of the [`Controller`] module.
        pub controller: ControllerRecord,
        /// Record of the [`Physic`] module.
        pub physic: PhysicRecord,
        /// Record of the [`StateEstimator`] module.
        pub state_estimator: StateEstimatorRecord,
        /// Record of the additionnal [`StateEstimator`]s, only to evaluate them.
        pub state_estimator_bench: Vec<BenchStateEstimatorRecord>,
        pub sensors: SensorManagerRecord,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RobotRecord {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "navigator",
                "controller",
                "physic",
                "state_estimator",
                "state_estimator_bench",
                "sensors",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.navigator,
                &self.controller,
                &self.physic,
                &self.state_estimator,
                &self.state_estimator_bench,
                &&self.sensors,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "RobotRecord",
                names,
                values,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RobotRecord {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RobotRecord",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "navigator",
                    &self.navigator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "controller",
                    &self.controller,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "physic",
                    &self.physic,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "state_estimator",
                    &self.state_estimator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "state_estimator_bench",
                    &self.state_estimator_bench,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sensors",
                    &self.sensors,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RobotRecord {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "navigator" => _serde::__private::Ok(__Field::__field1),
                            "controller" => _serde::__private::Ok(__Field::__field2),
                            "physic" => _serde::__private::Ok(__Field::__field3),
                            "state_estimator" => _serde::__private::Ok(__Field::__field4),
                            "state_estimator_bench" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "sensors" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"navigator" => _serde::__private::Ok(__Field::__field1),
                            b"controller" => _serde::__private::Ok(__Field::__field2),
                            b"physic" => _serde::__private::Ok(__Field::__field3),
                            b"state_estimator" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"state_estimator_bench" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"sensors" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RobotRecord>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RobotRecord;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RobotRecord",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            NavigatorRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ControllerRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            PhysicRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            StateEstimatorRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<BenchStateEstimatorRecord>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            SensorManagerRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct RobotRecord with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(RobotRecord {
                            name: __field0,
                            navigator: __field1,
                            controller: __field2,
                            physic: __field3,
                            state_estimator: __field4,
                            state_estimator_bench: __field5,
                            sensors: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<NavigatorRecord> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<ControllerRecord> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<PhysicRecord> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            StateEstimatorRecord,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Vec<BenchStateEstimatorRecord>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<
                            SensorManagerRecord,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "navigator",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            NavigatorRecord,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "controller",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ControllerRecord,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("physic"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PhysicRecord,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "state_estimator",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            StateEstimatorRecord,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "state_estimator_bench",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<BenchStateEstimatorRecord>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sensors",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SensorManagerRecord,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("navigator")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("controller")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("physic")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("state_estimator")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "state_estimator_bench",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sensors")?
                            }
                        };
                        _serde::__private::Ok(RobotRecord {
                            name: __field0,
                            navigator: __field1,
                            controller: __field2,
                            physic: __field3,
                            state_estimator: __field4,
                            state_estimator_bench: __field5,
                            sensors: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "navigator",
                    "controller",
                    "physic",
                    "state_estimator",
                    "state_estimator_bench",
                    "sensors",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RobotRecord",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<RobotRecord>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for RobotRecord {
        #[inline]
        fn clone(&self) -> RobotRecord {
            RobotRecord {
                name: ::core::clone::Clone::clone(&self.name),
                navigator: ::core::clone::Clone::clone(&self.navigator),
                controller: ::core::clone::Clone::clone(&self.controller),
                physic: ::core::clone::Clone::clone(&self.physic),
                state_estimator: ::core::clone::Clone::clone(&self.state_estimator),
                state_estimator_bench: ::core::clone::Clone::clone(
                    &self.state_estimator_bench,
                ),
                sensors: ::core::clone::Clone::clone(&self.sensors),
            }
        }
    }
    /// Configuration of the [`NodeType::ComputationUnit`].
    #[serde(default)]
    #[serde(deny_unknown_fields)]
    pub struct ComputationUnitConfig {
        /// Name of the unit.
        pub name: String,
        /// [`Network`] configuration.
        #[check]
        pub network: NetworkConfig,
        /// [`StateEstimator`]s
        #[check]
        pub state_estimators: Vec<BenchStateEstimatorConfig>,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ComputationUnitConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ComputationUnitConfig",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "network",
                    &self.network,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "state_estimators",
                    &self.state_estimators,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ComputationUnitConfig
        where
            ComputationUnitConfig: _serde::__private::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "network" => _serde::__private::Ok(__Field::__field1),
                            "state_estimators" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"network" => _serde::__private::Ok(__Field::__field1),
                            b"state_estimators" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    ComputationUnitConfig: _serde::__private::Default,
                {
                    marker: _serde::__private::PhantomData<ComputationUnitConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    ComputationUnitConfig: _serde::__private::Default,
                {
                    type Value = ComputationUnitConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ComputationUnitConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.name,
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            NetworkConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.network,
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<BenchStateEstimatorConfig>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.state_estimators,
                        };
                        _serde::__private::Ok(ComputationUnitConfig {
                            name: __field0,
                            network: __field1,
                            state_estimators: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<NetworkConfig> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Vec<BenchStateEstimatorConfig>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "network",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            NetworkConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "state_estimators",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<BenchStateEstimatorConfig>,
                                        >(&mut __map)?,
                                    );
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => __default.name,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => __default.network,
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => __default.state_estimators,
                        };
                        _serde::__private::Ok(ComputationUnitConfig {
                            name: __field0,
                            network: __field1,
                            state_estimators: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "network",
                    "state_estimators",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ComputationUnitConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ComputationUnitConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ComputationUnitConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ComputationUnitConfig",
                "name",
                &self.name,
                "network",
                &self.network,
                "state_estimators",
                &&self.state_estimators,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ComputationUnitConfig {
        #[inline]
        fn clone(&self) -> ComputationUnitConfig {
            ComputationUnitConfig {
                name: ::core::clone::Clone::clone(&self.name),
                network: ::core::clone::Clone::clone(&self.network),
                state_estimators: ::core::clone::Clone::clone(&self.state_estimators),
            }
        }
    }
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for ComputationUnitConfig {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            if !::config_checker::__check_config(&self.network, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "network",
                            "ComputationUnitConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.state_estimators, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "state_estimators",
                            "ComputationUnitConfig",
                            depth_space,
                        ),
                    );
                };
            }
            ret
        }
    }
    impl Default for ComputationUnitConfig {
        /// Default configuration, using:
        /// * Default [`Network`] config.
        fn default() -> Self {
            ComputationUnitConfig {
                name: String::from("NoName"),
                network: NetworkConfig::default(),
                state_estimators: Vec::new(),
            }
        }
    }
    /// State record of [`NodeType::ComputationUnit`].
    ///
    /// It contains the dynamic elements and the elements we want to save.
    pub struct ComputationUnitRecord {
        /// Name of the robot.
        pub name: String,
        pub state_estimators: Vec<BenchStateEstimatorRecord>,
        pub sensor_manager: SensorManagerRecord,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ComputationUnitRecord {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ComputationUnitRecord",
                "name",
                &self.name,
                "state_estimators",
                &self.state_estimators,
                "sensor_manager",
                &&self.sensor_manager,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ComputationUnitRecord {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ComputationUnitRecord",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "state_estimators",
                    &self.state_estimators,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sensor_manager",
                    &self.sensor_manager,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ComputationUnitRecord {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "state_estimators" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "sensor_manager" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"state_estimators" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"sensor_manager" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ComputationUnitRecord>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ComputationUnitRecord;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ComputationUnitRecord",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ComputationUnitRecord with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<BenchStateEstimatorRecord>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ComputationUnitRecord with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            SensorManagerRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ComputationUnitRecord with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ComputationUnitRecord {
                            name: __field0,
                            state_estimators: __field1,
                            sensor_manager: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Vec<BenchStateEstimatorRecord>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            SensorManagerRecord,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "state_estimators",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<BenchStateEstimatorRecord>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sensor_manager",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SensorManagerRecord,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("state_estimators")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sensor_manager")?
                            }
                        };
                        _serde::__private::Ok(ComputationUnitRecord {
                            name: __field0,
                            state_estimators: __field1,
                            sensor_manager: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "state_estimators",
                    "sensor_manager",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ComputationUnitRecord",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ComputationUnitRecord>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for ComputationUnitRecord {
        #[inline]
        fn clone(&self) -> ComputationUnitRecord {
            ComputationUnitRecord {
                name: ::core::clone::Clone::clone(&self.name),
                state_estimators: ::core::clone::Clone::clone(&self.state_estimators),
                sensor_manager: ::core::clone::Clone::clone(&self.sensor_manager),
            }
        }
    }
    pub struct NodeFactory {}
    impl NodeFactory {
        pub fn make_robot(
            config: &RobotConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
            va_factory: &DeterministRandomVariableFactory,
            time_cv: Arc<TimeCv>,
        ) -> Node {
            let node_type = NodeType::Robot;
            let mut node = Node {
                node_type,
                name: config.name.clone(),
                navigator: Some(
                    navigator::make_navigator_from_config(
                        &config.navigator,
                        plugin_api,
                        global_config,
                        va_factory,
                    ),
                ),
                controller: Some(
                    controller::make_controller_from_config(
                        &config.controller,
                        plugin_api,
                        global_config,
                        va_factory,
                    ),
                ),
                physic: Some(
                    physic::make_physic_from_config(
                        &config.physic,
                        plugin_api,
                        global_config,
                        va_factory,
                    ),
                ),
                state_estimator: Some(
                    Arc::new(
                        RwLock::new(
                            state_estimator::make_state_estimator_from_config(
                                &config.state_estimator,
                                plugin_api,
                                global_config,
                                va_factory,
                            ),
                        ),
                    ),
                ),
                sensor_manager: Some(
                    Arc::new(
                        RwLock::new(
                            SensorManager::from_config(
                                &config.sensor_manager,
                                plugin_api,
                                global_config,
                                &config.name,
                                va_factory,
                            ),
                        ),
                    ),
                ),
                network: Some(
                    Arc::new(
                        RwLock::new(
                            Network::from_config(
                                config.name.clone(),
                                &config.network,
                                global_config,
                                va_factory,
                                time_cv.clone(),
                            ),
                        ),
                    ),
                ),
                state_history: TimeOrderedData::new(),
                state_estimator_bench: Some(
                    Arc::new(
                        RwLock::new(
                            Vec::with_capacity(config.state_estimator_bench.len()),
                        ),
                    ),
                ),
                service_manager: None,
                node_server: None,
                other_node_names: Vec::new(),
                time_cv: time_cv.clone(),
            };
            for state_estimator_config in &config.state_estimator_bench {
                node.state_estimator_bench
                    .as_ref()
                    .unwrap()
                    .write()
                    .unwrap()
                    .push(BenchStateEstimator {
                        name: state_estimator_config.name.clone(),
                        state_estimator: Arc::new(
                            RwLock::new(
                                state_estimator::make_state_estimator_from_config(
                                    &state_estimator_config.config,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ),
                        ),
                    })
            }
            let service_manager = Some(
                Arc::new(RwLock::new(ServiceManager::initialize(&node, time_cv))),
            );
            if plugin_api.is_some() {
                if let Some(message_handlers) = plugin_api
                    .as_ref()
                    .unwrap()
                    .get_message_handlers(&node)
                {
                    let mut network = node.network.as_ref().unwrap().write().unwrap();
                    for message_handler in message_handlers {
                        network.subscribe(message_handler.clone());
                    }
                }
            }
            if is_enabled(crate::logger::InternalLog::SetupSteps) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Setup services"),
                                lvl,
                                &(
                                    "simba::node_factory",
                                    "simba::node_factory",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            node.service_manager = service_manager;
            node
        }
        pub fn make_computation_unit(
            config: &ComputationUnitConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
            va_factory: &DeterministRandomVariableFactory,
            time_cv: Arc<TimeCv>,
        ) -> Node {
            let node_type = NodeType::ComputationUnit;
            let mut node = Node {
                node_type,
                name: config.name.clone(),
                navigator: None,
                controller: None,
                physic: None,
                state_estimator: None,
                sensor_manager: Some(
                    Arc::new(
                        RwLock::new(
                            SensorManager::from_config(
                                &SensorManagerConfig::default(),
                                plugin_api,
                                global_config,
                                &config.name,
                                va_factory,
                            ),
                        ),
                    ),
                ),
                network: Some(
                    Arc::new(
                        RwLock::new(
                            Network::from_config(
                                config.name.clone(),
                                &config.network,
                                global_config,
                                va_factory,
                                time_cv.clone(),
                            ),
                        ),
                    ),
                ),
                state_history: TimeOrderedData::new(),
                state_estimator_bench: Some(
                    Arc::new(
                        RwLock::new(Vec::with_capacity(config.state_estimators.len())),
                    ),
                ),
                service_manager: None,
                node_server: None,
                other_node_names: Vec::new(),
                time_cv: time_cv.clone(),
            };
            for state_estimator_config in &config.state_estimators {
                node.state_estimator_bench
                    .as_ref()
                    .unwrap()
                    .write()
                    .unwrap()
                    .push(BenchStateEstimator {
                        name: state_estimator_config.name.clone(),
                        state_estimator: Arc::new(
                            RwLock::new(
                                state_estimator::make_state_estimator_from_config(
                                    &state_estimator_config.config,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ),
                        ),
                    })
            }
            let service_manager = Some(
                Arc::new(RwLock::new(ServiceManager::initialize(&node, time_cv))),
            );
            if plugin_api.is_some() {
                if let Some(message_handlers) = plugin_api
                    .as_ref()
                    .unwrap()
                    .get_message_handlers(&node)
                {
                    let mut network = node.network.as_ref().unwrap().write().unwrap();
                    for message_handler in message_handlers {
                        network.subscribe(message_handler.clone());
                    }
                }
            }
            if is_enabled(crate::logger::InternalLog::SetupSteps) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Setup services"),
                                lvl,
                                &(
                                    "simba::node_factory",
                                    "simba::node_factory",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            node.service_manager = service_manager;
            node
        }
    }
}
pub mod physics {
    /*!
This module proposes the [`Physic`](physic::Physic) trait and the perfect physic (no command noise).
*/
    pub mod external_physic {
        /*!
Module providing the interface to use external [`Physic`].

To make your own external physic strategy, the simulator should
be used as a library (see [dedicated page](crate::plugin_api)).

Your own external physic strategy is made using the
[`PluginAPI::get_physic`] function.

For the [`Stateful`] trait, the generic type is [`PhysicRecord`],
and your implementation should return a [`PhysicRecord::External`]
type. The value inside is a [`serde_json::Value`]. Use [`serde_json::to_value`]
and [`serde_json::from_value`] to make the bridge to your own Record struct.
*/
        use config_checker::macros::Check;
        use log::debug;
        use pyo3::{pyclass, pymethods};
        use serde_json::Value;
        use crate::logger::is_enabled;
        use crate::networking::service::HasService;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::State;
        use crate::stateful::Stateful;
        use crate::{
            plugin_api::PluginAPI,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use serde_derive::{Deserialize, Serialize};
        /// Config for the external physic (generic).
        ///
        /// The config for [`ExternalPhysic`] uses a [`serde_json::Value`] to
        /// integrate your own configuration inside the full simulator config.
        ///
        /// In the yaml file, the config could be:
        /// ```YAML
        /// physic:
        ///     External:
        ///         parameter_of_my_own_physic: true
        /// ```
        #[serde(default)]
        pub struct ExternalPhysicConfig {
            /// Config serialized.
            #[serde(flatten)]
            pub config: Value,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalPhysicConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.config,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalPhysicConfig
            where
                ExternalPhysicConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        ExternalPhysicConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<ExternalPhysicConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        ExternalPhysicConfig: _serde::__private::Default,
                    {
                        type Value = ExternalPhysicConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalPhysicConfig",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalPhysicConfig {
                                config: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalPhysicConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalPhysicConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalPhysicConfig",
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalPhysicConfig {
            #[inline]
            fn clone(&self) -> ExternalPhysicConfig {
                ExternalPhysicConfig {
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for ExternalPhysicConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                ret
            }
        }
        impl Default for ExternalPhysicConfig {
            fn default() -> Self {
                Self { config: Value::Null }
            }
        }
        /// Record for the external physic (generic).
        ///
        /// Like [`ExternalPhysicConfig`], [`ExternalPhysic`] uses a [`serde_json::Value`]
        /// to take every record.
        ///
        /// The record is not automatically cast to your own type, the cast should be done
        /// in [`Stateful::from_record`] and [`Stateful::record`] implementations.
        pub struct ExternalPhysicRecord {
            /// Record serialized.
            #[serde(flatten)]
            pub record: Value,
        }
        impl ::pyo3::types::DerefToPyAny for ExternalPhysicRecord {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for ExternalPhysicRecord {
            const NAME: &'static str = "ExternalPhysicRecord";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <ExternalPhysicRecord as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for ExternalPhysicRecord {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a ExternalPhysicRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRef<'py, ExternalPhysicRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut ExternalPhysicRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRefMut<'py, ExternalPhysicRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for ExternalPhysicRecord {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for ExternalPhysicRecord {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                ExternalPhysicRecord,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <ExternalPhysicRecord as ::pyo3::PyTypeInfo>::NAME,
                                c"Record for the external physic (generic).\n\nLike [`ExternalPhysicConfig`], [`ExternalPhysic`] uses a [`serde_json::Value`]\nto take every record.\n\nThe record is not automatically cast to your own type, the cast should be done\nin [`Stateful::from_record`] and [`Stateful::record`] implementations.",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ExternalPhysicRecord> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalPhysicRecord {}
        impl ExternalPhysicRecord {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalPhysicRecord {}
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalPhysicRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.record,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalPhysicRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ExternalPhysicRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ExternalPhysicRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalPhysicRecord",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalPhysicRecord {
                                record: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalPhysicRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalPhysicRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalPhysicRecord",
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalPhysicRecord {
            #[inline]
            fn clone(&self) -> ExternalPhysicRecord {
                ExternalPhysicRecord {
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        impl Default for ExternalPhysicRecord {
            fn default() -> Self {
                Self { record: Value::Null }
            }
        }
        impl ExternalPhysicRecord {
            fn record(&self) -> String {
                self.record.to_string()
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<ExternalPhysicRecord>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<ExternalPhysicRecord> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                            ::pyo3::class::PyMethodDefType::Getter(
                                ::pyo3::class::PyGetterDef::new(
                                    c"record",
                                    ExternalPhysicRecord::__pymethod_get_record__,
                                    c"",
                                ),
                            ),
                        ),
                    ],
                    slots: &[],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalPhysicRecord {
            unsafe fn __pymethod_get_record__(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let result = ::pyo3::callback::convert(
                    py,
                    ExternalPhysicRecord::record(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            ExternalPhysicRecord,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_0,
                        )?,
                    ),
                );
                result
            }
        }
        use super::physic::{
            Command, GetRealStateReq, GetRealStateResp, Physic, PhysicRecord,
        };
        /// External physic strategy, which does the bridge with your own strategy.
        pub struct ExternalPhysic {
            /// External physic.
            physic: Box<dyn Physic>,
        }
        impl ExternalPhysic {
            /// Creates a new [`ExternalPhysic`]
            pub fn new() -> Self {
                Self::from_config(
                    &ExternalPhysicConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Creates a new [`ExternalPhysic`] from the given config.
            ///
            /// <div class="warning">The `plugin_api` is required here !</div>
            ///
            ///  ## Arguments
            /// * `config` -- Scenario config of the External physic.
            /// * `plugin_api` -- Required [`PluginAPI`] implementation.
            /// * `global_config` -- Simulator config.
            /// * `_va_factory` -- Factory for Determinists random variables
            pub fn from_config(
                config: &ExternalPhysicConfig,
                plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Config given: {0:?}", config),
                                    lvl,
                                    &(
                                        "simba::physics::external_physic",
                                        "simba::physics::external_physic",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                Self {
                    physic: plugin_api
                        .as_ref()
                        .expect("Plugin API not set!")
                        .get_physic(&config.config, global_config),
                }
            }
        }
        impl std::fmt::Debug for ExternalPhysic {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("ExternalPhysic {{}}"))
            }
        }
        impl Physic for ExternalPhysic {
            fn apply_command(&mut self, command: &Command, time: f32) {
                self.physic.apply_command(command, time);
            }
            fn state(&self, time: f32) -> &State {
                self.physic.state(time)
            }
            fn update_state(&mut self, time: f32) {
                self.physic.update_state(time);
            }
        }
        impl Stateful<PhysicRecord> for ExternalPhysic {
            fn record(&self) -> PhysicRecord {
                self.physic.record()
            }
            fn from_record(&mut self, record: PhysicRecord) {
                self.physic.from_record(record);
            }
        }
        impl HasService<GetRealStateReq, GetRealStateResp> for ExternalPhysic {
            fn handle_service_requests(
                &mut self,
                _req: GetRealStateReq,
                time: f32,
            ) -> Result<GetRealStateResp, String> {
                Ok(GetRealStateResp {
                    state: self.state(time).clone(),
                })
            }
        }
    }
    pub mod perfect_physic {
        /*!
Provide the implementation of the [`Physic`] trait without any noise added to the [`Command`].
*/
        use crate::networking::service::HasService;
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::{State, StateConfig, StateRecord};
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use config_checker::macros::Check;
        use log::error;
        use nalgebra::SMatrix;
        use serde_derive::{Deserialize, Serialize};
        /// Config for the [`PerfectPhysic`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct PerfectPhysicConfig {
            /// Distance between the two wheels, to compute the angular velocity from the wheel speeds.
            #[check(ge(0.))]
            pub wheel_distance: f32,
            /// Starting state.
            #[check]
            pub initial_state: StateConfig,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PerfectPhysicConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PerfectPhysicConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "wheel_distance",
                        &self.wheel_distance,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "initial_state",
                        &self.initial_state,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PerfectPhysicConfig
            where
                PerfectPhysicConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "wheel_distance" => _serde::__private::Ok(__Field::__field0),
                                "initial_state" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"wheel_distance" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"initial_state" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        PerfectPhysicConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<PerfectPhysicConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        PerfectPhysicConfig: _serde::__private::Default,
                    {
                        type Value = PerfectPhysicConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PerfectPhysicConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.wheel_distance,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                StateConfig,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.initial_state,
                            };
                            _serde::__private::Ok(PerfectPhysicConfig {
                                wheel_distance: __field0,
                                initial_state: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<StateConfig> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "wheel_distance",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "initial_state",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateConfig,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.wheel_distance,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.initial_state,
                            };
                            _serde::__private::Ok(PerfectPhysicConfig {
                                wheel_distance: __field0,
                                initial_state: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "wheel_distance",
                        "initial_state",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PerfectPhysicConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PerfectPhysicConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PerfectPhysicConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PerfectPhysicConfig",
                    "wheel_distance",
                    &self.wheel_distance,
                    "initial_state",
                    &&self.initial_state,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerfectPhysicConfig {
            #[inline]
            fn clone(&self) -> PerfectPhysicConfig {
                PerfectPhysicConfig {
                    wheel_distance: ::core::clone::Clone::clone(&self.wheel_distance),
                    initial_state: ::core::clone::Clone::clone(&self.initial_state),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for PerfectPhysicConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.wheel_distance >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "wheel_distance",
                                "PerfectPhysicConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !::config_checker::__check_config(&self.initial_state, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "initial_state",
                                "PerfectPhysicConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for PerfectPhysicConfig {
            fn default() -> Self {
                Self {
                    wheel_distance: 0.25,
                    initial_state: StateConfig::default(),
                }
            }
        }
        /// Record for the [`PerfectPhysic`].
        pub struct PerfectPhysicRecord {
            /// State at the time `last_time_update`
            pub state: StateRecord,
            /// Time of the state
            pub last_time_update: f32,
            /// Current command applied.
            pub current_command: Command,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PerfectPhysicRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PerfectPhysicRecord",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "state",
                        &self.state,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_time_update",
                        &self.last_time_update,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "current_command",
                        &self.current_command,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PerfectPhysicRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "state" => _serde::__private::Ok(__Field::__field0),
                                "last_time_update" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "current_command" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"state" => _serde::__private::Ok(__Field::__field0),
                                b"last_time_update" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"current_command" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PerfectPhysicRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PerfectPhysicRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PerfectPhysicRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                StateRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PerfectPhysicRecord with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PerfectPhysicRecord with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Command,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct PerfectPhysicRecord with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PerfectPhysicRecord {
                                state: __field0,
                                last_time_update: __field1,
                                current_command: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<StateRecord> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Command> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("state"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_time_update",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "current_command",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Command>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("state")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_time_update")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("current_command")?
                                }
                            };
                            _serde::__private::Ok(PerfectPhysicRecord {
                                state: __field0,
                                last_time_update: __field1,
                                current_command: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "state",
                        "last_time_update",
                        "current_command",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PerfectPhysicRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PerfectPhysicRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PerfectPhysicRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "PerfectPhysicRecord",
                    "state",
                    &self.state,
                    "last_time_update",
                    &self.last_time_update,
                    "current_command",
                    &&self.current_command,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerfectPhysicRecord {
            #[inline]
            fn clone(&self) -> PerfectPhysicRecord {
                PerfectPhysicRecord {
                    state: ::core::clone::Clone::clone(&self.state),
                    last_time_update: ::core::clone::Clone::clone(
                        &self.last_time_update,
                    ),
                    current_command: ::core::clone::Clone::clone(&self.current_command),
                }
            }
        }
        /// Implementation of [`Physic`] with the command perfectly applied.
        pub struct PerfectPhysic {
            /// Distance between the wheels
            wheel_distance: f32,
            /// Current state
            state: State,
            /// Time of the current state.
            last_time_update: f32,
            /// Current command applied.
            current_command: Command,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PerfectPhysic {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "PerfectPhysic",
                    "wheel_distance",
                    &self.wheel_distance,
                    "state",
                    &self.state,
                    "last_time_update",
                    &self.last_time_update,
                    "current_command",
                    &&self.current_command,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerfectPhysic {
            #[inline]
            fn clone(&self) -> PerfectPhysic {
                PerfectPhysic {
                    wheel_distance: ::core::clone::Clone::clone(&self.wheel_distance),
                    state: ::core::clone::Clone::clone(&self.state),
                    last_time_update: ::core::clone::Clone::clone(
                        &self.last_time_update,
                    ),
                    current_command: ::core::clone::Clone::clone(&self.current_command),
                }
            }
        }
        impl PerfectPhysic {
            /// Makes a new [`PerfectPhysic`] situated at (0,0,0) and 25cm between wheels.
            pub fn new() -> Self {
                Self::from_config(
                    &PerfectPhysicConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Makes a new [`PerfectPhysic`] with the given configurations.
            ///
            /// ## Arguments
            /// * `config` - Configuration of [`PerfectPhysic`].
            /// * `plugin_api` - [`PluginAPI`] not used there.
            /// * `global_config` - Configuration of the simulator.
            pub fn from_config(
                config: &PerfectPhysicConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                _global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                PerfectPhysic {
                    wheel_distance: config.wheel_distance,
                    state: State::from_config(&config.initial_state),
                    last_time_update: 0.,
                    current_command: Command {
                        left_wheel_speed: 0.,
                        right_wheel_speed: 0.,
                    },
                }
            }
            /// Compute the state to the given `time`, using `self.command`.
            fn compute_state_until(&mut self, time: f32) {
                let dt = time - self.last_time_update;
                if !(dt > 0.) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "PID delta time should be positive: {0} - {1} = {2} > 0",
                                time,
                                self.last_time_update,
                                dt,
                            ),
                        );
                    }
                }
                let theta = self.state.pose.z;
                let displacement_wheel_left = self.current_command.left_wheel_speed * dt;
                let displacement_wheel_right = self.current_command.right_wheel_speed
                    * dt;
                let translation = (displacement_wheel_left + displacement_wheel_right)
                    / 2.;
                let rotation = (displacement_wheel_right - displacement_wheel_left)
                    / self.wheel_distance;
                self.last_time_update = time;
                let lie_action = SMatrix::<
                    f32,
                    3,
                    3,
                >::new(0., -rotation, translation, rotation, 0., 0., 0., 0., 0.);
                let rot_mat = nalgebra::Rotation2::new(theta).matrix().clone();
                let mut se2_mat = SMatrix::<
                    f32,
                    3,
                    3,
                >::new(
                    rot_mat[(0, 0)],
                    rot_mat[(0, 1)],
                    self.state.pose.x,
                    rot_mat[(1, 0)],
                    rot_mat[(1, 1)],
                    self.state.pose.y,
                    0.,
                    0.,
                    1.,
                );
                se2_mat = se2_mat * lie_action.exp();
                self.state.pose.z = nalgebra::Rotation2::from_matrix(
                        &se2_mat.fixed_view::<2, 2>(0, 0).into(),
                    )
                    .angle();
                self.state.pose.x = se2_mat[(0, 2)];
                self.state.pose.y = se2_mat[(1, 2)];
                self.state.velocity = translation / dt;
            }
        }
        use super::physic::{Command, GetRealStateReq, GetRealStateResp};
        use super::physic::{Physic, PhysicRecord};
        impl Physic for PerfectPhysic {
            /// Apply the given `command` perfectly.
            fn apply_command(&mut self, command: &Command, _time: f32) {
                self.current_command = command.clone();
            }
            /// Compute the state at the given `time`.
            fn update_state(&mut self, time: f32) {
                self.compute_state_until(time);
            }
            /// Return the current state. Do not compute the state again.
            fn state(&self, time: f32) -> &State {
                if !(time == self.last_time_update) {
                    ::core::panicking::panic(
                        "assertion failed: time == self.last_time_update",
                    )
                }
                &self.state
            }
        }
        impl HasService<GetRealStateReq, GetRealStateResp> for PerfectPhysic {
            fn handle_service_requests(
                &mut self,
                _req: GetRealStateReq,
                time: f32,
            ) -> Result<GetRealStateResp, String> {
                Ok(GetRealStateResp {
                    state: self.state(time).clone(),
                })
            }
        }
        impl Stateful<PhysicRecord> for PerfectPhysic {
            fn record(&self) -> PhysicRecord {
                PhysicRecord::Perfect(PerfectPhysicRecord {
                    state: self.state.record(),
                    last_time_update: self.last_time_update,
                    current_command: self.current_command.clone(),
                })
            }
            fn from_record(&mut self, record: PhysicRecord) {
                if let PhysicRecord::Perfect(perfect_record) = record {
                    self.state.from_record(perfect_record.state);
                    self.last_time_update = perfect_record.last_time_update;
                    self.current_command = perfect_record.current_command.clone();
                } else {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Using a PhysicRecord type which does not match the used Physic (PerfectPhysic)",
                                    ),
                                    lvl,
                                    &(
                                        "simba::physics::perfect_physic",
                                        "simba::physics::perfect_physic",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
        }
    }
    pub mod physic {
        /*!
Provide the [`Physic`] trait and the utilitary structs ([`PhysicRecord`] and [`PhysicConfig`]).

It also defines the [`Command`] that it can take. The control is done controlling the speed of the two wheels.

The [`Physic`] implementation should take a command, apply it to the internal state, and it can add noise to it.
However, the [`Physic::state`] should provide the real [`State`].
*/
        extern crate confy;
        use std::sync::{Arc, RwLock};
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        /// Command struct, to control both wheel speed, in m/s.
        pub struct Command {
            /// Left wheel speed.
            pub left_wheel_speed: f32,
            /// Right wheel speed.
            pub right_wheel_speed: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Command {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Command",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "left_wheel_speed",
                        &self.left_wheel_speed,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "right_wheel_speed",
                        &self.right_wheel_speed,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Command {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "left_wheel_speed" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "right_wheel_speed" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"left_wheel_speed" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"right_wheel_speed" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Command>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Command;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Command",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Command with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Command with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Command {
                                left_wheel_speed: __field0,
                                right_wheel_speed: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "left_wheel_speed",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "right_wheel_speed",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("left_wheel_speed")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("right_wheel_speed")?
                                }
                            };
                            _serde::__private::Ok(Command {
                                left_wheel_speed: __field0,
                                right_wheel_speed: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "left_wheel_speed",
                        "right_wheel_speed",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Command",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Command>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for Command {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Command",
                    "left_wheel_speed",
                    &self.left_wheel_speed,
                    "right_wheel_speed",
                    &&self.right_wheel_speed,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Command {
            #[inline]
            fn clone(&self) -> Command {
                Command {
                    left_wheel_speed: ::core::clone::Clone::clone(
                        &self.left_wheel_speed,
                    ),
                    right_wheel_speed: ::core::clone::Clone::clone(
                        &self.right_wheel_speed,
                    ),
                }
            }
        }
        use super::{external_physic, perfect_physic};
        /// Enumeration of the different physic implementations.
        #[serde(deny_unknown_fields)]
        pub enum PhysicConfig {
            Perfect(Box<perfect_physic::PerfectPhysicConfig>),
            External(Box<external_physic::ExternalPhysicConfig>),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PhysicConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        PhysicConfig::Perfect(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "PhysicConfig",
                                0u32,
                                "Perfect",
                                __field0,
                            )
                        }
                        PhysicConfig::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "PhysicConfig",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PhysicConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Perfect" => _serde::__private::Ok(__Field::__field0),
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Perfect" => _serde::__private::Ok(__Field::__field0),
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PhysicConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PhysicConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum PhysicConfig",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<perfect_physic::PerfectPhysicConfig>,
                                        >(__variant),
                                        PhysicConfig::Perfect,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<external_physic::ExternalPhysicConfig>,
                                        >(__variant),
                                        PhysicConfig::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Perfect", "External"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "PhysicConfig",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PhysicConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PhysicConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    PhysicConfig::Perfect(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Perfect",
                            &__self_0,
                        )
                    }
                    PhysicConfig::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PhysicConfig {
            #[inline]
            fn clone(&self) -> PhysicConfig {
                match self {
                    PhysicConfig::Perfect(__self_0) => {
                        PhysicConfig::Perfect(::core::clone::Clone::clone(__self_0))
                    }
                    PhysicConfig::External(__self_0) => {
                        PhysicConfig::External(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for PhysicConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                match &self {
                    PhysicConfig::Perfect(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Perfect",
                                        "PhysicConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    PhysicConfig::External(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "External",
                                        "PhysicConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    _ => {}
                };
                ret
            }
        }
        /// Enumeration of the records by physic implementations.
        pub enum PhysicRecord {
            Perfect(perfect_physic::PerfectPhysicRecord),
            External(external_physic::ExternalPhysicRecord),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PhysicRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        PhysicRecord::Perfect(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "PhysicRecord",
                                0u32,
                                "Perfect",
                                __field0,
                            )
                        }
                        PhysicRecord::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "PhysicRecord",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PhysicRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Perfect" => _serde::__private::Ok(__Field::__field0),
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Perfect" => _serde::__private::Ok(__Field::__field0),
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PhysicRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PhysicRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum PhysicRecord",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            perfect_physic::PerfectPhysicRecord,
                                        >(__variant),
                                        PhysicRecord::Perfect,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            external_physic::ExternalPhysicRecord,
                                        >(__variant),
                                        PhysicRecord::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Perfect", "External"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "PhysicRecord",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PhysicRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PhysicRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    PhysicRecord::Perfect(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Perfect",
                            &__self_0,
                        )
                    }
                    PhysicRecord::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PhysicRecord {
            #[inline]
            fn clone(&self) -> PhysicRecord {
                match self {
                    PhysicRecord::Perfect(__self_0) => {
                        PhysicRecord::Perfect(::core::clone::Clone::clone(__self_0))
                    }
                    PhysicRecord::External(__self_0) => {
                        PhysicRecord::External(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        impl PhysicRecord {
            pub fn pose(&self) -> [f32; 3] {
                match self {
                    Self::External(p) => [0., 0., 0.],
                    Self::Perfect(p) => p.state.pose.into(),
                }
            }
        }
        use crate::{
            networking::service::HasService, plugin_api::PluginAPI,
            simulator::SimulatorConfig, state_estimators::state_estimator::State,
            stateful::Stateful,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        pub struct GetRealStateReq {}
        #[automatically_derived]
        impl ::core::fmt::Debug for GetRealStateReq {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "GetRealStateReq")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GetRealStateReq {
            #[inline]
            fn clone(&self) -> GetRealStateReq {
                GetRealStateReq {}
            }
        }
        pub struct GetRealStateResp {
            pub state: State,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GetRealStateResp {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "GetRealStateResp",
                    "state",
                    &&self.state,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GetRealStateResp {
            #[inline]
            fn clone(&self) -> GetRealStateResp {
                GetRealStateResp {
                    state: ::core::clone::Clone::clone(&self.state),
                }
            }
        }
        /// Physic simulation trait.
        ///
        /// Different implementation can either use real robots, add noise to command, etc.
        pub trait Physic: std::fmt::Debug + std::marker::Send + std::marker::Sync + Stateful<
                PhysicRecord,
            > + HasService<GetRealStateReq, GetRealStateResp> {
            /// Apply the given `command` to the internal state from the last update time
            /// to the given `time`
            ///
            /// ## Arguments
            /// * `command` - Command to apply
            /// * `time` - Current time, when to apply the command.
            fn apply_command(&mut self, command: &Command, time: f32);
            /// Update the state to the given time, while keeping the previous command.
            fn update_state(&mut self, time: f32);
            /// Get the current real state, the groundtruth.
            fn state(&self, time: f32) -> &State;
        }
        /// Helper function to create a physic from the given configuration.
        ///
        /// ## Arguments
        /// - `config`: The configuration of the physic.
        /// - `plugin_api`: The plugin API, to be used by the physic (if needed).
        /// - `meta_config`: The meta configuration of the simulator.
        /// - `va_factory`: Random variables factory for determinist behavior.
        /// - `time_cv`: Simulator time condition variable, used by services.
        pub fn make_physic_from_config(
            config: &PhysicConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
            va_factory: &DeterministRandomVariableFactory,
        ) -> Arc<RwLock<Box<dyn Physic>>> {
            Arc::new(
                RwLock::new(
                    match &config {
                        PhysicConfig::Perfect(c) => {
                            Box::new(
                                perfect_physic::PerfectPhysic::from_config(
                                    c,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            ) as Box<dyn Physic>
                        }
                        PhysicConfig::External(c) => {
                            Box::new(
                                external_physic::ExternalPhysic::from_config(
                                    c,
                                    plugin_api,
                                    global_config,
                                    va_factory,
                                ),
                            )
                        }
                    },
                ),
            )
        }
    }
    pub mod pybinds {
        use std::{str::FromStr, sync::{mpsc, Arc, Mutex}};
        use log::debug;
        use pyo3::prelude::*;
        use serde_json::Value;
        use crate::{
            logger::is_enabled, networking::service::HasService,
            physics::external_physic::ExternalPhysicRecord,
            pywrappers::{CommandWrapper, StateWrapper},
            state_estimators::state_estimator::State, stateful::Stateful,
        };
        use super::physic::{
            Command, GetRealStateReq, GetRealStateResp, Physic, PhysicRecord,
        };
        pub struct PythonPhysicAsyncClient {
            apply_command_request: mpsc::Sender<(Command, f32)>,
            apply_command_response: Arc<Mutex<mpsc::Receiver<()>>>,
            state_request: mpsc::Sender<f32>,
            state_response: Arc<Mutex<mpsc::Receiver<State>>>,
            update_state_request: mpsc::Sender<f32>,
            update_state_response: Arc<Mutex<mpsc::Receiver<()>>>,
            record_request: mpsc::Sender<()>,
            record_response: Arc<Mutex<mpsc::Receiver<PhysicRecord>>>,
            from_record_request: mpsc::Sender<PhysicRecord>,
            from_record_response: Arc<Mutex<mpsc::Receiver<()>>>,
            last_state: State,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonPhysicAsyncClient {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "apply_command_request",
                    "apply_command_response",
                    "state_request",
                    "state_response",
                    "update_state_request",
                    "update_state_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                    "last_state",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.apply_command_request,
                    &self.apply_command_response,
                    &self.state_request,
                    &self.state_response,
                    &self.update_state_request,
                    &self.update_state_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &self.from_record_response,
                    &&self.last_state,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonPhysicAsyncClient",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PythonPhysicAsyncClient {
            #[inline]
            fn clone(&self) -> PythonPhysicAsyncClient {
                PythonPhysicAsyncClient {
                    apply_command_request: ::core::clone::Clone::clone(
                        &self.apply_command_request,
                    ),
                    apply_command_response: ::core::clone::Clone::clone(
                        &self.apply_command_response,
                    ),
                    state_request: ::core::clone::Clone::clone(&self.state_request),
                    state_response: ::core::clone::Clone::clone(&self.state_response),
                    update_state_request: ::core::clone::Clone::clone(
                        &self.update_state_request,
                    ),
                    update_state_response: ::core::clone::Clone::clone(
                        &self.update_state_response,
                    ),
                    record_request: ::core::clone::Clone::clone(&self.record_request),
                    record_response: ::core::clone::Clone::clone(&self.record_response),
                    from_record_request: ::core::clone::Clone::clone(
                        &self.from_record_request,
                    ),
                    from_record_response: ::core::clone::Clone::clone(
                        &self.from_record_response,
                    ),
                    last_state: ::core::clone::Clone::clone(&self.last_state),
                }
            }
        }
        impl Physic for PythonPhysicAsyncClient {
            fn apply_command(&mut self, command: &Command, time: f32) {
                self.apply_command_request.send((command.clone(), time)).unwrap();
                self.apply_command_response.lock().unwrap().recv().unwrap()
            }
            fn state(&self, _time: f32) -> &State {
                &self.last_state
            }
            fn update_state(&mut self, time: f32) {
                self.update_state_request.send(time).unwrap();
                self.update_state_response.lock().unwrap().recv().unwrap();
                self.state_request.send(time).unwrap();
                self.last_state = self
                    .state_response
                    .lock()
                    .unwrap()
                    .recv()
                    .unwrap()
                    .clone();
            }
        }
        impl Stateful<PhysicRecord> for PythonPhysicAsyncClient {
            fn from_record(&mut self, record: PhysicRecord) {
                self.from_record_request.send(record).unwrap();
                self.from_record_response.lock().unwrap().recv().unwrap();
            }
            fn record(&self) -> PhysicRecord {
                self.record_request.send(()).unwrap();
                self.record_response
                    .lock()
                    .unwrap()
                    .recv()
                    .expect("Error during call of record")
            }
        }
        impl HasService<GetRealStateReq, GetRealStateResp> for PythonPhysicAsyncClient {
            fn handle_service_requests(
                &mut self,
                _req: GetRealStateReq,
                time: f32,
            ) -> Result<GetRealStateResp, String> {
                Ok(GetRealStateResp {
                    state: self.state(time).clone(),
                })
            }
        }
        pub struct PythonPhysic {
            model: Py<PyAny>,
            client: PythonPhysicAsyncClient,
            apply_command_request: Arc<Mutex<mpsc::Receiver<(Command, f32)>>>,
            apply_command_response: mpsc::Sender<()>,
            state_request: Arc<Mutex<mpsc::Receiver<f32>>>,
            state_response: mpsc::Sender<State>,
            update_state_request: Arc<Mutex<mpsc::Receiver<f32>>>,
            update_state_response: mpsc::Sender<()>,
            record_request: Arc<Mutex<mpsc::Receiver<()>>>,
            record_response: mpsc::Sender<PhysicRecord>,
            from_record_request: Arc<Mutex<mpsc::Receiver<PhysicRecord>>>,
            from_record_response: mpsc::Sender<()>,
        }
        impl ::pyo3::types::DerefToPyAny for PythonPhysic {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for PythonPhysic {
            const NAME: &'static str = "Physics";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <PythonPhysic as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for PythonPhysic {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a PythonPhysic {
            type Holder = ::std::option::Option<::pyo3::PyRef<'py, PythonPhysic>>;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut PythonPhysic {
            type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, PythonPhysic>>;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for PythonPhysic {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for PythonPhysic {
            const IS_BASETYPE: bool = true;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<PythonPhysic>;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <PythonPhysic as ::pyo3::PyTypeInfo>::NAME,
                                c"",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<PythonPhysic> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonPhysic {}
        impl PythonPhysic {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonPhysic {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonPhysic {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "model",
                    "client",
                    "apply_command_request",
                    "apply_command_response",
                    "state_request",
                    "state_response",
                    "update_state_request",
                    "update_state_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.model,
                    &self.client,
                    &self.apply_command_request,
                    &self.apply_command_response,
                    &self.state_request,
                    &self.state_response,
                    &self.update_state_request,
                    &self.update_state_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonPhysic",
                    names,
                    values,
                )
            }
        }
        impl PythonPhysic {
            pub fn new(py_model: Py<PyAny>) -> PythonPhysic {
                if is_enabled(crate::logger::InternalLog::API) {
                    Python::with_gil(|py| {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Model got: {0}",
                                            py_model.bind(py).dir().unwrap(),
                                        ),
                                        lvl,
                                        &(
                                            "simba::physics::pybinds",
                                            "simba::physics::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    });
                }
                let (apply_command_request_tx, apply_command_request_rx) = mpsc::channel();
                let (apply_command_response_tx, apply_command_response_rx) = mpsc::channel();
                let (state_request_tx, state_request_rx) = mpsc::channel();
                let (state_response_tx, state_response_rx) = mpsc::channel();
                let (update_state_request_tx, update_state_request_rx) = mpsc::channel();
                let (update_state_response_tx, update_state_response_rx) = mpsc::channel();
                let (record_request_tx, record_request_rx) = mpsc::channel();
                let (record_response_tx, record_response_rx) = mpsc::channel();
                let (from_record_request_tx, from_record_request_rx) = mpsc::channel();
                let (from_record_response_tx, from_record_response_rx) = mpsc::channel();
                PythonPhysic {
                    model: py_model,
                    client: PythonPhysicAsyncClient {
                        apply_command_request: apply_command_request_tx,
                        apply_command_response: Arc::new(
                            Mutex::new(apply_command_response_rx),
                        ),
                        state_request: state_request_tx,
                        state_response: Arc::new(Mutex::new(state_response_rx)),
                        update_state_request: update_state_request_tx,
                        update_state_response: Arc::new(
                            Mutex::new(update_state_response_rx),
                        ),
                        record_request: record_request_tx,
                        record_response: Arc::new(Mutex::new(record_response_rx)),
                        from_record_request: from_record_request_tx,
                        from_record_response: Arc::new(
                            Mutex::new(from_record_response_rx),
                        ),
                        last_state: State::new(),
                    },
                    apply_command_request: Arc::new(
                        Mutex::new(apply_command_request_rx),
                    ),
                    apply_command_response: apply_command_response_tx,
                    state_request: Arc::new(Mutex::new(state_request_rx)),
                    state_response: state_response_tx,
                    update_state_request: Arc::new(Mutex::new(update_state_request_rx)),
                    update_state_response: update_state_response_tx,
                    record_request: Arc::new(Mutex::new(record_request_rx)),
                    record_response: record_response_tx,
                    from_record_request: Arc::new(Mutex::new(from_record_request_rx)),
                    from_record_response: from_record_response_tx,
                }
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<PythonPhysic>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<PythonPhysic> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[],
                    slots: &[
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut ::pyo3::ffi::PyTypeObject,
                                    args: *mut ::pyo3::ffi::PyObject,
                                    kwargs: *mut ::pyo3::ffi::PyObject,
                                ) -> *mut ::pyo3::ffi::PyObject {
                                    use ::pyo3::impl_::pyclass::*;
                                    #[allow(unknown_lints, non_local_definitions)]
                                    impl PyClassNewTextSignature<PythonPhysic>
                                    for PyClassImplCollector<PythonPhysic> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str> {
                                            ::std::option::Option::Some("(py_model)")
                                        }
                                    }
                                    ::pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        PythonPhysic::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as ::pyo3::ffi::newfunc as _,
                        },
                    ],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonPhysic {
            unsafe fn __pymethod___new____(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyTypeObject,
                _args: *mut ::pyo3::ffi::PyObject,
                _kwargs: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                use ::pyo3::callback::IntoPyCallbackOutput;
                let _slf_ref = &_slf;
                let function = PythonPhysic::new;
                const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::Some(
                        <PythonPhysic as ::pyo3::type_object::PyTypeInfo>::NAME,
                    ),
                    func_name: "__new__",
                    positional_parameter_names: &["py_model"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) = DESCRIPTION
                    .extract_arguments_tuple_dict::<
                        ::pyo3::impl_::extract_argument::NoVarargs,
                        ::pyo3::impl_::extract_argument::NoVarkeywords,
                    >(py, _args, _kwargs, &mut output)?;
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
                let result = PythonPhysic::new(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "py_model",
                        )?,
                        &gil_refs_checker_0,
                    ),
                );
                let initializer: ::pyo3::PyClassInitializer<PythonPhysic> = result
                    .convert(py)?;
                gil_refs_checker_0.function_arg();
                ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
            }
        }
        impl PythonPhysic {
            pub fn get_client(&self) -> PythonPhysicAsyncClient {
                self.client.clone()
            }
            pub fn check_requests(&mut self) {
                if let Ok((command, time)) = self
                    .apply_command_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.apply_command(&command, time);
                    self.apply_command_response.send(()).unwrap();
                }
                if let Ok(time) = self.state_request.clone().lock().unwrap().try_recv() {
                    let state = self.state(time);
                    self.state_response.send(state).unwrap();
                }
                if let Ok(time) = self
                    .update_state_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.update_state(time);
                    self.update_state_response.send(()).unwrap();
                }
                if let Ok(()) = self.record_request.clone().lock().unwrap().try_recv() {
                    self.record_response.send(self.record()).unwrap();
                }
                if let Ok(record) = self
                    .from_record_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.from_record(record);
                    self.from_record_response.send(()).unwrap();
                }
            }
            fn apply_command(&mut self, command: &Command, time: f32) {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of apply_command",
                                    ),
                                    lvl,
                                    &(
                                        "simba::physics::pybinds",
                                        "simba::physics::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method(
                            "apply_command",
                            (CommandWrapper::from_rust(command), time),
                            None,
                        )
                        .expect(
                            "PythonPhysic does not have a correct 'apply_command' method",
                        );
                });
            }
            fn update_state(&mut self, time: f32) {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of update_state",
                                    ),
                                    lvl,
                                    &(
                                        "simba::physics::pybinds",
                                        "simba::physics::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("update_state", (time,), None)
                        .expect(
                            "PythonPhysic does not have a correct 'update_state' method",
                        );
                });
            }
            fn state(&mut self, time: f32) -> State {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Calling python implementation of state"),
                                    lvl,
                                    &(
                                        "simba::physics::pybinds",
                                        "simba::physics::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let state = Python::with_gil(|py| -> StateWrapper {
                    self.model
                        .bind(py)
                        .call_method("state", (time,), None)
                        .expect("PythonPhysic does not have a correct 'state' method")
                        .extract()
                        .expect(
                            "The 'state' method of PythonPhysic does not return a correct state vector",
                        )
                });
                state.to_rust()
            }
            fn record(&self) -> PhysicRecord {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Calling python implementation of record"),
                                    lvl,
                                    &(
                                        "simba::physics::pybinds",
                                        "simba::physics::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let record_str: String = Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("record", (), None)
                        .expect(
                            "Python implementation of PythonPhysic does not have a correct 'record' method",
                        )
                        .extract()
                        .expect(
                            "The 'record' method of PythonPhysic does not return a valid EstimatorRecord type",
                        )
                });
                let record = ExternalPhysicRecord {
                    record: Value::from_str(record_str.as_str())
                        .expect(
                            "Impossible to get serde_json::Value from the input serialized python structure",
                        ),
                };
                PhysicRecord::External(record)
            }
            fn from_record(&mut self, record: PhysicRecord) {
                if let PhysicRecord::External(record) = record {
                    if is_enabled(crate::logger::InternalLog::API) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Calling python implementation of from_record",
                                        ),
                                        lvl,
                                        &(
                                            "simba::physics::pybinds",
                                            "simba::physics::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    Python::with_gil(|py| {
                        self.model
                            .bind(py)
                            .call_method(
                                "from_record",
                                (serde_json::to_string(&record).unwrap(),),
                                None,
                            )
                            .expect(
                                "Python implementation of PythonPhysic does not have a correct 'from_record' method",
                            );
                    });
                }
            }
        }
    }
}
pub mod sensors {
    /*!
This module provides [`Sensor management`](sensor_manager::SensorManager) and
[`Sensor Implementation`](sensor::Sensor).

The [`SensorManager`](sensor_manager::SensorManager) manages all the sensors of a robot.

## How to add a new sensor ?

To add a new [`Sensor`](sensor::Sensor), you should implement the
[`Sensor`](sensor::Sensor) trait, and add your new implementation to the
[`SensorConfig`](sensor::SensorConfig) and the
[`SensorRecord`](sensor::SensorRecord) enumarations.
*/
    pub mod gnss_sensor {
        /*!
Provides a [`Sensor`] which can provide position and velocity in the global frame.
*/
        use std::sync::{Arc, Mutex, RwLock};
        use super::fault_models::fault_model::{
            make_fault_model_from_config, FaultModel, FaultModelConfig,
        };
        use super::sensor::{Sensor, SensorObservation, SensorRecord};
        use crate::constants::TIME_ROUND;
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::maths::round_precision;
        use config_checker::macros::Check;
        use nalgebra::Vector2;
        use serde_derive::{Deserialize, Serialize};
        extern crate nalgebra as na;
        /// Configuration of the [`GNSSSensor`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct GNSSSensorConfig {
            /// Observation period of the sensor.
            #[check(ge(0.))]
            pub period: f32,
            /// Fault on the x, y positions, and on the x and y velocities
            #[check]
            pub faults: Vec<FaultModelConfig>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GNSSSensorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GNSSSensorConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "period",
                        &self.period,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "faults",
                        &self.faults,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GNSSSensorConfig
            where
                GNSSSensorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "period" => _serde::__private::Ok(__Field::__field0),
                                "faults" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"period" => _serde::__private::Ok(__Field::__field0),
                                b"faults" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        GNSSSensorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<GNSSSensorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        GNSSSensorConfig: _serde::__private::Default,
                    {
                        type Value = GNSSSensorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GNSSSensorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.period,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<FaultModelConfig>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(GNSSSensorConfig {
                                period: __field0,
                                faults: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Vec<FaultModelConfig>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("period"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("faults"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<FaultModelConfig>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.period,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(GNSSSensorConfig {
                                period: __field0,
                                faults: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["period", "faults"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GNSSSensorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GNSSSensorConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for GNSSSensorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "GNSSSensorConfig",
                    "period",
                    &self.period,
                    "faults",
                    &&self.faults,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GNSSSensorConfig {
            #[inline]
            fn clone(&self) -> GNSSSensorConfig {
                GNSSSensorConfig {
                    period: ::core::clone::Clone::clone(&self.period),
                    faults: ::core::clone::Clone::clone(&self.faults),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for GNSSSensorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.period >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "period",
                                "GNSSSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !::config_checker::__check_config(&self.faults, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "faults",
                                "GNSSSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for GNSSSensorConfig {
            fn default() -> Self {
                Self {
                    period: 1.,
                    faults: Vec::new(),
                }
            }
        }
        /// Record of the [`GNSSSensor`], which contains nothing for now.
        pub struct GNSSSensorRecord {
            last_time: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GNSSSensorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GNSSSensorRecord",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_time",
                        &self.last_time,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GNSSSensorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "last_time" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"last_time" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GNSSSensorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GNSSSensorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GNSSSensorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GNSSSensorRecord with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GNSSSensorRecord {
                                last_time: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_time",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_time")?
                                }
                            };
                            _serde::__private::Ok(GNSSSensorRecord {
                                last_time: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["last_time"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GNSSSensorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GNSSSensorRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for GNSSSensorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "GNSSSensorRecord",
                    "last_time",
                    &&self.last_time,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GNSSSensorRecord {
            #[inline]
            fn clone(&self) -> GNSSSensorRecord {
                GNSSSensorRecord {
                    last_time: ::core::clone::Clone::clone(&self.last_time),
                }
            }
        }
        impl Default for GNSSSensorRecord {
            fn default() -> Self {
                Self { last_time: 0. }
            }
        }
        /// Observation of the odometry.
        pub struct GNSSObservation {
            pub position: Vector2<f32>,
            pub velocity: Vector2<f32>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GNSSObservation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "GNSSObservation",
                    "position",
                    &self.position,
                    "velocity",
                    &&self.velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for GNSSObservation {
            #[inline]
            fn default() -> GNSSObservation {
                GNSSObservation {
                    position: ::core::default::Default::default(),
                    velocity: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GNSSObservation {
            #[inline]
            fn clone(&self) -> GNSSObservation {
                GNSSObservation {
                    position: ::core::clone::Clone::clone(&self.position),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GNSSObservation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GNSSObservation",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "position",
                        &self.position,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "velocity",
                        &self.velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GNSSObservation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "position" => _serde::__private::Ok(__Field::__field0),
                                "velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"position" => _serde::__private::Ok(__Field::__field0),
                                b"velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GNSSObservation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GNSSObservation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GNSSObservation",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vector2<f32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GNSSObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vector2<f32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GNSSObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GNSSObservation {
                                position: __field0,
                                velocity: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Vector2<f32>> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vector2<f32>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "position",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vector2<f32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "velocity",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vector2<f32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("position")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("velocity")?
                                }
                            };
                            _serde::__private::Ok(GNSSObservation {
                                position: __field0,
                                velocity: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["position", "velocity"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GNSSObservation",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GNSSObservation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct GNSSObservationRecord {
            pub position: [f32; 2],
            pub velocity: [f32; 2],
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GNSSObservationRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GNSSObservationRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "position",
                        &self.position,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "velocity",
                        &self.velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GNSSObservationRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "position" => _serde::__private::Ok(__Field::__field0),
                                "velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"position" => _serde::__private::Ok(__Field::__field0),
                                b"velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GNSSObservationRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GNSSObservationRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GNSSObservationRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                [f32; 2],
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GNSSObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                [f32; 2],
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GNSSObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GNSSObservationRecord {
                                position: __field0,
                                velocity: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<[f32; 2]> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<[f32; 2]> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "position",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<[f32; 2]>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "velocity",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<[f32; 2]>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("position")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("velocity")?
                                }
                            };
                            _serde::__private::Ok(GNSSObservationRecord {
                                position: __field0,
                                velocity: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["position", "velocity"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GNSSObservationRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                GNSSObservationRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for GNSSObservationRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "GNSSObservationRecord",
                    "position",
                    &self.position,
                    "velocity",
                    &&self.velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GNSSObservationRecord {
            #[inline]
            fn clone(&self) -> GNSSObservationRecord {
                let _: ::core::clone::AssertParamIsClone<[f32; 2]>;
                let _: ::core::clone::AssertParamIsClone<[f32; 2]>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for GNSSObservationRecord {}
        impl Stateful<GNSSObservationRecord> for GNSSObservation {
            fn record(&self) -> GNSSObservationRecord {
                GNSSObservationRecord {
                    position: [self.position.x, self.position.y],
                    velocity: [self.velocity.x, self.velocity.y],
                }
            }
            fn from_record(&mut self, record: GNSSObservationRecord) {
                self.position = Vector2::from_vec(record.position.to_vec());
                self.velocity = Vector2::from_vec(record.velocity.to_vec());
            }
        }
        /// Sensor which observes the robot's odometry
        pub struct GNSSSensor {
            /// Observation period
            period: f32,
            /// Last observation time.
            last_time: f32,
            /// Fault models for x and y positions and on x and y velocities
            faults: Arc<Mutex<Vec<Box<dyn FaultModel>>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GNSSSensor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "GNSSSensor",
                    "period",
                    &self.period,
                    "last_time",
                    &self.last_time,
                    "faults",
                    &&self.faults,
                )
            }
        }
        impl GNSSSensor {
            /// Makes a new [`GNSSSensor`].
            pub fn new() -> Self {
                GNSSSensor::from_config(
                    &GNSSSensorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &"NoName".to_string(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Makes a new [`GNSSSensor`] from the given config.
            pub fn from_config(
                config: &GNSSSensorConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                robot_name: &String,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                let fault_models = Arc::new(Mutex::new(Vec::new()));
                let mut unlock_fault_model = fault_models.lock().unwrap();
                for fault_config in &config.faults {
                    unlock_fault_model
                        .push(
                            make_fault_model_from_config(
                                fault_config,
                                global_config,
                                robot_name,
                                va_factory,
                            ),
                        );
                }
                drop(unlock_fault_model);
                Self {
                    period: config.period,
                    last_time: 0.,
                    faults: fault_models,
                }
            }
        }
        use crate::node::Node;
        impl Sensor for GNSSSensor {
            fn init(&mut self, _robot: &mut Node) {}
            fn get_observations(
                &mut self,
                robot: &mut Node,
                time: f32,
            ) -> Vec<SensorObservation> {
                let arc_physic = robot
                    .physics()
                    .expect("Node with GNSS sensor should have Physics");
                let physic = arc_physic.read().unwrap();
                let mut observation_list = Vec::<SensorObservation>::new();
                if (time - self.next_time_step()).abs() > TIME_ROUND / 2. {
                    return observation_list;
                }
                let state = physic.state(time);
                let velocity = Vector2::<
                    f32,
                >::from_vec(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            state.velocity * state.pose.z.cos(),
                            state.velocity * state.pose.z.sin(),
                        ]),
                    ),
                );
                observation_list
                    .push(
                        SensorObservation::GNSS(GNSSObservation {
                            position: state.pose.fixed_rows::<2>(0).into(),
                            velocity,
                        }),
                    );
                for fault_model in self.faults.lock().unwrap().iter() {
                    fault_model
                        .add_faults(
                            time,
                            self.period,
                            &mut observation_list,
                            SensorObservation::GNSS(GNSSObservation::default()),
                        );
                }
                self.last_time = time;
                observation_list
            }
            fn next_time_step(&self) -> f32 {
                round_precision(self.last_time + self.period, TIME_ROUND).unwrap()
            }
            fn period(&self) -> f32 {
                self.period
            }
        }
        impl Stateful<SensorRecord> for GNSSSensor {
            fn record(&self) -> SensorRecord {
                SensorRecord::GNSSSensor(GNSSSensorRecord {
                    last_time: self.last_time,
                })
            }
            fn from_record(&mut self, record: SensorRecord) {
                if let SensorRecord::GNSSSensor(gnss_record) = record {
                    self.last_time = gnss_record.last_time;
                }
            }
        }
    }
    pub mod odometry_sensor {
        /*!
Provides a [`Sensor`] which can provide linear velocity and angular velocity.
*/
        use std::sync::{Arc, Mutex, RwLock};
        use super::fault_models::fault_model::{
            make_fault_model_from_config, FaultModel, FaultModelConfig,
        };
        use super::sensor::{Sensor, SensorObservation, SensorRecord};
        use crate::constants::TIME_ROUND;
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::{State, StateRecord};
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::maths::round_precision;
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        extern crate nalgebra as na;
        /// Configuration of the [`OdometrySensor`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct OdometrySensorConfig {
            /// Observation period of the sensor.
            #[check[ge(0.)]]
            pub period: f32,
            #[check]
            pub faults: Vec<FaultModelConfig>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OdometrySensorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OdometrySensorConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "period",
                        &self.period,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "faults",
                        &self.faults,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OdometrySensorConfig
            where
                OdometrySensorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "period" => _serde::__private::Ok(__Field::__field0),
                                "faults" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"period" => _serde::__private::Ok(__Field::__field0),
                                b"faults" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        OdometrySensorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<OdometrySensorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        OdometrySensorConfig: _serde::__private::Default,
                    {
                        type Value = OdometrySensorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OdometrySensorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.period,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<FaultModelConfig>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(OdometrySensorConfig {
                                period: __field0,
                                faults: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Vec<FaultModelConfig>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("period"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("faults"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<FaultModelConfig>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.period,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(OdometrySensorConfig {
                                period: __field0,
                                faults: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["period", "faults"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OdometrySensorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OdometrySensorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OdometrySensorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OdometrySensorConfig",
                    "period",
                    &self.period,
                    "faults",
                    &&self.faults,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OdometrySensorConfig {
            #[inline]
            fn clone(&self) -> OdometrySensorConfig {
                OdometrySensorConfig {
                    period: ::core::clone::Clone::clone(&self.period),
                    faults: ::core::clone::Clone::clone(&self.faults),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for OdometrySensorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.period >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "period",
                                "OdometrySensorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !::config_checker::__check_config(&self.faults, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "faults",
                                "OdometrySensorConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for OdometrySensorConfig {
            fn default() -> Self {
                Self {
                    period: 0.1,
                    faults: Vec::new(),
                }
            }
        }
        /// Record of the [`OdometrySensor`], which contains nothing for now.
        pub struct OdometrySensorRecord {
            last_time: f32,
            last_state: StateRecord,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OdometrySensorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OdometrySensorRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_time",
                        &self.last_time,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_state",
                        &self.last_state,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OdometrySensorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "last_time" => _serde::__private::Ok(__Field::__field0),
                                "last_state" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"last_time" => _serde::__private::Ok(__Field::__field0),
                                b"last_state" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<OdometrySensorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OdometrySensorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OdometrySensorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OdometrySensorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                StateRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OdometrySensorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OdometrySensorRecord {
                                last_time: __field0,
                                last_state: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<StateRecord> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_time",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_state",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_time")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_state")?
                                }
                            };
                            _serde::__private::Ok(OdometrySensorRecord {
                                last_time: __field0,
                                last_state: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["last_time", "last_state"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OdometrySensorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OdometrySensorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OdometrySensorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OdometrySensorRecord",
                    "last_time",
                    &self.last_time,
                    "last_state",
                    &&self.last_state,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OdometrySensorRecord {
            #[inline]
            fn clone(&self) -> OdometrySensorRecord {
                OdometrySensorRecord {
                    last_time: ::core::clone::Clone::clone(&self.last_time),
                    last_state: ::core::clone::Clone::clone(&self.last_state),
                }
            }
        }
        impl Default for OdometrySensorRecord {
            fn default() -> Self {
                Self {
                    last_time: 0.,
                    last_state: StateRecord::default(),
                }
            }
        }
        /// Observation of the odometry.
        pub struct OdometryObservation {
            pub linear_velocity: f32,
            pub angular_velocity: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OdometryObservation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OdometryObservation",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "linear_velocity",
                        &self.linear_velocity,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "angular_velocity",
                        &self.angular_velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OdometryObservation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "linear_velocity" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "angular_velocity" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"linear_velocity" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"angular_velocity" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<OdometryObservation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OdometryObservation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OdometryObservation",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OdometryObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OdometryObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OdometryObservation {
                                linear_velocity: __field0,
                                angular_velocity: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "linear_velocity",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "angular_velocity",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("linear_velocity")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("angular_velocity")?
                                }
                            };
                            _serde::__private::Ok(OdometryObservation {
                                linear_velocity: __field0,
                                angular_velocity: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "linear_velocity",
                        "angular_velocity",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OdometryObservation",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OdometryObservation,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OdometryObservation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OdometryObservation",
                    "linear_velocity",
                    &self.linear_velocity,
                    "angular_velocity",
                    &&self.angular_velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for OdometryObservation {
            #[inline]
            fn default() -> OdometryObservation {
                OdometryObservation {
                    linear_velocity: ::core::default::Default::default(),
                    angular_velocity: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OdometryObservation {
            #[inline]
            fn clone(&self) -> OdometryObservation {
                OdometryObservation {
                    linear_velocity: ::core::clone::Clone::clone(&self.linear_velocity),
                    angular_velocity: ::core::clone::Clone::clone(&self.angular_velocity),
                }
            }
        }
        impl Stateful<OdometryObservationRecord> for OdometryObservation {
            fn record(&self) -> OdometryObservationRecord {
                OdometryObservationRecord {
                    linear_velocity: self.linear_velocity,
                    angular_velocity: self.angular_velocity,
                }
            }
            fn from_record(&mut self, record: OdometryObservationRecord) {
                self.linear_velocity = record.linear_velocity;
                self.angular_velocity = record.angular_velocity;
            }
        }
        pub struct OdometryObservationRecord {
            pub linear_velocity: f32,
            pub angular_velocity: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OdometryObservationRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OdometryObservationRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "linear_velocity",
                        &self.linear_velocity,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "angular_velocity",
                        &self.angular_velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OdometryObservationRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "linear_velocity" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "angular_velocity" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"linear_velocity" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"angular_velocity" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            OdometryObservationRecord,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OdometryObservationRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OdometryObservationRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OdometryObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OdometryObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OdometryObservationRecord {
                                linear_velocity: __field0,
                                angular_velocity: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "linear_velocity",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "angular_velocity",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("linear_velocity")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("angular_velocity")?
                                }
                            };
                            _serde::__private::Ok(OdometryObservationRecord {
                                linear_velocity: __field0,
                                angular_velocity: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "linear_velocity",
                        "angular_velocity",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OdometryObservationRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OdometryObservationRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OdometryObservationRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OdometryObservationRecord",
                    "linear_velocity",
                    &self.linear_velocity,
                    "angular_velocity",
                    &&self.angular_velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OdometryObservationRecord {
            #[inline]
            fn clone(&self) -> OdometryObservationRecord {
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for OdometryObservationRecord {}
        /// Sensor which observes the robot's odometry
        pub struct OdometrySensor {
            /// Last state to compute the velocity.
            last_state: State,
            /// Observation period
            period: f32,
            /// Last observation time.
            last_time: f32,
            faults: Arc<Mutex<Vec<Box<dyn FaultModel>>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OdometrySensor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "OdometrySensor",
                    "last_state",
                    &self.last_state,
                    "period",
                    &self.period,
                    "last_time",
                    &self.last_time,
                    "faults",
                    &&self.faults,
                )
            }
        }
        impl OdometrySensor {
            /// Makes a new [`OdometrySensor`].
            pub fn new() -> Self {
                OdometrySensor::from_config(
                    &OdometrySensorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &"NoName".to_string(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Makes a new [`OdometrySensor`] from the given config.
            pub fn from_config(
                config: &OdometrySensorConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                robot_name: &String,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                let fault_models = Arc::new(Mutex::new(Vec::new()));
                let mut unlock_fault_model = fault_models.lock().unwrap();
                for fault_config in &config.faults {
                    unlock_fault_model
                        .push(
                            make_fault_model_from_config(
                                fault_config,
                                global_config,
                                robot_name,
                                va_factory,
                            ),
                        );
                }
                drop(unlock_fault_model);
                Self {
                    last_state: State::new(),
                    period: config.period,
                    last_time: 0.,
                    faults: fault_models,
                }
            }
        }
        use crate::node::Node;
        impl Sensor for OdometrySensor {
            fn init(&mut self, robot: &mut Node) {
                self.last_state = robot
                    .physics()
                    .expect("Node with GNSS sensor should have Physics")
                    .read()
                    .unwrap()
                    .state(0.)
                    .clone();
            }
            fn get_observations(
                &mut self,
                robot: &mut Node,
                time: f32,
            ) -> Vec<SensorObservation> {
                let arc_physic = robot
                    .physics()
                    .expect("Node with Odometry sensor should have Physics");
                let physic = arc_physic.read().unwrap();
                let mut observation_list = Vec::<SensorObservation>::new();
                if (time - self.next_time_step()).abs() > TIME_ROUND / 2. {
                    return observation_list;
                }
                let state = physic.state(time);
                let dt = time - self.last_time;
                observation_list
                    .push(
                        SensorObservation::Odometry(OdometryObservation {
                            linear_velocity: state.velocity,
                            angular_velocity: (state.pose.z - self.last_state.pose.z)
                                / dt,
                        }),
                    );
                for fault_model in self.faults.lock().unwrap().iter() {
                    fault_model
                        .add_faults(
                            time,
                            self.period,
                            &mut observation_list,
                            SensorObservation::Odometry(OdometryObservation::default()),
                        );
                }
                self.last_time = time;
                self.last_state = state.clone();
                observation_list
            }
            fn next_time_step(&self) -> f32 {
                round_precision(self.last_time + self.period, TIME_ROUND).unwrap()
            }
            fn period(&self) -> f32 {
                self.period
            }
        }
        impl Stateful<SensorRecord> for OdometrySensor {
            fn record(&self) -> SensorRecord {
                SensorRecord::OdometrySensor(OdometrySensorRecord {
                    last_time: self.last_time,
                    last_state: self.last_state.record(),
                })
            }
            fn from_record(&mut self, record: SensorRecord) {
                if let SensorRecord::OdometrySensor(odometry_record) = record {
                    self.last_time = odometry_record.last_time;
                    self.last_state.from_record(odometry_record.last_state);
                }
            }
        }
    }
    pub mod oriented_landmark_sensor {
        /*!
Provides a [`Sensor`] which can observe oriented landmarks in the frame of the robot.
*/
        use super::fault_models::fault_model::{
            make_fault_model_from_config, FaultModel, FaultModelConfig,
        };
        use super::sensor::{Sensor, SensorObservation, SensorRecord};
        use crate::constants::TIME_ROUND;
        use crate::plugin_api::PluginAPI;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::State;
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::maths::round_precision;
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        use log::error;
        extern crate nalgebra as na;
        use na::Vector3;
        use std::fmt;
        use std::path::Path;
        use std::sync::{Arc, Mutex, RwLock};
        /// Configuration of the [`OrientedLandmarkSensor`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct OrientedLandmarkSensorConfig {
            /// Max distance of detection.
            #[check[ge(0.)]]
            pub detection_distance: f32,
            /// Path to the map (with real position of the landmarks), relative to the simulator
            /// config path.
            pub map_path: String,
            /// Observation period of the sensor.
            #[check[ge(0.)]]
            pub period: f32,
            #[check]
            pub faults: Vec<FaultModelConfig>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OrientedLandmarkSensorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OrientedLandmarkSensorConfig",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "detection_distance",
                        &self.detection_distance,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "map_path",
                        &self.map_path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "period",
                        &self.period,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "faults",
                        &self.faults,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OrientedLandmarkSensorConfig
            where
                OrientedLandmarkSensorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "detection_distance" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "map_path" => _serde::__private::Ok(__Field::__field1),
                                "period" => _serde::__private::Ok(__Field::__field2),
                                "faults" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"detection_distance" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"map_path" => _serde::__private::Ok(__Field::__field1),
                                b"period" => _serde::__private::Ok(__Field::__field2),
                                b"faults" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        OrientedLandmarkSensorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<
                            OrientedLandmarkSensorConfig,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        OrientedLandmarkSensorConfig: _serde::__private::Default,
                    {
                        type Value = OrientedLandmarkSensorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OrientedLandmarkSensorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.detection_distance,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.map_path,
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.period,
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<FaultModelConfig>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(OrientedLandmarkSensorConfig {
                                detection_distance: __field0,
                                map_path: __field1,
                                period: __field2,
                                faults: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Vec<FaultModelConfig>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "detection_distance",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "map_path",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("period"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("faults"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<FaultModelConfig>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.detection_distance,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.map_path,
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => __default.period,
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(OrientedLandmarkSensorConfig {
                                detection_distance: __field0,
                                map_path: __field1,
                                period: __field2,
                                faults: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "detection_distance",
                        "map_path",
                        "period",
                        "faults",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OrientedLandmarkSensorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OrientedLandmarkSensorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedLandmarkSensorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "OrientedLandmarkSensorConfig",
                    "detection_distance",
                    &self.detection_distance,
                    "map_path",
                    &self.map_path,
                    "period",
                    &self.period,
                    "faults",
                    &&self.faults,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedLandmarkSensorConfig {
            #[inline]
            fn clone(&self) -> OrientedLandmarkSensorConfig {
                OrientedLandmarkSensorConfig {
                    detection_distance: ::core::clone::Clone::clone(
                        &self.detection_distance,
                    ),
                    map_path: ::core::clone::Clone::clone(&self.map_path),
                    period: ::core::clone::Clone::clone(&self.period),
                    faults: ::core::clone::Clone::clone(&self.faults),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for OrientedLandmarkSensorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.detection_distance >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "detection_distance",
                                "OrientedLandmarkSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.period >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "period",
                                "OrientedLandmarkSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !::config_checker::__check_config(&self.faults, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "faults",
                                "OrientedLandmarkSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for OrientedLandmarkSensorConfig {
            fn default() -> Self {
                Self {
                    detection_distance: 5.0,
                    map_path: String::from(""),
                    period: 0.1,
                    faults: Vec::new(),
                }
            }
        }
        /// Record of the [`OrientedLandmarkSensor`], which contains nothing for now.
        pub struct OrientedLandmarkSensorRecord {
            last_time: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OrientedLandmarkSensorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OrientedLandmarkSensorRecord",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_time",
                        &self.last_time,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OrientedLandmarkSensorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "last_time" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"last_time" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            OrientedLandmarkSensorRecord,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OrientedLandmarkSensorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OrientedLandmarkSensorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OrientedLandmarkSensorRecord with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OrientedLandmarkSensorRecord {
                                last_time: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_time",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_time")?
                                }
                            };
                            _serde::__private::Ok(OrientedLandmarkSensorRecord {
                                last_time: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["last_time"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OrientedLandmarkSensorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OrientedLandmarkSensorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedLandmarkSensorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "OrientedLandmarkSensorRecord",
                    "last_time",
                    &&self.last_time,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedLandmarkSensorRecord {
            #[inline]
            fn clone(&self) -> OrientedLandmarkSensorRecord {
                OrientedLandmarkSensorRecord {
                    last_time: ::core::clone::Clone::clone(&self.last_time),
                }
            }
        }
        impl Default for OrientedLandmarkSensorRecord {
            fn default() -> Self {
                Self { last_time: 0. }
            }
        }
        /// Landmark struct, with an `id` and a `pose`, used to read the map file.
        pub struct OrientedLandmark {
            pub id: i32,
            pub pose: Vector3<f32>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedLandmark {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OrientedLandmark",
                    "id",
                    &self.id,
                    "pose",
                    &&self.pose,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedLandmark {
            #[inline]
            fn clone(&self) -> OrientedLandmark {
                OrientedLandmark {
                    id: ::core::clone::Clone::clone(&self.id),
                    pose: ::core::clone::Clone::clone(&self.pose),
                }
            }
        }
        use serde::ser::{Serialize, SerializeStruct, Serializer};
        impl Serialize for OrientedLandmark {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let mut state = serializer.serialize_struct("OrientedLandmark", 4)?;
                state.serialize_field("id", &self.id)?;
                state.serialize_field("x", &self.pose.x)?;
                state.serialize_field("y", &self.pose.y)?;
                state.serialize_field("theta", &self.pose.z)?;
                state.end()
            }
        }
        use serde::de::{self, Deserialize, Deserializer, MapAccess, SeqAccess, Visitor};
        impl<'de> Deserialize<'de> for OrientedLandmark {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                enum Field {
                    Id,
                    X,
                    Y,
                    Theta,
                    Unknown,
                }
                impl<'de> Deserialize<'de> for Field {
                    fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>
                    where
                        D: Deserializer<'de>,
                    {
                        struct FieldVisitor;
                        impl<'de> Visitor<'de> for FieldVisitor {
                            type Value = Field;
                            fn expecting(
                                &self,
                                formatter: &mut fmt::Formatter,
                            ) -> fmt::Result {
                                formatter.write_str("`id` or `x` or `y` or `theta`")
                            }
                            fn visit_str<E>(self, value: &str) -> Result<Field, E>
                            where
                                E: de::Error,
                            {
                                match value {
                                    "id" => Ok(Field::Id),
                                    "x" => Ok(Field::X),
                                    "y" => Ok(Field::Y),
                                    "theta" => Ok(Field::Theta),
                                    _ => Ok(Field::Unknown),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(FieldVisitor)
                    }
                }
                struct OrientedLandmarkVisitor;
                impl<'de> Visitor<'de> for OrientedLandmarkVisitor {
                    type Value = OrientedLandmark;
                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter.write_str("struct OrientedLandmark")
                    }
                    fn visit_seq<V>(
                        self,
                        mut seq: V,
                    ) -> Result<OrientedLandmark, V::Error>
                    where
                        V: SeqAccess<'de>,
                    {
                        let id: i32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(0, &self))?;
                        let x: f32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(1, &self))?;
                        let y: f32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(2, &self))?;
                        let theta: f32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(3, &self))?;
                        Ok(OrientedLandmark {
                            id: id,
                            pose: Vector3::from_vec(
                                <[_]>::into_vec(::alloc::boxed::box_new([x, y, theta])),
                            ),
                        })
                    }
                    fn visit_map<V>(
                        self,
                        mut map: V,
                    ) -> Result<OrientedLandmark, V::Error>
                    where
                        V: MapAccess<'de>,
                    {
                        let mut id = None;
                        let mut x = None;
                        let mut y = None;
                        let mut theta = None;
                        while let Some(key) = map.next_key()? {
                            match key {
                                Field::Id => {
                                    if id.is_some() {
                                        return Err(de::Error::duplicate_field("id"));
                                    }
                                    id = Some(map.next_value()?);
                                }
                                Field::X => {
                                    if x.is_some() {
                                        return Err(de::Error::duplicate_field("x"));
                                    }
                                    x = Some(map.next_value()?);
                                }
                                Field::Y => {
                                    if y.is_some() {
                                        return Err(de::Error::duplicate_field("y"));
                                    }
                                    y = Some(map.next_value()?);
                                }
                                Field::Theta => {
                                    if theta.is_some() {
                                        return Err(de::Error::duplicate_field("theta"));
                                    }
                                    theta = Some(map.next_value()?);
                                }
                                Field::Unknown => {}
                            }
                        }
                        let id = id.ok_or_else(|| de::Error::missing_field("id"))?;
                        let x = x.ok_or_else(|| de::Error::missing_field("x"))?;
                        let y = y.ok_or_else(|| de::Error::missing_field("y"))?;
                        let theta = theta
                            .ok_or_else(|| de::Error::missing_field("theta"))?;
                        Ok(OrientedLandmark {
                            id: id,
                            pose: Vector3::from_vec(
                                <[_]>::into_vec(::alloc::boxed::box_new([x, y, theta])),
                            ),
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["id", "x", "y", "theta"];
                deserializer
                    .deserialize_struct(
                        "OrientedLandmark",
                        FIELDS,
                        OrientedLandmarkVisitor,
                    )
            }
        }
        /// Observation of an [`OrientedLandmark`].
        pub struct OrientedLandmarkObservation {
            /// Id of the landmark
            pub id: i32,
            /// Pose of the landmark
            pub pose: Vector3<f32>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedLandmarkObservation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OrientedLandmarkObservation",
                    "id",
                    &self.id,
                    "pose",
                    &&self.pose,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for OrientedLandmarkObservation {
            #[inline]
            fn default() -> OrientedLandmarkObservation {
                OrientedLandmarkObservation {
                    id: ::core::default::Default::default(),
                    pose: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedLandmarkObservation {
            #[inline]
            fn clone(&self) -> OrientedLandmarkObservation {
                OrientedLandmarkObservation {
                    id: ::core::clone::Clone::clone(&self.id),
                    pose: ::core::clone::Clone::clone(&self.pose),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OrientedLandmarkObservation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OrientedLandmarkObservation",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pose",
                        &self.pose,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OrientedLandmarkObservation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            OrientedLandmarkObservation,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OrientedLandmarkObservation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OrientedLandmarkObservation",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OrientedLandmarkObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vector3<f32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OrientedLandmarkObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OrientedLandmarkObservation {
                                id: __field0,
                                pose: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vector3<f32>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pose"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vector3<f32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pose")?
                                }
                            };
                            _serde::__private::Ok(OrientedLandmarkObservation {
                                id: __field0,
                                pose: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["id", "pose"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OrientedLandmarkObservation",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OrientedLandmarkObservation,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Stateful<OrientedLandmarkObservationRecord>
        for OrientedLandmarkObservation {
            fn record(&self) -> OrientedLandmarkObservationRecord {
                OrientedLandmarkObservationRecord {
                    id: self.id,
                    pose: self.pose.into(),
                }
            }
            fn from_record(&mut self, record: OrientedLandmarkObservationRecord) {
                self.id = record.id;
                self.pose = Vector3::from_vec(record.pose.to_vec());
            }
        }
        pub struct OrientedLandmarkObservationRecord {
            /// Id of the landmark
            pub id: i32,
            /// Pose of the landmark
            pub pose: [f32; 3],
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OrientedLandmarkObservationRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OrientedLandmarkObservationRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pose",
                        &self.pose,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OrientedLandmarkObservationRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            OrientedLandmarkObservationRecord,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OrientedLandmarkObservationRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OrientedLandmarkObservationRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OrientedLandmarkObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                [f32; 3],
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OrientedLandmarkObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OrientedLandmarkObservationRecord {
                                id: __field0,
                                pose: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<[f32; 3]> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pose"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<[f32; 3]>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pose")?
                                }
                            };
                            _serde::__private::Ok(OrientedLandmarkObservationRecord {
                                id: __field0,
                                pose: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["id", "pose"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OrientedLandmarkObservationRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OrientedLandmarkObservationRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedLandmarkObservationRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OrientedLandmarkObservationRecord",
                    "id",
                    &self.id,
                    "pose",
                    &&self.pose,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedLandmarkObservationRecord {
            #[inline]
            fn clone(&self) -> OrientedLandmarkObservationRecord {
                let _: ::core::clone::AssertParamIsClone<i32>;
                let _: ::core::clone::AssertParamIsClone<[f32; 3]>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for OrientedLandmarkObservationRecord {}
        /// Map, containing multiple [`OrientedLandmark`], used for the map file.
        pub struct Map {
            pub landmarks: Vec<OrientedLandmark>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Map {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Map",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "landmarks",
                        &self.landmarks,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Map {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "landmarks" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"landmarks" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Map>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Map;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Map",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<OrientedLandmark>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Map with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Map { landmarks: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<OrientedLandmark>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "landmarks",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<OrientedLandmark>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("landmarks")?
                                }
                            };
                            _serde::__private::Ok(Map { landmarks: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["landmarks"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Map",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Map>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for Map {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Map",
                    "landmarks",
                    &&self.landmarks,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Map {
            #[inline]
            fn default() -> Map {
                Map {
                    landmarks: ::core::default::Default::default(),
                }
            }
        }
        /// Sensor which observe the map landmarks.
        pub struct OrientedLandmarkSensor {
            /// Detection distance
            detection_distance: f32,
            /// Landmarks list.
            landmarks: Vec<OrientedLandmark>,
            /// Observation period
            period: f32,
            /// Last observation time.
            last_time: f32,
            faults: Arc<Mutex<Vec<Box<dyn FaultModel>>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedLandmarkSensor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "OrientedLandmarkSensor",
                    "detection_distance",
                    &self.detection_distance,
                    "landmarks",
                    &self.landmarks,
                    "period",
                    &self.period,
                    "last_time",
                    &self.last_time,
                    "faults",
                    &&self.faults,
                )
            }
        }
        impl OrientedLandmarkSensor {
            /// Makes a new [`OrientedLandmarkSensor`].
            pub fn new() -> Self {
                OrientedLandmarkSensor::from_config(
                    &OrientedLandmarkSensorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &"NoName".to_string(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Makes a new [`OrientedLandmarkSensor`] from the given config.
            ///
            /// The map path is relative to the config path of the simulator.
            pub fn from_config(
                config: &OrientedLandmarkSensorConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                robot_name: &String,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                let mut path = Path::new(&config.map_path);
                let fault_models = Arc::new(Mutex::new(Vec::new()));
                let mut unlock_fault_model = fault_models.lock().unwrap();
                for fault_config in &config.faults {
                    unlock_fault_model
                        .push(
                            make_fault_model_from_config(
                                fault_config,
                                global_config,
                                robot_name,
                                va_factory,
                            ),
                        );
                }
                drop(unlock_fault_model);
                let mut sensor = Self {
                    detection_distance: config.detection_distance,
                    landmarks: Vec::new(),
                    period: config.period,
                    last_time: 0.,
                    faults: fault_models,
                };
                if config.map_path == "" {
                    return sensor;
                }
                let joined_path = global_config.base_path.join(&config.map_path);
                if path.is_relative() {
                    path = joined_path.as_path();
                }
                sensor.landmarks = Self::load_map_from_path(&path);
                sensor
            }
            /// Load the map from the given `path`.
            pub fn load_map_from_path(path: &Path) -> Vec<OrientedLandmark> {
                let map: Map = match confy::load_path(&path) {
                    Ok(config) => config,
                    Err(error) => {
                        {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Error from Confy while loading the map file {0} : {1}",
                                            path.display(),
                                            error,
                                        ),
                                        lvl,
                                        &(
                                            "simba::sensors::oriented_landmark_sensor",
                                            "simba::sensors::oriented_landmark_sensor",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        return Vec::new();
                    }
                };
                map.landmarks
            }
        }
        use crate::node::Node;
        impl Sensor for OrientedLandmarkSensor {
            fn init(&mut self, _robot: &mut Node) {}
            fn get_observations(
                &mut self,
                robot: &mut Node,
                time: f32,
            ) -> Vec<SensorObservation> {
                let mut observation_list = Vec::<SensorObservation>::new();
                if (time - self.next_time_step()).abs() > TIME_ROUND / 2. {
                    return observation_list;
                }
                let state = if let Some(arc_physic) = robot.physics() {
                    let physic = arc_physic.read().unwrap();
                    physic.state(time).clone()
                } else {
                    State::new()
                };
                let rotation_matrix = nalgebra::geometry::Rotation3::from_euler_angles(
                    0.,
                    0.,
                    state.pose.z,
                );
                for landmark in &self.landmarks {
                    let d = ((landmark.pose.x - state.pose.x).powi(2)
                        + (landmark.pose.y - state.pose.y).powi(2))
                        .sqrt();
                    if d <= self.detection_distance {
                        let landmark_seed = 1. / (100. * self.period)
                            * (landmark.id as f32);
                        observation_list
                            .push(
                                SensorObservation::OrientedLandmark(OrientedLandmarkObservation {
                                    id: landmark.id,
                                    pose: rotation_matrix.transpose()
                                        * (landmark.pose - state.pose),
                                }),
                            );
                        for fault_model in self.faults.lock().unwrap().iter() {
                            fault_model
                                .add_faults(
                                    time + landmark_seed,
                                    self.period,
                                    &mut observation_list,
                                    SensorObservation::OrientedLandmark(
                                        OrientedLandmarkObservation::default(),
                                    ),
                                );
                        }
                    }
                }
                self.last_time = time;
                observation_list
            }
            /// Get the next observation time.
            fn next_time_step(&self) -> f32 {
                round_precision(self.last_time + self.period, TIME_ROUND).unwrap()
            }
            /// Get the observation period.
            fn period(&self) -> f32 {
                self.period
            }
        }
        impl Stateful<SensorRecord> for OrientedLandmarkSensor {
            fn record(&self) -> SensorRecord {
                SensorRecord::OrientedLandmarkSensor(OrientedLandmarkSensorRecord {
                    last_time: self.last_time,
                })
            }
            fn from_record(&mut self, record: SensorRecord) {
                if let SensorRecord::OrientedLandmarkSensor(oriented_landmark_record) = record {
                    self.last_time = oriented_landmark_record.last_time;
                }
            }
        }
    }
    pub mod robot_sensor {
        /*!
Provides a [`Sensor`] which can observe the other nodes in the frame of the ego node.
*/
        use super::fault_models::fault_model::{FaultModel, FaultModelConfig};
        use super::sensor::{Sensor, SensorObservation, SensorRecord};
        use crate::constants::TIME_ROUND;
        use crate::logger::is_enabled;
        use crate::networking::network::MessageFlag;
        use crate::networking::service::ServiceClient;
        use crate::networking::service_manager;
        use crate::physics::physic::{GetRealStateReq, GetRealStateResp};
        use crate::plugin_api::PluginAPI;
        use crate::sensors::fault_models::fault_model::make_fault_model_from_config;
        use crate::simulator::SimulatorConfig;
        use crate::state_estimators::state_estimator::State;
        use crate::stateful::Stateful;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::utils::maths::round_precision;
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        use log::debug;
        extern crate nalgebra as na;
        use na::Vector3;
        use std::collections::BTreeMap;
        use std::fmt;
        use std::sync::{Arc, Mutex, RwLock};
        /// Configuration of the [`RobotSensor`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct RobotSensorConfig {
            /// Max distance of detection.
            #[check[ge(0.)]]
            pub detection_distance: f32,
            /// Observation period of the sensor.
            #[check[ge(0.)]]
            pub period: f32,
            #[check]
            pub faults: Vec<FaultModelConfig>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RobotSensorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RobotSensorConfig",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "detection_distance",
                        &self.detection_distance,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "period",
                        &self.period,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "faults",
                        &self.faults,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RobotSensorConfig
            where
                RobotSensorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "detection_distance" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "period" => _serde::__private::Ok(__Field::__field1),
                                "faults" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"detection_distance" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"period" => _serde::__private::Ok(__Field::__field1),
                                b"faults" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        RobotSensorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<RobotSensorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        RobotSensorConfig: _serde::__private::Default,
                    {
                        type Value = RobotSensorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RobotSensorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.detection_distance,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.period,
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<FaultModelConfig>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(RobotSensorConfig {
                                detection_distance: __field0,
                                period: __field1,
                                faults: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Vec<FaultModelConfig>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "detection_distance",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("period"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("faults"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<FaultModelConfig>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.detection_distance,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.period,
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => __default.faults,
                            };
                            _serde::__private::Ok(RobotSensorConfig {
                                detection_distance: __field0,
                                period: __field1,
                                faults: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "detection_distance",
                        "period",
                        "faults",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RobotSensorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RobotSensorConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for RobotSensorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "RobotSensorConfig",
                    "detection_distance",
                    &self.detection_distance,
                    "period",
                    &self.period,
                    "faults",
                    &&self.faults,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RobotSensorConfig {
            #[inline]
            fn clone(&self) -> RobotSensorConfig {
                RobotSensorConfig {
                    detection_distance: ::core::clone::Clone::clone(
                        &self.detection_distance,
                    ),
                    period: ::core::clone::Clone::clone(&self.period),
                    faults: ::core::clone::Clone::clone(&self.faults),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for RobotSensorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.detection_distance >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "detection_distance",
                                "RobotSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !(self.period >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "period",
                                "RobotSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                if !::config_checker::__check_config(&self.faults, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "faults",
                                "RobotSensorConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for RobotSensorConfig {
            fn default() -> Self {
                Self {
                    detection_distance: 5.0,
                    period: 0.1,
                    faults: Vec::new(),
                }
            }
        }
        /// Record of the [`RobotSensor`], which contains nothing for now.
        pub struct RobotSensorRecord {
            last_time: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RobotSensorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RobotSensorRecord",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_time",
                        &self.last_time,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RobotSensorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "last_time" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"last_time" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RobotSensorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RobotSensorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RobotSensorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RobotSensorRecord with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RobotSensorRecord {
                                last_time: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_time",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_time")?
                                }
                            };
                            _serde::__private::Ok(RobotSensorRecord {
                                last_time: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["last_time"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RobotSensorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RobotSensorRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for RobotSensorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RobotSensorRecord",
                    "last_time",
                    &&self.last_time,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RobotSensorRecord {
            #[inline]
            fn clone(&self) -> RobotSensorRecord {
                RobotSensorRecord {
                    last_time: ::core::clone::Clone::clone(&self.last_time),
                }
            }
        }
        impl Default for RobotSensorRecord {
            fn default() -> Self {
                Self { last_time: 0. }
            }
        }
        /// Landmark struct, with an `id` and a `pose`, used to read the map file.
        pub struct OrientedRobot {
            pub name: String,
            pub pose: Vector3<f32>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedRobot {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OrientedRobot",
                    "name",
                    &self.name,
                    "pose",
                    &&self.pose,
                )
            }
        }
        use serde::ser::{Serialize, SerializeStruct, Serializer};
        impl Serialize for OrientedRobot {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let mut state = serializer.serialize_struct("OrientedRobot", 4)?;
                state.serialize_field("name", self.name.as_str())?;
                state.serialize_field("x", &self.pose.x)?;
                state.serialize_field("y", &self.pose.y)?;
                state.serialize_field("theta", &self.pose.z)?;
                state.end()
            }
        }
        use serde::de::{self, Deserialize, Deserializer, MapAccess, SeqAccess, Visitor};
        impl<'de> Deserialize<'de> for OrientedRobot {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                enum Field {
                    Name,
                    X,
                    Y,
                    Theta,
                    Unknown,
                }
                impl<'de> Deserialize<'de> for Field {
                    fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>
                    where
                        D: Deserializer<'de>,
                    {
                        struct FieldVisitor;
                        impl<'de> Visitor<'de> for FieldVisitor {
                            type Value = Field;
                            fn expecting(
                                &self,
                                formatter: &mut fmt::Formatter,
                            ) -> fmt::Result {
                                formatter.write_str("`name` or `x` or `y` or `theta`")
                            }
                            fn visit_str<E>(self, value: &str) -> Result<Field, E>
                            where
                                E: de::Error,
                            {
                                match value {
                                    "name" => Ok(Field::Name),
                                    "x" => Ok(Field::X),
                                    "y" => Ok(Field::Y),
                                    "theta" => Ok(Field::Theta),
                                    _ => Ok(Field::Unknown),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(FieldVisitor)
                    }
                }
                struct OrientedRobotVisitor;
                impl<'de> Visitor<'de> for OrientedRobotVisitor {
                    type Value = OrientedRobot;
                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter.write_str("struct OrientedRobot")
                    }
                    fn visit_seq<V>(self, mut seq: V) -> Result<OrientedRobot, V::Error>
                    where
                        V: SeqAccess<'de>,
                    {
                        let name: &str = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(0, &self))?;
                        let x: f32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(1, &self))?;
                        let y: f32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(2, &self))?;
                        let theta: f32 = seq
                            .next_element()?
                            .ok_or_else(|| de::Error::invalid_length(3, &self))?;
                        Ok(OrientedRobot {
                            name: name.to_string(),
                            pose: Vector3::from_vec(
                                <[_]>::into_vec(::alloc::boxed::box_new([x, y, theta])),
                            ),
                        })
                    }
                    fn visit_map<V>(self, mut map: V) -> Result<OrientedRobot, V::Error>
                    where
                        V: MapAccess<'de>,
                    {
                        let mut name = None;
                        let mut x = None;
                        let mut y = None;
                        let mut theta = None;
                        while let Some(key) = map.next_key()? {
                            match key {
                                Field::Name => {
                                    if name.is_some() {
                                        return Err(de::Error::duplicate_field("name"));
                                    }
                                    name = Some(map.next_value()?);
                                }
                                Field::X => {
                                    if x.is_some() {
                                        return Err(de::Error::duplicate_field("x"));
                                    }
                                    x = Some(map.next_value()?);
                                }
                                Field::Y => {
                                    if y.is_some() {
                                        return Err(de::Error::duplicate_field("y"));
                                    }
                                    y = Some(map.next_value()?);
                                }
                                Field::Theta => {
                                    if theta.is_some() {
                                        return Err(de::Error::duplicate_field("theta"));
                                    }
                                    theta = Some(map.next_value()?);
                                }
                                Field::Unknown => {}
                            }
                        }
                        let name = name.ok_or_else(|| de::Error::missing_field("name"))?;
                        let x = x.ok_or_else(|| de::Error::missing_field("x"))?;
                        let y = y.ok_or_else(|| de::Error::missing_field("y"))?;
                        let theta = theta
                            .ok_or_else(|| de::Error::missing_field("theta"))?;
                        Ok(OrientedRobot {
                            name,
                            pose: Vector3::from_vec(
                                <[_]>::into_vec(::alloc::boxed::box_new([x, y, theta])),
                            ),
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name", "x", "y", "theta"];
                deserializer
                    .deserialize_struct("OrientedRobot", FIELDS, OrientedRobotVisitor)
            }
        }
        /// Observation of an [`OrientedRobot`].
        pub struct OrientedRobotObservation {
            /// Name of the Robot
            pub name: String,
            /// Pose of the Robot
            pub pose: Vector3<f32>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedRobotObservation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OrientedRobotObservation",
                    "name",
                    &self.name,
                    "pose",
                    &&self.pose,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for OrientedRobotObservation {
            #[inline]
            fn default() -> OrientedRobotObservation {
                OrientedRobotObservation {
                    name: ::core::default::Default::default(),
                    pose: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedRobotObservation {
            #[inline]
            fn clone(&self) -> OrientedRobotObservation {
                OrientedRobotObservation {
                    name: ::core::clone::Clone::clone(&self.name),
                    pose: ::core::clone::Clone::clone(&self.pose),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OrientedRobotObservation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OrientedRobotObservation",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pose",
                        &self.pose,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OrientedRobotObservation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<OrientedRobotObservation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OrientedRobotObservation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OrientedRobotObservation",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OrientedRobotObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vector3<f32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OrientedRobotObservation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OrientedRobotObservation {
                                name: __field0,
                                pose: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vector3<f32>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pose"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vector3<f32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pose")?
                                }
                            };
                            _serde::__private::Ok(OrientedRobotObservation {
                                name: __field0,
                                pose: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name", "pose"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OrientedRobotObservation",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OrientedRobotObservation,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Stateful<OrientedRobotObservationRecord> for OrientedRobotObservation {
            fn record(&self) -> OrientedRobotObservationRecord {
                OrientedRobotObservationRecord {
                    name: self.name.clone(),
                    pose: self.pose.to_owned().into(),
                }
            }
            fn from_record(&mut self, record: OrientedRobotObservationRecord) {
                self.name = record.name;
                self.pose = Vector3::from(record.pose);
            }
        }
        pub struct OrientedRobotObservationRecord {
            /// Name of the Robot
            pub name: String,
            /// Pose of the Robot
            pub pose: [f32; 3],
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OrientedRobotObservationRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "OrientedRobotObservationRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pose",
                        &self.pose,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OrientedRobotObservationRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"pose" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            OrientedRobotObservationRecord,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OrientedRobotObservationRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct OrientedRobotObservationRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct OrientedRobotObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                [f32; 3],
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct OrientedRobotObservationRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(OrientedRobotObservationRecord {
                                name: __field0,
                                pose: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<[f32; 3]> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pose"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<[f32; 3]>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pose")?
                                }
                            };
                            _serde::__private::Ok(OrientedRobotObservationRecord {
                                name: __field0,
                                pose: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name", "pose"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OrientedRobotObservationRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OrientedRobotObservationRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OrientedRobotObservationRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OrientedRobotObservationRecord",
                    "name",
                    &self.name,
                    "pose",
                    &&self.pose,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OrientedRobotObservationRecord {
            #[inline]
            fn clone(&self) -> OrientedRobotObservationRecord {
                OrientedRobotObservationRecord {
                    name: ::core::clone::Clone::clone(&self.name),
                    pose: ::core::clone::Clone::clone(&self.pose),
                }
            }
        }
        /// Sensor which observe the other Robots.
        pub struct RobotSensor {
            /// Detection distance
            detection_distance: f32,
            /// Observation period
            period: f32,
            /// Last observation time.
            last_time: f32,
            faults: Arc<Mutex<Vec<Box<dyn FaultModel>>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RobotSensor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "RobotSensor",
                    "detection_distance",
                    &self.detection_distance,
                    "period",
                    &self.period,
                    "last_time",
                    &self.last_time,
                    "faults",
                    &&self.faults,
                )
            }
        }
        impl RobotSensor {
            /// Makes a new [`RobotSensor`].
            pub fn new() -> Self {
                RobotSensor::from_config(
                    &RobotSensorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &"NoName".to_string(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Makes a new [`RobotSensor`] from the given config.
            ///
            /// The map path is relative to the config path of the simulator.
            pub fn from_config(
                config: &RobotSensorConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                node_name: &String,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                if !(config.period != 0.) {
                    ::core::panicking::panic("assertion failed: config.period != 0.")
                }
                let fault_models = Arc::new(Mutex::new(Vec::new()));
                let mut unlock_fault_model = fault_models.lock().unwrap();
                for fault_config in &config.faults {
                    unlock_fault_model
                        .push(
                            make_fault_model_from_config(
                                fault_config,
                                global_config,
                                node_name,
                                va_factory,
                            ),
                        );
                }
                drop(unlock_fault_model);
                Self {
                    detection_distance: config.detection_distance,
                    period: config.period,
                    last_time: 0.,
                    faults: fault_models,
                }
            }
        }
        use crate::node::Node;
        impl Sensor for RobotSensor {
            fn init(&mut self, _node: &mut Node) {}
            fn get_observations(
                &mut self,
                node: &mut Node,
                time: f32,
            ) -> Vec<SensorObservation> {
                let mut observation_list = Vec::<SensorObservation>::new();
                if (time - self.next_time_step()).abs() > TIME_ROUND / 2. {
                    return observation_list;
                }
                if is_enabled(crate::logger::InternalLog::SensorManagerDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Start looking for nodes"),
                                    lvl,
                                    &(
                                        "simba::sensors::robot_sensor",
                                        "simba::sensors::robot_sensor",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let state = if let Some(arc_physic) = node.physics() {
                    let physic = arc_physic.read().unwrap();
                    physic.state(time).clone()
                } else {
                    State::new()
                };
                let rotation_matrix = nalgebra::geometry::Rotation3::from_euler_angles(
                    0.,
                    0.,
                    state.pose.z,
                );
                if is_enabled(crate::logger::InternalLog::SensorManagerDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Rotation matrix: {0}", rotation_matrix),
                                    lvl,
                                    &(
                                        "simba::sensors::robot_sensor",
                                        "simba::sensors::robot_sensor",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                for other_node_name in node.other_node_names.iter() {
                    if is_enabled(crate::logger::InternalLog::SensorManagerDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Sensing node {0}", other_node_name),
                                        lvl,
                                        &(
                                            "simba::sensors::robot_sensor",
                                            "simba::sensors::robot_sensor",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    if !(*other_node_name != node.name()) {
                        ::core::panicking::panic(
                            "assertion failed: *other_node_name != node.name()",
                        )
                    }
                    let service_manager = node.service_manager();
                    if let Some(other_state) = service_manager
                        .read()
                        .unwrap()
                        .get_real_state(&other_node_name.to_string(), node, time)
                    {
                        let d = ((other_state.pose.x - state.pose.x).powi(2)
                            + (other_state.pose.y - state.pose.y).powi(2))
                            .sqrt();
                        if is_enabled(
                            crate::logger::InternalLog::SensorManagerDetailed,
                        ) {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Distance is {0}", d),
                                            lvl,
                                            &(
                                                "simba::sensors::robot_sensor",
                                                "simba::sensors::robot_sensor",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                        if d <= self.detection_distance {
                            observation_list
                                .push(
                                    SensorObservation::OrientedRobot(OrientedRobotObservation {
                                        name: other_node_name.clone(),
                                        pose: rotation_matrix.transpose()
                                            * (other_state.pose - state.pose),
                                    }),
                                );
                        }
                    }
                }
                for fault_model in self.faults.lock().unwrap().iter() {
                    fault_model
                        .add_faults(
                            time,
                            self.period,
                            &mut observation_list,
                            SensorObservation::OrientedRobot(
                                OrientedRobotObservation::default(),
                            ),
                        );
                }
                self.last_time = time;
                observation_list
            }
            /// Get the next observation time.
            fn next_time_step(&self) -> f32 {
                round_precision(self.last_time + self.period, TIME_ROUND).unwrap()
            }
            /// Get the observation period.
            fn period(&self) -> f32 {
                self.period
            }
        }
        impl Stateful<SensorRecord> for RobotSensor {
            fn record(&self) -> SensorRecord {
                SensorRecord::RobotSensor(RobotSensorRecord {
                    last_time: self.last_time,
                })
            }
            fn from_record(&mut self, record: SensorRecord) {
                if let SensorRecord::RobotSensor(node_sensor_record) = record {
                    self.last_time = node_sensor_record.last_time;
                }
            }
        }
    }
    pub mod sensor {
        /*!
Provides the [`Sensor`] trait, which is the interface for all the sensors.
*/
        extern crate confy;
        use std::sync::{Arc, RwLock};
        use config_checker::macros::Check;
        use serde_derive::{Deserialize, Serialize};
        use super::{
            gnss_sensor::{self, GNSSObservation, GNSSObservationRecord},
            odometry_sensor::{self, OdometryObservation, OdometryObservationRecord},
            oriented_landmark_sensor::{
                self, OrientedLandmarkObservation, OrientedLandmarkObservationRecord,
            },
            robot_sensor::{
                self, OrientedRobotObservation, OrientedRobotObservationRecord,
            },
        };
        pub struct Observation {
            pub sensor_name: String,
            pub observer: String,
            pub time: f32,
            pub sensor_observation: SensorObservation,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Observation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Observation",
                    "sensor_name",
                    &self.sensor_name,
                    "observer",
                    &self.observer,
                    "time",
                    &self.time,
                    "sensor_observation",
                    &&self.sensor_observation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Observation {
            #[inline]
            fn clone(&self) -> Observation {
                Observation {
                    sensor_name: ::core::clone::Clone::clone(&self.sensor_name),
                    observer: ::core::clone::Clone::clone(&self.observer),
                    time: ::core::clone::Clone::clone(&self.time),
                    sensor_observation: ::core::clone::Clone::clone(
                        &self.sensor_observation,
                    ),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Observation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Observation",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sensor_name",
                        &self.sensor_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "observer",
                        &self.observer,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "time",
                        &self.time,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sensor_observation",
                        &self.sensor_observation,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Observation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sensor_name" => _serde::__private::Ok(__Field::__field0),
                                "observer" => _serde::__private::Ok(__Field::__field1),
                                "time" => _serde::__private::Ok(__Field::__field2),
                                "sensor_observation" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sensor_name" => _serde::__private::Ok(__Field::__field0),
                                b"observer" => _serde::__private::Ok(__Field::__field1),
                                b"time" => _serde::__private::Ok(__Field::__field2),
                                b"sensor_observation" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Observation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Observation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Observation",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Observation with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Observation with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Observation with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SensorObservation,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Observation with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Observation {
                                sensor_name: __field0,
                                observer: __field1,
                                time: __field2,
                                sensor_observation: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SensorObservation,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sensor_name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "observer",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("time"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sensor_observation",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SensorObservation,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sensor_name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("observer")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("time")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sensor_observation")?
                                }
                            };
                            _serde::__private::Ok(Observation {
                                sensor_name: __field0,
                                observer: __field1,
                                time: __field2,
                                sensor_observation: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "sensor_name",
                        "observer",
                        "time",
                        "sensor_observation",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Observation",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Observation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Observation {
            pub fn new() -> Self {
                Self {
                    sensor_name: "sensor".to_string(),
                    observer: "someone".to_string(),
                    time: 0.,
                    sensor_observation: SensorObservation::Odometry(
                        OdometryObservation::default(),
                    ),
                }
            }
        }
        impl Stateful<ObservationRecord> for Observation {
            fn from_record(&mut self, record: ObservationRecord) {
                self.observer = record.observer;
                self.sensor_name = record.sensor_name;
                self.time = record.time;
                self.sensor_observation.from_record(record.sensor_observation);
            }
            fn record(&self) -> ObservationRecord {
                ObservationRecord {
                    sensor_name: self.sensor_name.clone(),
                    observer: self.observer.clone(),
                    time: self.time,
                    sensor_observation: self.sensor_observation.record(),
                }
            }
        }
        pub struct ObservationRecord {
            pub sensor_name: String,
            pub observer: String,
            pub time: f32,
            pub sensor_observation: SensorObservationRecord,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ObservationRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ObservationRecord",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sensor_name",
                        &self.sensor_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "observer",
                        &self.observer,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "time",
                        &self.time,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sensor_observation",
                        &self.sensor_observation,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ObservationRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sensor_name" => _serde::__private::Ok(__Field::__field0),
                                "observer" => _serde::__private::Ok(__Field::__field1),
                                "time" => _serde::__private::Ok(__Field::__field2),
                                "sensor_observation" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sensor_name" => _serde::__private::Ok(__Field::__field0),
                                b"observer" => _serde::__private::Ok(__Field::__field1),
                                b"time" => _serde::__private::Ok(__Field::__field2),
                                b"sensor_observation" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ObservationRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ObservationRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ObservationRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ObservationRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ObservationRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ObservationRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SensorObservationRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ObservationRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ObservationRecord {
                                sensor_name: __field0,
                                observer: __field1,
                                time: __field2,
                                sensor_observation: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SensorObservationRecord,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sensor_name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "observer",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("time"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sensor_observation",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SensorObservationRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sensor_name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("observer")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("time")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sensor_observation")?
                                }
                            };
                            _serde::__private::Ok(ObservationRecord {
                                sensor_name: __field0,
                                observer: __field1,
                                time: __field2,
                                sensor_observation: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "sensor_name",
                        "observer",
                        "time",
                        "sensor_observation",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ObservationRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ObservationRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ObservationRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ObservationRecord",
                    "sensor_name",
                    &self.sensor_name,
                    "observer",
                    &self.observer,
                    "time",
                    &self.time,
                    "sensor_observation",
                    &&self.sensor_observation,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ObservationRecord {
            #[inline]
            fn clone(&self) -> ObservationRecord {
                ObservationRecord {
                    sensor_name: ::core::clone::Clone::clone(&self.sensor_name),
                    observer: ::core::clone::Clone::clone(&self.observer),
                    time: ::core::clone::Clone::clone(&self.time),
                    sensor_observation: ::core::clone::Clone::clone(
                        &self.sensor_observation,
                    ),
                }
            }
        }
        pub enum SensorObservation {
            OrientedLandmark(OrientedLandmarkObservation),
            Odometry(OdometryObservation),
            GNSS(GNSSObservation),
            OrientedRobot(OrientedRobotObservation),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorObservation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SensorObservation::OrientedLandmark(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OrientedLandmark",
                            &__self_0,
                        )
                    }
                    SensorObservation::Odometry(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Odometry",
                            &__self_0,
                        )
                    }
                    SensorObservation::GNSS(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "GNSS",
                            &__self_0,
                        )
                    }
                    SensorObservation::OrientedRobot(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OrientedRobot",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SensorObservation {
            #[inline]
            fn clone(&self) -> SensorObservation {
                match self {
                    SensorObservation::OrientedLandmark(__self_0) => {
                        SensorObservation::OrientedLandmark(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorObservation::Odometry(__self_0) => {
                        SensorObservation::Odometry(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorObservation::GNSS(__self_0) => {
                        SensorObservation::GNSS(::core::clone::Clone::clone(__self_0))
                    }
                    SensorObservation::OrientedRobot(__self_0) => {
                        SensorObservation::OrientedRobot(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SensorObservation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SensorObservation::OrientedLandmark(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservation",
                                0u32,
                                "OrientedLandmark",
                                __field0,
                            )
                        }
                        SensorObservation::Odometry(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservation",
                                1u32,
                                "Odometry",
                                __field0,
                            )
                        }
                        SensorObservation::GNSS(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservation",
                                2u32,
                                "GNSS",
                                __field0,
                            )
                        }
                        SensorObservation::OrientedRobot(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservation",
                                3u32,
                                "OrientedRobot",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SensorObservation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "OrientedLandmark" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "Odometry" => _serde::__private::Ok(__Field::__field1),
                                "GNSS" => _serde::__private::Ok(__Field::__field2),
                                "OrientedRobot" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"OrientedLandmark" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"Odometry" => _serde::__private::Ok(__Field::__field1),
                                b"GNSS" => _serde::__private::Ok(__Field::__field2),
                                b"OrientedRobot" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SensorObservation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SensorObservation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SensorObservation",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            OrientedLandmarkObservation,
                                        >(__variant),
                                        SensorObservation::OrientedLandmark,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            OdometryObservation,
                                        >(__variant),
                                        SensorObservation::Odometry,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            GNSSObservation,
                                        >(__variant),
                                        SensorObservation::GNSS,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            OrientedRobotObservation,
                                        >(__variant),
                                        SensorObservation::OrientedRobot,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "OrientedLandmark",
                        "Odometry",
                        "GNSS",
                        "OrientedRobot",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SensorObservation",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SensorObservation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Stateful<SensorObservationRecord> for SensorObservation {
            fn record(&self) -> SensorObservationRecord {
                match self {
                    SensorObservation::OrientedLandmark(o) => {
                        SensorObservationRecord::OrientedLandmark(o.record())
                    }
                    SensorObservation::Odometry(o) => {
                        SensorObservationRecord::Odometry(o.record())
                    }
                    SensorObservation::GNSS(o) => {
                        SensorObservationRecord::GNSS(o.record())
                    }
                    SensorObservation::OrientedRobot(o) => {
                        SensorObservationRecord::OrientedRobot(o.record())
                    }
                }
            }
            fn from_record(&mut self, record: SensorObservationRecord) {
                match record {
                    SensorObservationRecord::OrientedLandmark(o) => {
                        if let SensorObservation::OrientedLandmark(ref mut obs) = self {
                            obs.from_record(o);
                        }
                    }
                    SensorObservationRecord::Odometry(o) => {
                        if let SensorObservation::Odometry(ref mut obs) = self {
                            obs.from_record(o);
                        }
                    }
                    SensorObservationRecord::GNSS(o) => {
                        if let SensorObservation::GNSS(ref mut obs) = self {
                            obs.from_record(o);
                        }
                    }
                    SensorObservationRecord::OrientedRobot(o) => {
                        if let SensorObservation::OrientedRobot(ref mut obs) = self {
                            obs.from_record(o);
                        }
                    }
                }
            }
        }
        pub enum SensorObservationRecord {
            OrientedLandmark(OrientedLandmarkObservationRecord),
            Odometry(OdometryObservationRecord),
            GNSS(GNSSObservationRecord),
            OrientedRobot(OrientedRobotObservationRecord),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SensorObservationRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SensorObservationRecord::OrientedLandmark(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservationRecord",
                                0u32,
                                "OrientedLandmark",
                                __field0,
                            )
                        }
                        SensorObservationRecord::Odometry(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservationRecord",
                                1u32,
                                "Odometry",
                                __field0,
                            )
                        }
                        SensorObservationRecord::GNSS(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservationRecord",
                                2u32,
                                "GNSS",
                                __field0,
                            )
                        }
                        SensorObservationRecord::OrientedRobot(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorObservationRecord",
                                3u32,
                                "OrientedRobot",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SensorObservationRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "OrientedLandmark" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "Odometry" => _serde::__private::Ok(__Field::__field1),
                                "GNSS" => _serde::__private::Ok(__Field::__field2),
                                "OrientedRobot" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"OrientedLandmark" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"Odometry" => _serde::__private::Ok(__Field::__field1),
                                b"GNSS" => _serde::__private::Ok(__Field::__field2),
                                b"OrientedRobot" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SensorObservationRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SensorObservationRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SensorObservationRecord",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            OrientedLandmarkObservationRecord,
                                        >(__variant),
                                        SensorObservationRecord::OrientedLandmark,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            OdometryObservationRecord,
                                        >(__variant),
                                        SensorObservationRecord::Odometry,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            GNSSObservationRecord,
                                        >(__variant),
                                        SensorObservationRecord::GNSS,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            OrientedRobotObservationRecord,
                                        >(__variant),
                                        SensorObservationRecord::OrientedRobot,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "OrientedLandmark",
                        "Odometry",
                        "GNSS",
                        "OrientedRobot",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SensorObservationRecord",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SensorObservationRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorObservationRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SensorObservationRecord::OrientedLandmark(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OrientedLandmark",
                            &__self_0,
                        )
                    }
                    SensorObservationRecord::Odometry(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Odometry",
                            &__self_0,
                        )
                    }
                    SensorObservationRecord::GNSS(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "GNSS",
                            &__self_0,
                        )
                    }
                    SensorObservationRecord::OrientedRobot(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OrientedRobot",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SensorObservationRecord {
            #[inline]
            fn clone(&self) -> SensorObservationRecord {
                match self {
                    SensorObservationRecord::OrientedLandmark(__self_0) => {
                        SensorObservationRecord::OrientedLandmark(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorObservationRecord::Odometry(__self_0) => {
                        SensorObservationRecord::Odometry(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorObservationRecord::GNSS(__self_0) => {
                        SensorObservationRecord::GNSS(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorObservationRecord::OrientedRobot(__self_0) => {
                        SensorObservationRecord::OrientedRobot(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        /// Enumerates all the possible sensors configurations.
        #[serde(deny_unknown_fields)]
        pub enum SensorConfig {
            OrientedLandmarkSensor(
                Box<oriented_landmark_sensor::OrientedLandmarkSensorConfig>,
            ),
            OdometrySensor(odometry_sensor::OdometrySensorConfig),
            GNSSSensor(gnss_sensor::GNSSSensorConfig),
            RobotSensor(robot_sensor::RobotSensorConfig),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SensorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SensorConfig::OrientedLandmarkSensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorConfig",
                                0u32,
                                "OrientedLandmarkSensor",
                                __field0,
                            )
                        }
                        SensorConfig::OdometrySensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorConfig",
                                1u32,
                                "OdometrySensor",
                                __field0,
                            )
                        }
                        SensorConfig::GNSSSensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorConfig",
                                2u32,
                                "GNSSSensor",
                                __field0,
                            )
                        }
                        SensorConfig::RobotSensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorConfig",
                                3u32,
                                "RobotSensor",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SensorConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "OrientedLandmarkSensor" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "OdometrySensor" => _serde::__private::Ok(__Field::__field1),
                                "GNSSSensor" => _serde::__private::Ok(__Field::__field2),
                                "RobotSensor" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"OrientedLandmarkSensor" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"OdometrySensor" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"GNSSSensor" => _serde::__private::Ok(__Field::__field2),
                                b"RobotSensor" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SensorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SensorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SensorConfig",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Box<oriented_landmark_sensor::OrientedLandmarkSensorConfig>,
                                        >(__variant),
                                        SensorConfig::OrientedLandmarkSensor,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            odometry_sensor::OdometrySensorConfig,
                                        >(__variant),
                                        SensorConfig::OdometrySensor,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            gnss_sensor::GNSSSensorConfig,
                                        >(__variant),
                                        SensorConfig::GNSSSensor,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            robot_sensor::RobotSensorConfig,
                                        >(__variant),
                                        SensorConfig::RobotSensor,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "OrientedLandmarkSensor",
                        "OdometrySensor",
                        "GNSSSensor",
                        "RobotSensor",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SensorConfig",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SensorConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SensorConfig::OrientedLandmarkSensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OrientedLandmarkSensor",
                            &__self_0,
                        )
                    }
                    SensorConfig::OdometrySensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OdometrySensor",
                            &__self_0,
                        )
                    }
                    SensorConfig::GNSSSensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "GNSSSensor",
                            &__self_0,
                        )
                    }
                    SensorConfig::RobotSensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "RobotSensor",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SensorConfig {
            #[inline]
            fn clone(&self) -> SensorConfig {
                match self {
                    SensorConfig::OrientedLandmarkSensor(__self_0) => {
                        SensorConfig::OrientedLandmarkSensor(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorConfig::OdometrySensor(__self_0) => {
                        SensorConfig::OdometrySensor(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorConfig::GNSSSensor(__self_0) => {
                        SensorConfig::GNSSSensor(::core::clone::Clone::clone(__self_0))
                    }
                    SensorConfig::RobotSensor(__self_0) => {
                        SensorConfig::RobotSensor(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for SensorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                match &self {
                    SensorConfig::OrientedLandmarkSensor(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "OrientedLandmarkSensor",
                                        "SensorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    SensorConfig::OdometrySensor(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "OdometrySensor",
                                        "SensorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    SensorConfig::GNSSSensor(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "GNSSSensor",
                                        "SensorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    SensorConfig::RobotSensor(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "RobotSensor",
                                        "SensorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    _ => {}
                };
                ret
            }
        }
        /// Enumerates all the sensor records.
        pub enum SensorRecord {
            OrientedLandmarkSensor(
                oriented_landmark_sensor::OrientedLandmarkSensorRecord,
            ),
            OdometrySensor(odometry_sensor::OdometrySensorRecord),
            GNSSSensor(gnss_sensor::GNSSSensorRecord),
            RobotSensor(robot_sensor::RobotSensorRecord),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SensorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SensorRecord::OrientedLandmarkSensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorRecord",
                                0u32,
                                "OrientedLandmarkSensor",
                                __field0,
                            )
                        }
                        SensorRecord::OdometrySensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorRecord",
                                1u32,
                                "OdometrySensor",
                                __field0,
                            )
                        }
                        SensorRecord::GNSSSensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorRecord",
                                2u32,
                                "GNSSSensor",
                                __field0,
                            )
                        }
                        SensorRecord::RobotSensor(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "SensorRecord",
                                3u32,
                                "RobotSensor",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SensorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "OrientedLandmarkSensor" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "OdometrySensor" => _serde::__private::Ok(__Field::__field1),
                                "GNSSSensor" => _serde::__private::Ok(__Field::__field2),
                                "RobotSensor" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"OrientedLandmarkSensor" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"OdometrySensor" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"GNSSSensor" => _serde::__private::Ok(__Field::__field2),
                                b"RobotSensor" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SensorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SensorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SensorRecord",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            oriented_landmark_sensor::OrientedLandmarkSensorRecord,
                                        >(__variant),
                                        SensorRecord::OrientedLandmarkSensor,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            odometry_sensor::OdometrySensorRecord,
                                        >(__variant),
                                        SensorRecord::OdometrySensor,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            gnss_sensor::GNSSSensorRecord,
                                        >(__variant),
                                        SensorRecord::GNSSSensor,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            robot_sensor::RobotSensorRecord,
                                        >(__variant),
                                        SensorRecord::RobotSensor,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "OrientedLandmarkSensor",
                        "OdometrySensor",
                        "GNSSSensor",
                        "RobotSensor",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SensorRecord",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SensorRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SensorRecord::OrientedLandmarkSensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OrientedLandmarkSensor",
                            &__self_0,
                        )
                    }
                    SensorRecord::OdometrySensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OdometrySensor",
                            &__self_0,
                        )
                    }
                    SensorRecord::GNSSSensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "GNSSSensor",
                            &__self_0,
                        )
                    }
                    SensorRecord::RobotSensor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "RobotSensor",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SensorRecord {
            #[inline]
            fn clone(&self) -> SensorRecord {
                match self {
                    SensorRecord::OrientedLandmarkSensor(__self_0) => {
                        SensorRecord::OrientedLandmarkSensor(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorRecord::OdometrySensor(__self_0) => {
                        SensorRecord::OdometrySensor(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    SensorRecord::GNSSSensor(__self_0) => {
                        SensorRecord::GNSSSensor(::core::clone::Clone::clone(__self_0))
                    }
                    SensorRecord::RobotSensor(__self_0) => {
                        SensorRecord::RobotSensor(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        use crate::{node::Node, stateful::Stateful};
        /// Sensor trait which need to be implemented by each sensors.
        pub trait Sensor: std::fmt::Debug + std::marker::Send + std::marker::Sync + Stateful<
                SensorRecord,
            > {
            /// Initialize the [`Sensor`]. Should be called at the beginning of the run, after
            /// the initialization of the modules.
            fn init(&mut self, node: &mut Node);
            /// Get the observations available at the given `time`.
            ///
            /// ## Arguments
            /// * `node` - Reference to the node to access the modules.
            /// * `time` - Time at which the observations are taken.
            ///
            /// ## Return
            /// List of [`GenericObservation`]s, could be empty if no [`Sensor`] provided observation
            /// at this `time`.
            fn get_observations(
                &mut self,
                node: &mut Node,
                time: f32,
            ) -> Vec<SensorObservation>;
            /// Get the time of the next observation.
            fn next_time_step(&self) -> f32;
            /// Period of the [`Sensor`].
            fn period(&self) -> f32;
        }
    }
    pub mod sensor_manager {
        /*!
Provide the [`SensorManager`], which owns the different [`Sensor`]s and get the
available observations.
*/
        extern crate confy;
        use config_checker::macros::Check;
        use core::f32;
        use log::debug;
        use serde_derive::{Deserialize, Serialize};
        use std::collections::BTreeMap;
        use std::sync::{Arc, RwLock};
        use crate::logger::is_enabled;
        use crate::networking::message_handler::MessageHandler;
        use crate::node::Node;
        use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
        use crate::{simulator::SimulatorConfig, stateful::Stateful};
        use super::gnss_sensor::GNSSSensor;
        use super::odometry_sensor::{OdometrySensor, OdometrySensorConfig};
        use super::robot_sensor::RobotSensor;
        use super::sensor::{Observation, ObservationRecord, SensorObservationRecord};
        use super::{
            oriented_landmark_sensor::OrientedLandmarkSensor,
            sensor::{Sensor, SensorConfig, SensorObservation, SensorRecord},
        };
        use crate::plugin_api::PluginAPI;
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct ManagedSensorConfig {
            pub name: String,
            pub send_to: Vec<String>,
            pub config: SensorConfig,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ManagedSensorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ManagedSensorConfig",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "send_to",
                        &self.send_to,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "config",
                        &self.config,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ManagedSensorConfig
            where
                ManagedSensorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "send_to" => _serde::__private::Ok(__Field::__field1),
                                "config" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"send_to" => _serde::__private::Ok(__Field::__field1),
                                b"config" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        ManagedSensorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<ManagedSensorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        ManagedSensorConfig: _serde::__private::Default,
                    {
                        type Value = ManagedSensorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ManagedSensorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.name,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.send_to,
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                SensorConfig,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.config,
                            };
                            _serde::__private::Ok(ManagedSensorConfig {
                                name: __field0,
                                send_to: __field1,
                                config: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<SensorConfig> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "send_to",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("config"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SensorConfig,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.name,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.send_to,
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => __default.config,
                            };
                            _serde::__private::Ok(ManagedSensorConfig {
                                name: __field0,
                                send_to: __field1,
                                config: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "name",
                        "send_to",
                        "config",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ManagedSensorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ManagedSensorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ManagedSensorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ManagedSensorConfig",
                    "name",
                    &self.name,
                    "send_to",
                    &self.send_to,
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ManagedSensorConfig {
            #[inline]
            fn clone(&self) -> ManagedSensorConfig {
                ManagedSensorConfig {
                    name: ::core::clone::Clone::clone(&self.name),
                    send_to: ::core::clone::Clone::clone(&self.send_to),
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for ManagedSensorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                ret
            }
        }
        impl Default for ManagedSensorConfig {
            fn default() -> Self {
                Self {
                    name: "some_sensor".to_string(),
                    send_to: Vec::new(),
                    config: SensorConfig::OdometrySensor(OdometrySensorConfig::default()),
                }
            }
        }
        /// Configuration listing all the [`SensorConfig`]s.
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct SensorManagerConfig {
            #[check]
            pub sensors: Vec<ManagedSensorConfig>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SensorManagerConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SensorManagerConfig",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sensors",
                        &self.sensors,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SensorManagerConfig
            where
                SensorManagerConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sensors" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sensors" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        SensorManagerConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<SensorManagerConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        SensorManagerConfig: _serde::__private::Default,
                    {
                        type Value = SensorManagerConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SensorManagerConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<ManagedSensorConfig>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.sensors,
                            };
                            _serde::__private::Ok(SensorManagerConfig {
                                sensors: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<ManagedSensorConfig>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sensors",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ManagedSensorConfig>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.sensors,
                            };
                            _serde::__private::Ok(SensorManagerConfig {
                                sensors: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["sensors"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SensorManagerConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SensorManagerConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorManagerConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SensorManagerConfig",
                    "sensors",
                    &&self.sensors,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SensorManagerConfig {
            #[inline]
            fn clone(&self) -> SensorManagerConfig {
                SensorManagerConfig {
                    sensors: ::core::clone::Clone::clone(&self.sensors),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for SensorManagerConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !::config_checker::__check_config(&self.sensors, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "sensors",
                                "SensorManagerConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for SensorManagerConfig {
            fn default() -> Self {
                Self { sensors: Vec::new() }
            }
        }
        /// Record listing all the [`SensorRecord`]s and the next observation time.
        pub struct SensorManagerRecord {
            pub sensors: Vec<ManagedSensorRecord>,
            pub next_time: Option<f32>,
            pub last_observations: Vec<ObservationRecord>,
            pub received_observations: Vec<ObservationRecord>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SensorManagerRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SensorManagerRecord",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sensors",
                        &self.sensors,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "next_time",
                        &self.next_time,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_observations",
                        &self.last_observations,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "received_observations",
                        &self.received_observations,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SensorManagerRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sensors" => _serde::__private::Ok(__Field::__field0),
                                "next_time" => _serde::__private::Ok(__Field::__field1),
                                "last_observations" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "received_observations" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sensors" => _serde::__private::Ok(__Field::__field0),
                                b"next_time" => _serde::__private::Ok(__Field::__field1),
                                b"last_observations" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"received_observations" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SensorManagerRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SensorManagerRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SensorManagerRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<ManagedSensorRecord>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SensorManagerRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<f32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SensorManagerRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<ObservationRecord>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct SensorManagerRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<ObservationRecord>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct SensorManagerRecord with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SensorManagerRecord {
                                sensors: __field0,
                                next_time: __field1,
                                last_observations: __field2,
                                received_observations: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<ManagedSensorRecord>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<f32>> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Vec<ObservationRecord>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Vec<ObservationRecord>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sensors",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ManagedSensorRecord>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "next_time",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<f32>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_observations",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ObservationRecord>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "received_observations",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ObservationRecord>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sensors")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("next_time")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_observations")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "received_observations",
                                    )?
                                }
                            };
                            _serde::__private::Ok(SensorManagerRecord {
                                sensors: __field0,
                                next_time: __field1,
                                last_observations: __field2,
                                received_observations: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "sensors",
                        "next_time",
                        "last_observations",
                        "received_observations",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SensorManagerRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SensorManagerRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorManagerRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "SensorManagerRecord",
                    "sensors",
                    &self.sensors,
                    "next_time",
                    &self.next_time,
                    "last_observations",
                    &self.last_observations,
                    "received_observations",
                    &&self.received_observations,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SensorManagerRecord {
            #[inline]
            fn clone(&self) -> SensorManagerRecord {
                SensorManagerRecord {
                    sensors: ::core::clone::Clone::clone(&self.sensors),
                    next_time: ::core::clone::Clone::clone(&self.next_time),
                    last_observations: ::core::clone::Clone::clone(
                        &self.last_observations,
                    ),
                    received_observations: ::core::clone::Clone::clone(
                        &self.received_observations,
                    ),
                }
            }
        }
        pub struct ManagedSensorRecord {
            pub name: String,
            pub record: SensorRecord,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ManagedSensorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ManagedSensorRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "record",
                        &self.record,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ManagedSensorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "record" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"record" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ManagedSensorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ManagedSensorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ManagedSensorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ManagedSensorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SensorRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ManagedSensorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ManagedSensorRecord {
                                name: __field0,
                                record: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<SensorRecord> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("record"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SensorRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("record")?
                                }
                            };
                            _serde::__private::Ok(ManagedSensorRecord {
                                name: __field0,
                                record: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name", "record"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ManagedSensorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ManagedSensorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ManagedSensorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ManagedSensorRecord",
                    "name",
                    &self.name,
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ManagedSensorRecord {
            #[inline]
            fn clone(&self) -> ManagedSensorRecord {
                ManagedSensorRecord {
                    name: ::core::clone::Clone::clone(&self.name),
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        struct ManagedSensor {
            name: String,
            send_to: Vec<String>,
            sensor: Arc<RwLock<Box<dyn Sensor>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ManagedSensor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ManagedSensor",
                    "name",
                    &self.name,
                    "send_to",
                    &self.send_to,
                    "sensor",
                    &&self.sensor,
                )
            }
        }
        /// Sensor manager which manages all the node's [`Sensor`]s.
        pub struct SensorManager {
            sensors: Vec<ManagedSensor>,
            next_time: Option<f32>,
            last_observations: Vec<ObservationRecord>,
            received_observations: Vec<Observation>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SensorManager {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "SensorManager",
                    "sensors",
                    &self.sensors,
                    "next_time",
                    &self.next_time,
                    "last_observations",
                    &self.last_observations,
                    "received_observations",
                    &&self.received_observations,
                )
            }
        }
        impl SensorManager {
            /// Makes a new [`SensorManager`] without any [`Sensor`].
            pub fn new() -> Self {
                Self {
                    sensors: Vec::new(),
                    next_time: None,
                    last_observations: Vec::new(),
                    received_observations: Vec::new(),
                }
            }
            /// Makes a new [`SensorManager`] from the given config.
            ///
            /// ## Arguments
            /// * `config` - Config of the [`SensorManager`].
            /// * `plugin_api` - Not used yet, but will be used for external [`Sensor`]s.
            /// * `meta_config` - Simulator meta config.
            pub fn from_config(
                config: &SensorManagerConfig,
                plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                node_name: &String,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                let mut manager = Self::new();
                for sensor_config in &config.sensors {
                    manager
                        .sensors
                        .push(ManagedSensor {
                            name: sensor_config.name.clone(),
                            send_to: sensor_config.send_to.clone(),
                            sensor: Arc::new(
                                RwLock::new(
                                    match &sensor_config.config {
                                        SensorConfig::OrientedLandmarkSensor(c) => {
                                            Box::new(
                                                OrientedLandmarkSensor::from_config(
                                                    c,
                                                    plugin_api,
                                                    global_config,
                                                    node_name,
                                                    va_factory,
                                                ),
                                            ) as Box<dyn Sensor>
                                        }
                                        SensorConfig::OdometrySensor(c) => {
                                            Box::new(
                                                OdometrySensor::from_config(
                                                    c,
                                                    plugin_api,
                                                    global_config,
                                                    node_name,
                                                    va_factory,
                                                ),
                                            ) as Box<dyn Sensor>
                                        }
                                        SensorConfig::GNSSSensor(c) => {
                                            Box::new(
                                                GNSSSensor::from_config(
                                                    c,
                                                    plugin_api,
                                                    global_config,
                                                    node_name,
                                                    va_factory,
                                                ),
                                            ) as Box<dyn Sensor>
                                        }
                                        SensorConfig::RobotSensor(c) => {
                                            Box::new(
                                                RobotSensor::from_config(
                                                    c,
                                                    plugin_api,
                                                    global_config,
                                                    node_name,
                                                    va_factory,
                                                ),
                                            ) as Box<dyn Sensor>
                                        }
                                    },
                                ),
                            ),
                        });
                }
                manager.next_time = None;
                for sensor in &manager.sensors {
                    manager.next_time = Some(
                        manager
                            .next_time
                            .unwrap_or(f32::INFINITY)
                            .min(sensor.sensor.read().unwrap().next_time_step()),
                    );
                }
                manager
            }
            /// Initialize the [`Sensor`]s. Should be called at the beginning of the run, after
            /// the initialization of the modules.
            pub fn init(&mut self, node: &mut Node) {
                for sensor in &mut self.sensors {
                    sensor.sensor.write().unwrap().init(node);
                }
            }
            /// Get the observations at the given `time`.
            pub fn get_observations(
                &mut self,
                node: &mut Node,
                time: f32,
            ) -> Vec<Observation> {
                let mut observations = Vec::<Observation>::new();
                let mut min_next_time = None;
                let mut obs_to_send = BTreeMap::new();
                for sensor in &mut self.sensors {
                    let sensor_observations: Vec<Observation> = sensor
                        .sensor
                        .write()
                        .unwrap()
                        .get_observations(node, time)
                        .into_iter()
                        .map(|obs| Observation {
                            sensor_name: sensor.name.clone(),
                            observer: node.name(),
                            time,
                            sensor_observation: obs,
                        })
                        .collect();
                    if sensor_observations.len() > 0 {
                        for to in &sensor.send_to {
                            if !obs_to_send.contains_key(to) {
                                obs_to_send.insert(to, Vec::new());
                            }
                            obs_to_send
                                .get_mut(to)
                                .unwrap()
                                .extend(sensor_observations.clone());
                        }
                    }
                    observations.extend(sensor_observations);
                    min_next_time = Some(
                        min_next_time
                            .unwrap_or(f32::INFINITY)
                            .min(sensor.sensor.read().unwrap().next_time_step()),
                    );
                }
                if obs_to_send.len() > 0 {
                    for (to, observations) in obs_to_send {
                        if observations.len() > 0 {
                            let obs_serialized = serde_json::to_value(observations)
                                .unwrap();
                            node.network()
                                .expect(
                                    "This Node has no network, it cannot send observation to other nodes",
                                )
                                .write()
                                .unwrap()
                                .send_to(to.clone(), obs_serialized, time, Vec::new())
                                .unwrap();
                        }
                    }
                }
                observations.extend(self.received_observations.drain(0..));
                self.next_time = min_next_time;
                self.last_observations = observations
                    .iter()
                    .map(|obs| obs.record())
                    .collect();
                observations
            }
            /// Get the time of the next observation.
            pub fn next_time_step(&self) -> Option<f32> {
                self.next_time
            }
        }
        impl Stateful<SensorManagerRecord> for SensorManager {
            fn record(&self) -> SensorManagerRecord {
                let mut record = SensorManagerRecord {
                    next_time: self.next_time,
                    sensors: Vec::new(),
                    received_observations: self
                        .received_observations
                        .iter()
                        .map(|o| o.record())
                        .collect(),
                    last_observations: self.last_observations.clone(),
                };
                for sensor in &self.sensors {
                    record
                        .sensors
                        .push(ManagedSensorRecord {
                            name: sensor.name.clone(),
                            record: sensor.sensor.read().unwrap().record(),
                        });
                }
                record
            }
            fn from_record(&mut self, record: SensorManagerRecord) {
                self.next_time = record.next_time;
                self.received_observations = record
                    .received_observations
                    .into_iter()
                    .map(|o| {
                        let mut obs = Observation::new();
                        obs.from_record(o);
                        obs
                    })
                    .collect();
                for (i, sensor) in self.sensors.iter_mut().enumerate() {
                    sensor.name = record.sensors[i].name.clone();
                    sensor
                        .sensor
                        .write()
                        .unwrap()
                        .from_record(record.sensors[i].record.clone())
                }
            }
        }
        impl MessageHandler for SensorManager {
            fn handle_message(
                &mut self,
                robot: &mut Node,
                from: &String,
                message: &serde_json::Value,
                time: f32,
            ) -> Result<(), ()> {
                if let Ok(obs_list) = serde_json::from_value::<
                    Vec<Observation>,
                >(message.clone()) {
                    self.received_observations.extend(obs_list);
                    if self.received_observations.len() > 0 {
                        self.next_time = Some(time);
                    }
                    if is_enabled(crate::logger::InternalLog::SensorManager) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Receive observations from {0} at time {1}",
                                            from,
                                            time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::sensors::sensor_manager",
                                            "simba::sensors::sensor_manager",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    Ok(())
                } else {
                    Err(())
                }
            }
        }
    }
    pub mod fault_models {
        pub mod additive_observation_centered_polar {
            //! AdditiveObservationCenteredPolarPolar faults
            //!
            //! Remark: the order of the application of the random value is alphabetical on the name of the observation variables if no order is specified.
            use std::sync::{Arc, Mutex};
            use config_checker::macros::Check;
            use serde::{Deserialize, Serialize};
            use crate::{
                sensors::sensor::SensorObservation,
                utils::{
                    determinist_random_variable::{
                        DeterministRandomVariable, DeterministRandomVariableFactory,
                        RandomVariableTypeConfig,
                    },
                    distributions::{
                        bernouilli::{
                            BernouilliRandomVariableConfig,
                            DeterministBernouilliRandomVariable,
                        },
                        normal::NormalRandomVariableConfig,
                    },
                    geometry::mod2pi,
                },
            };
            use super::fault_model::FaultModel;
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct AdditiveObservationCenteredPolarFaultConfig {
                #[check(eq(self.apparition.probability.len(), 1))]
                #[check]
                pub apparition: BernouilliRandomVariableConfig,
                #[check]
                pub distributions: Vec<RandomVariableTypeConfig>,
                pub variable_order: Vec<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AdditiveObservationCenteredPolarFaultConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AdditiveObservationCenteredPolarFaultConfig",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &&self.variable_order,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AdditiveObservationCenteredPolarFaultConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "AdditiveObservationCenteredPolarFaultConfig",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "apparition",
                            &self.apparition,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "distributions",
                            &self.distributions,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "variable_order",
                            &self.variable_order,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de>
                for AdditiveObservationCenteredPolarFaultConfig
                where
                    AdditiveObservationCenteredPolarFaultConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "apparition" => _serde::__private::Ok(__Field::__field0),
                                    "distributions" => _serde::__private::Ok(__Field::__field1),
                                    "variable_order" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"apparition" => _serde::__private::Ok(__Field::__field0),
                                    b"distributions" => _serde::__private::Ok(__Field::__field1),
                                    b"variable_order" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            AdditiveObservationCenteredPolarFaultConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                AdditiveObservationCenteredPolarFaultConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            AdditiveObservationCenteredPolarFaultConfig: _serde::__private::Default,
                        {
                            type Value = AdditiveObservationCenteredPolarFaultConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct AdditiveObservationCenteredPolarFaultConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    BernouilliRandomVariableConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<RandomVariableTypeConfig>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Vec<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.variable_order,
                                };
                                _serde::__private::Ok(AdditiveObservationCenteredPolarFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    BernouilliRandomVariableConfig,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<RandomVariableTypeConfig>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "apparition",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    BernouilliRandomVariableConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "distributions",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<RandomVariableTypeConfig>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "variable_order",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.variable_order,
                                };
                                _serde::__private::Ok(AdditiveObservationCenteredPolarFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "apparition",
                            "distributions",
                            "variable_order",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "AdditiveObservationCenteredPolarFaultConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    AdditiveObservationCenteredPolarFaultConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for AdditiveObservationCenteredPolarFaultConfig {
                #[inline]
                fn clone(&self) -> AdditiveObservationCenteredPolarFaultConfig {
                    AdditiveObservationCenteredPolarFaultConfig {
                        apparition: ::core::clone::Clone::clone(&self.apparition),
                        distributions: ::core::clone::Clone::clone(&self.distributions),
                        variable_order: ::core::clone::Clone::clone(&self.variable_order),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable
            for AdditiveObservationCenteredPolarFaultConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    if !(self.apparition.probability.len() == 1) {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {3}In field `{1}` of `{2}`\n",
                                    "ERROR:".red(),
                                    "apparition",
                                    "AdditiveObservationCenteredPolarFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                        ret = false;
                    }
                    if !::config_checker::__check_config(&self.apparition, depth + 1) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "apparition",
                                    "AdditiveObservationCenteredPolarFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    if !::config_checker::__check_config(
                        &self.distributions,
                        depth + 1,
                    ) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "distributions",
                                    "AdditiveObservationCenteredPolarFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    ret
                }
            }
            impl Default for AdditiveObservationCenteredPolarFaultConfig {
                fn default() -> Self {
                    Self {
                        apparition: BernouilliRandomVariableConfig {
                            probability: <[_]>::into_vec(::alloc::boxed::box_new([1.0])),
                            ..Default::default()
                        },
                        distributions: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                RandomVariableTypeConfig::Normal(
                                    NormalRandomVariableConfig::default(),
                                ),
                            ]),
                        ),
                        variable_order: Vec::new(),
                    }
                }
            }
            pub struct AdditiveObservationCenteredPolarFault {
                apparition: DeterministBernouilliRandomVariable,
                distributions: Arc<Mutex<Vec<Box<dyn DeterministRandomVariable>>>>,
                variable_order: Vec<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AdditiveObservationCenteredPolarFault {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AdditiveObservationCenteredPolarFault",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &&self.variable_order,
                    )
                }
            }
            impl AdditiveObservationCenteredPolarFault {
                pub fn from_config(
                    config: &AdditiveObservationCenteredPolarFaultConfig,
                    va_factory: &DeterministRandomVariableFactory,
                ) -> Self {
                    let distributions = Arc::new(
                        Mutex::new(
                            config
                                .distributions
                                .iter()
                                .map(|conf| va_factory.make_variable(conf.clone()))
                                .collect::<Vec<Box<dyn DeterministRandomVariable>>>(),
                        ),
                    );
                    if config.variable_order.len() != 0 {
                        if !(config.variable_order.len()
                            == distributions
                                .lock()
                                .unwrap()
                                .iter()
                                .map(|d| d.dim())
                                .sum::<usize>())
                        {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "If variable order is given, its length must match the distribution dimension.",
                                    ),
                                );
                            }
                        }
                    }
                    Self {
                        apparition: DeterministBernouilliRandomVariable::from_config(
                            va_factory.global_seed,
                            config.apparition.clone(),
                        ),
                        distributions,
                        variable_order: config.variable_order.clone(),
                    }
                }
            }
            impl FaultModel for AdditiveObservationCenteredPolarFault {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    _obs_type: SensorObservation,
                ) {
                    let obs_seed_increment = 1. / (100. * period);
                    let mut seed = time;
                    for obs in obs_list {
                        seed += obs_seed_increment;
                        if self.apparition.gen(seed)[0] < 1. {
                            continue;
                        }
                        let mut random_sample = Vec::new();
                        for d in self.distributions.lock().unwrap().iter() {
                            random_sample.extend_from_slice(&d.gen(seed));
                        }
                        match obs {
                            SensorObservation::OrientedRobot(o) => {
                                let mut r_add = 0.;
                                let mut z_add = 0.;
                                let mut theta_add = 0.;
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "r" => r_add = random_sample[i],
                                            "theta" => theta_add = random_sample[i],
                                            "z | orientation" => z_add = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [r, theta, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveObservationCenteredPolar fault for OrientedRobot observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    theta_add = random_sample[0];
                                    r_add = random_sample[1];
                                    z_add = random_sample[2];
                                }
                                let theta = o.pose.z + theta_add;
                                o.pose.x += r_add * theta.cos();
                                o.pose.y += r_add * theta.sin();
                                o.pose.z = o.pose.z + z_add;
                                o.pose.z = mod2pi(o.pose.z);
                            }
                            SensorObservation::GNSS(o) => {
                                let mut r_add = 0.;
                                let mut theta_add = 0.;
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "r" => r_add = random_sample[i],
                                            "theta" => theta_add = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [r, theta]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveObservationCenteredPolar fault for OrientedRobot observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    theta_add = random_sample[0];
                                    r_add = random_sample[1];
                                }
                                o.position.x += r_add * theta_add.cos();
                                o.position.y += r_add * theta_add.sin();
                            }
                            SensorObservation::Odometry(_) => {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Not implemented (appropriated for this sensor?)",
                                        ),
                                    );
                                };
                            }
                            SensorObservation::OrientedLandmark(o) => {
                                let mut r_add = 0.;
                                let mut z_add = 0.;
                                let mut theta_add = 0.;
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "r" => r_add = random_sample[i],
                                            "theta" => theta_add = random_sample[i],
                                            "z | orientation" => z_add = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [r, theta, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveObservationCenteredPolar fault for OrientedLandmark observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    r_add = random_sample[0];
                                    theta_add = random_sample[1];
                                    z_add = random_sample[2];
                                }
                                let theta = o.pose.z + theta_add;
                                o.pose.x += r_add * theta.cos();
                                o.pose.y += r_add * theta.sin();
                                o.pose.z = o.pose.z + z_add;
                                o.pose.z = mod2pi(o.pose.z);
                            }
                        }
                    }
                }
            }
            pub struct AdditiveObservationCenteredPolarRecord {}
        }
        pub mod additive_robot_centered {
            //! AdditiveRobotCentered faults
            //!
            //! Remark: the order of the application of the random value is alphabetical on the name of the observation variables if no order is specified.
            use std::sync::{Arc, Mutex};
            use config_checker::macros::Check;
            use serde::{Deserialize, Serialize};
            use crate::{
                sensors::sensor::SensorObservation,
                utils::{
                    determinist_random_variable::{
                        DeterministRandomVariable, DeterministRandomVariableFactory,
                        RandomVariableTypeConfig,
                    },
                    distributions::{
                        bernouilli::{
                            BernouilliRandomVariableConfig,
                            DeterministBernouilliRandomVariable,
                        },
                        normal::NormalRandomVariableConfig,
                    },
                    geometry::mod2pi,
                },
            };
            use super::fault_model::FaultModel;
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct AdditiveRobotCenteredFaultConfig {
                #[check(eq(self.apparition.probability.len(), 1))]
                #[check]
                pub apparition: BernouilliRandomVariableConfig,
                #[check]
                pub distributions: Vec<RandomVariableTypeConfig>,
                pub variable_order: Vec<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AdditiveRobotCenteredFaultConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AdditiveRobotCenteredFaultConfig",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &&self.variable_order,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AdditiveRobotCenteredFaultConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "AdditiveRobotCenteredFaultConfig",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "apparition",
                            &self.apparition,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "distributions",
                            &self.distributions,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "variable_order",
                            &self.variable_order,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AdditiveRobotCenteredFaultConfig
                where
                    AdditiveRobotCenteredFaultConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "apparition" => _serde::__private::Ok(__Field::__field0),
                                    "distributions" => _serde::__private::Ok(__Field::__field1),
                                    "variable_order" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"apparition" => _serde::__private::Ok(__Field::__field0),
                                    b"distributions" => _serde::__private::Ok(__Field::__field1),
                                    b"variable_order" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            AdditiveRobotCenteredFaultConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                AdditiveRobotCenteredFaultConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            AdditiveRobotCenteredFaultConfig: _serde::__private::Default,
                        {
                            type Value = AdditiveRobotCenteredFaultConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct AdditiveRobotCenteredFaultConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    BernouilliRandomVariableConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<RandomVariableTypeConfig>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Vec<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.variable_order,
                                };
                                _serde::__private::Ok(AdditiveRobotCenteredFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    BernouilliRandomVariableConfig,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<RandomVariableTypeConfig>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "apparition",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    BernouilliRandomVariableConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "distributions",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<RandomVariableTypeConfig>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "variable_order",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.variable_order,
                                };
                                _serde::__private::Ok(AdditiveRobotCenteredFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "apparition",
                            "distributions",
                            "variable_order",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "AdditiveRobotCenteredFaultConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    AdditiveRobotCenteredFaultConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for AdditiveRobotCenteredFaultConfig {
                #[inline]
                fn clone(&self) -> AdditiveRobotCenteredFaultConfig {
                    AdditiveRobotCenteredFaultConfig {
                        apparition: ::core::clone::Clone::clone(&self.apparition),
                        distributions: ::core::clone::Clone::clone(&self.distributions),
                        variable_order: ::core::clone::Clone::clone(&self.variable_order),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for AdditiveRobotCenteredFaultConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    if !(self.apparition.probability.len() == 1) {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {3}In field `{1}` of `{2}`\n",
                                    "ERROR:".red(),
                                    "apparition",
                                    "AdditiveRobotCenteredFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                        ret = false;
                    }
                    if !::config_checker::__check_config(&self.apparition, depth + 1) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "apparition",
                                    "AdditiveRobotCenteredFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    if !::config_checker::__check_config(
                        &self.distributions,
                        depth + 1,
                    ) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "distributions",
                                    "AdditiveRobotCenteredFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    ret
                }
            }
            impl Default for AdditiveRobotCenteredFaultConfig {
                fn default() -> Self {
                    Self {
                        apparition: BernouilliRandomVariableConfig {
                            probability: <[_]>::into_vec(::alloc::boxed::box_new([1.0])),
                            ..Default::default()
                        },
                        distributions: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                RandomVariableTypeConfig::Normal(
                                    NormalRandomVariableConfig::default(),
                                ),
                            ]),
                        ),
                        variable_order: Vec::new(),
                    }
                }
            }
            pub struct AdditiveRobotCenteredFault {
                apparition: DeterministBernouilliRandomVariable,
                distributions: Arc<Mutex<Vec<Box<dyn DeterministRandomVariable>>>>,
                variable_order: Vec<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AdditiveRobotCenteredFault {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AdditiveRobotCenteredFault",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &&self.variable_order,
                    )
                }
            }
            impl AdditiveRobotCenteredFault {
                pub fn from_config(
                    config: &AdditiveRobotCenteredFaultConfig,
                    va_factory: &DeterministRandomVariableFactory,
                ) -> Self {
                    let distributions = Arc::new(
                        Mutex::new(
                            config
                                .distributions
                                .iter()
                                .map(|conf| va_factory.make_variable(conf.clone()))
                                .collect::<Vec<Box<dyn DeterministRandomVariable>>>(),
                        ),
                    );
                    if config.variable_order.len() != 0 {
                        if !(config.variable_order.len()
                            == distributions
                                .lock()
                                .unwrap()
                                .iter()
                                .map(|d| d.dim())
                                .sum::<usize>())
                        {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "If variable order is given, its length must match the distribution dimension.",
                                    ),
                                );
                            }
                        }
                    }
                    Self {
                        apparition: DeterministBernouilliRandomVariable::from_config(
                            va_factory.global_seed,
                            config.apparition.clone(),
                        ),
                        distributions,
                        variable_order: config.variable_order.clone(),
                    }
                }
            }
            impl FaultModel for AdditiveRobotCenteredFault {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    _obs_type: SensorObservation,
                ) {
                    let obs_seed_increment = 1. / (100. * period);
                    let mut seed = time;
                    for obs in obs_list {
                        seed += obs_seed_increment;
                        if self.apparition.gen(seed)[0] < 1. {
                            continue;
                        }
                        let mut random_sample = Vec::new();
                        for d in self.distributions.lock().unwrap().iter() {
                            random_sample.extend_from_slice(&d.gen(seed));
                        }
                        match obs {
                            SensorObservation::OrientedRobot(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "x" => o.pose.x += random_sample[i],
                                            "y" => o.pose.y += random_sample[i],
                                            "z" | "orientation" => o.pose.z += random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [x, y, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveRobotCentered fault for OrientedRobot observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    o.pose.x += random_sample[0];
                                    o.pose.y += random_sample[1];
                                    o.pose.z += random_sample[2];
                                }
                                o.pose.z = mod2pi(o.pose.z);
                            }
                            SensorObservation::GNSS(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "position_x" | "x" => o.position.x += random_sample[i],
                                            "position_y" | "y" => o.position.y += random_sample[i],
                                            "velocity_x" => o.velocity.x += random_sample[i],
                                            "velocity_y" => o.velocity.y += random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [position_x | x, position_y | y, velocity_x, velocity_y]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 2) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveRobotCentered fault for GNSS observation need to be at least of dimension 2 (to 4 for velocities).",
                                                ),
                                            );
                                        }
                                    }
                                    o.position.x += random_sample[0];
                                    o.position.y += random_sample[1];
                                    if random_sample.len() >= 3 {
                                        o.velocity.x += random_sample[2];
                                    }
                                    if random_sample.len() >= 4 {
                                        o.velocity.y += random_sample[3];
                                    }
                                }
                            }
                            SensorObservation::Odometry(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "w" | "angular" | "angular_velocity" => {
                                                o.angular_velocity += random_sample[i];
                                            }
                                            "v" | "linear" | "linear_velocity" => {
                                                o.linear_velocity += random_sample[i];
                                            }
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [w | angular | angular_velocity, v | linear | linear_velocity]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 2) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveRobotCentered fault for Odometry observation need to be of dimension 2.",
                                                ),
                                            );
                                        }
                                    }
                                    o.angular_velocity += random_sample[0];
                                    o.linear_velocity += random_sample[1];
                                }
                            }
                            SensorObservation::OrientedLandmark(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "x" => o.pose.x += random_sample[i],
                                            "y" => o.pose.y += random_sample[i],
                                            "z" | "orientation" => o.pose.z += random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [x, y, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveRobotCentered fault for OrientedLandmark observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    o.pose.x += random_sample[0];
                                    o.pose.y += random_sample[1];
                                    o.pose.z += random_sample[2];
                                }
                                o.pose.z = mod2pi(o.pose.z);
                            }
                        }
                    }
                }
            }
            pub struct AdditiveRobotCenteredRecord {}
        }
        pub mod additive_robot_centered_polar {
            //! AdditiveRobotCenteredPolarPolar faults
            //!
            //! Remark: the order of the application of the random value is alphabetical on the name of the observation variables if no order is specified.
            use std::sync::{Arc, Mutex};
            use config_checker::macros::Check;
            use libm::atan2f;
            use serde::{Deserialize, Serialize};
            use crate::{
                sensors::sensor::SensorObservation,
                utils::{
                    determinist_random_variable::{
                        DeterministRandomVariable, DeterministRandomVariableFactory,
                        RandomVariableTypeConfig,
                    },
                    distributions::{
                        bernouilli::{
                            BernouilliRandomVariableConfig,
                            DeterministBernouilliRandomVariable,
                        },
                        normal::NormalRandomVariableConfig,
                    },
                    geometry::mod2pi,
                },
            };
            use super::fault_model::FaultModel;
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct AdditiveRobotCenteredPolarFaultConfig {
                #[check(eq(self.apparition.probability.len(), 1))]
                #[check]
                pub apparition: BernouilliRandomVariableConfig,
                #[check]
                pub distributions: Vec<RandomVariableTypeConfig>,
                pub variable_order: Vec<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AdditiveRobotCenteredPolarFaultConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AdditiveRobotCenteredPolarFaultConfig",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &&self.variable_order,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AdditiveRobotCenteredPolarFaultConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "AdditiveRobotCenteredPolarFaultConfig",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "apparition",
                            &self.apparition,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "distributions",
                            &self.distributions,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "variable_order",
                            &self.variable_order,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de>
                for AdditiveRobotCenteredPolarFaultConfig
                where
                    AdditiveRobotCenteredPolarFaultConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "apparition" => _serde::__private::Ok(__Field::__field0),
                                    "distributions" => _serde::__private::Ok(__Field::__field1),
                                    "variable_order" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"apparition" => _serde::__private::Ok(__Field::__field0),
                                    b"distributions" => _serde::__private::Ok(__Field::__field1),
                                    b"variable_order" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            AdditiveRobotCenteredPolarFaultConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                AdditiveRobotCenteredPolarFaultConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            AdditiveRobotCenteredPolarFaultConfig: _serde::__private::Default,
                        {
                            type Value = AdditiveRobotCenteredPolarFaultConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct AdditiveRobotCenteredPolarFaultConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    BernouilliRandomVariableConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<RandomVariableTypeConfig>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Vec<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.variable_order,
                                };
                                _serde::__private::Ok(AdditiveRobotCenteredPolarFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    BernouilliRandomVariableConfig,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<RandomVariableTypeConfig>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "apparition",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    BernouilliRandomVariableConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "distributions",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<RandomVariableTypeConfig>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "variable_order",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.variable_order,
                                };
                                _serde::__private::Ok(AdditiveRobotCenteredPolarFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "apparition",
                            "distributions",
                            "variable_order",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "AdditiveRobotCenteredPolarFaultConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    AdditiveRobotCenteredPolarFaultConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for AdditiveRobotCenteredPolarFaultConfig {
                #[inline]
                fn clone(&self) -> AdditiveRobotCenteredPolarFaultConfig {
                    AdditiveRobotCenteredPolarFaultConfig {
                        apparition: ::core::clone::Clone::clone(&self.apparition),
                        distributions: ::core::clone::Clone::clone(&self.distributions),
                        variable_order: ::core::clone::Clone::clone(&self.variable_order),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable
            for AdditiveRobotCenteredPolarFaultConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    if !(self.apparition.probability.len() == 1) {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {3}In field `{1}` of `{2}`\n",
                                    "ERROR:".red(),
                                    "apparition",
                                    "AdditiveRobotCenteredPolarFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                        ret = false;
                    }
                    if !::config_checker::__check_config(&self.apparition, depth + 1) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "apparition",
                                    "AdditiveRobotCenteredPolarFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    if !::config_checker::__check_config(
                        &self.distributions,
                        depth + 1,
                    ) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "distributions",
                                    "AdditiveRobotCenteredPolarFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    ret
                }
            }
            impl Default for AdditiveRobotCenteredPolarFaultConfig {
                fn default() -> Self {
                    Self {
                        apparition: BernouilliRandomVariableConfig {
                            probability: <[_]>::into_vec(::alloc::boxed::box_new([1.0])),
                            ..Default::default()
                        },
                        distributions: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                RandomVariableTypeConfig::Normal(
                                    NormalRandomVariableConfig::default(),
                                ),
                            ]),
                        ),
                        variable_order: Vec::new(),
                    }
                }
            }
            pub struct AdditiveRobotCenteredPolarFault {
                apparition: DeterministBernouilliRandomVariable,
                distributions: Arc<Mutex<Vec<Box<dyn DeterministRandomVariable>>>>,
                variable_order: Vec<String>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AdditiveRobotCenteredPolarFault {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AdditiveRobotCenteredPolarFault",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &&self.variable_order,
                    )
                }
            }
            impl AdditiveRobotCenteredPolarFault {
                pub fn from_config(
                    config: &AdditiveRobotCenteredPolarFaultConfig,
                    va_factory: &DeterministRandomVariableFactory,
                ) -> Self {
                    let distributions = Arc::new(
                        Mutex::new(
                            config
                                .distributions
                                .iter()
                                .map(|conf| va_factory.make_variable(conf.clone()))
                                .collect::<Vec<Box<dyn DeterministRandomVariable>>>(),
                        ),
                    );
                    if config.variable_order.len() != 0 {
                        if !(config.variable_order.len()
                            == distributions
                                .lock()
                                .unwrap()
                                .iter()
                                .map(|d| d.dim())
                                .sum::<usize>())
                        {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "If variable order is given, its length must match the distribution dimension.",
                                    ),
                                );
                            }
                        }
                    }
                    Self {
                        apparition: DeterministBernouilliRandomVariable::from_config(
                            va_factory.global_seed,
                            config.apparition.clone(),
                        ),
                        distributions,
                        variable_order: config.variable_order.clone(),
                    }
                }
            }
            impl FaultModel for AdditiveRobotCenteredPolarFault {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    _obs_type: SensorObservation,
                ) {
                    let obs_seed_increment = 1. / (100. * period);
                    let mut seed = time;
                    for obs in obs_list {
                        seed += obs_seed_increment;
                        if self.apparition.gen(seed)[0] < 1. {
                            continue;
                        }
                        let mut random_sample = Vec::new();
                        for d in self.distributions.lock().unwrap().iter() {
                            random_sample.extend_from_slice(&d.gen(seed));
                        }
                        match obs {
                            SensorObservation::OrientedRobot(o) => {
                                let mut r_add = 0.;
                                let mut z_add = 0.;
                                let mut theta_add = 0.;
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "r" => r_add = random_sample[i],
                                            "theta" => theta_add = random_sample[i],
                                            "z | orientation" => z_add = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [r, theta, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveRobotCenteredPolar fault for OrientedRobot observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    r_add = random_sample[0];
                                    theta_add = random_sample[1];
                                    z_add = random_sample[2];
                                }
                                let current_r = (o.pose.x.powi(2) + o.pose.y.powi(2))
                                    .sqrt();
                                let current_dir = atan2f(o.pose.y, o.pose.x);
                                let r = current_r + r_add;
                                let theta = current_dir + theta_add;
                                let z = o.pose.z + z_add;
                                o.pose.x = r * theta.cos();
                                o.pose.y = r * theta.sin();
                                o.pose.z = mod2pi(z);
                            }
                            SensorObservation::GNSS(_) => {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Not implemented yet (need to find a logical way to do it.",
                                        ),
                                    );
                                };
                            }
                            SensorObservation::Odometry(_) => {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Not implemented (appropriated for this sensor?)",
                                        ),
                                    );
                                };
                            }
                            SensorObservation::OrientedLandmark(o) => {
                                let mut r_add = 0.;
                                let mut z_add = 0.;
                                let mut theta_add = 0.;
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "r" => r_add = random_sample[i],
                                            "theta" => theta_add = random_sample[i],
                                            "z | orientation" => z_add = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [r, theta, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an AdditiveRobotCenteredPolar fault for OrientedLandmark observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    r_add = random_sample[0];
                                    theta_add = random_sample[1];
                                    z_add = random_sample[2];
                                }
                                let current_r = (o.pose.x.powi(2) + o.pose.y.powi(2))
                                    .sqrt();
                                let current_dir = atan2f(o.pose.y, o.pose.x);
                                let r = current_r + r_add;
                                let theta = current_dir + theta_add;
                                let z = o.pose.z + z_add;
                                o.pose.x = r * theta.cos();
                                o.pose.y = r * theta.sin();
                                o.pose.z = mod2pi(z);
                            }
                        }
                    }
                }
            }
            pub struct AdditiveRobotCenteredPolarRecord {}
        }
        pub mod clutter {
            use std::sync::{Arc, Mutex};
            use config_checker::macros::Check;
            use serde::{Deserialize, Serialize};
            use crate::{
                sensors::sensor::SensorObservation,
                utils::{
                    determinist_random_variable::{
                        DeterministRandomVariable, DeterministRandomVariableFactory,
                        RandomVariableTypeConfig,
                    },
                    distributions::{
                        poisson::PoissonRandomVariableConfig,
                        uniform::UniformRandomVariableConfig,
                    },
                    geometry::mod2pi,
                },
            };
            use super::fault_model::FaultModel;
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct ClutterFaultConfig {
                #[check]
                pub apparition: RandomVariableTypeConfig,
                #[check]
                pub distributions: Vec<RandomVariableTypeConfig>,
                pub variable_order: Vec<String>,
                pub observation_id: String,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ClutterFaultConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "ClutterFaultConfig",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &self.variable_order,
                        "observation_id",
                        &&self.observation_id,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ClutterFaultConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ClutterFaultConfig",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "apparition",
                            &self.apparition,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "distributions",
                            &self.distributions,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "variable_order",
                            &self.variable_order,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "observation_id",
                            &self.observation_id,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ClutterFaultConfig
                where
                    ClutterFaultConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 4",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "apparition" => _serde::__private::Ok(__Field::__field0),
                                    "distributions" => _serde::__private::Ok(__Field::__field1),
                                    "variable_order" => _serde::__private::Ok(__Field::__field2),
                                    "observation_id" => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"apparition" => _serde::__private::Ok(__Field::__field0),
                                    b"distributions" => _serde::__private::Ok(__Field::__field1),
                                    b"variable_order" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"observation_id" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            ClutterFaultConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<ClutterFaultConfig>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            ClutterFaultConfig: _serde::__private::Default,
                        {
                            type Value = ClutterFaultConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ClutterFaultConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    RandomVariableTypeConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<RandomVariableTypeConfig>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Vec<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.variable_order,
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.observation_id,
                                };
                                _serde::__private::Ok(ClutterFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                    observation_id: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    RandomVariableTypeConfig,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<RandomVariableTypeConfig>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "apparition",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RandomVariableTypeConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "distributions",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<RandomVariableTypeConfig>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "variable_order",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "observation_id",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.distributions,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.variable_order,
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => __default.observation_id,
                                };
                                _serde::__private::Ok(ClutterFaultConfig {
                                    apparition: __field0,
                                    distributions: __field1,
                                    variable_order: __field2,
                                    observation_id: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "apparition",
                            "distributions",
                            "variable_order",
                            "observation_id",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ClutterFaultConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ClutterFaultConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for ClutterFaultConfig {
                #[inline]
                fn clone(&self) -> ClutterFaultConfig {
                    ClutterFaultConfig {
                        apparition: ::core::clone::Clone::clone(&self.apparition),
                        distributions: ::core::clone::Clone::clone(&self.distributions),
                        variable_order: ::core::clone::Clone::clone(
                            &self.variable_order,
                        ),
                        observation_id: ::core::clone::Clone::clone(&self.observation_id),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for ClutterFaultConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    if !::config_checker::__check_config(&self.apparition, depth + 1) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "apparition",
                                    "ClutterFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    if !::config_checker::__check_config(
                        &self.distributions,
                        depth + 1,
                    ) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "distributions",
                                    "ClutterFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    ret
                }
            }
            impl Default for ClutterFaultConfig {
                fn default() -> Self {
                    Self {
                        apparition: RandomVariableTypeConfig::Poisson(PoissonRandomVariableConfig {
                            lambda: <[_]>::into_vec(::alloc::boxed::box_new([10.])),
                            unique_seed: 0.,
                        }),
                        distributions: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                RandomVariableTypeConfig::Uniform(UniformRandomVariableConfig {
                                    unique_seed: 0.,
                                    min: <[_]>::into_vec(::alloc::boxed::box_new([-10., -10.])),
                                    max: <[_]>::into_vec(::alloc::boxed::box_new([10., 10.])),
                                }),
                            ]),
                        ),
                        variable_order: Vec::new(),
                        observation_id: "clutter".to_string(),
                    }
                }
            }
            pub struct ClutterFault {
                apparition: Arc<Mutex<Box<dyn DeterministRandomVariable>>>,
                distributions: Arc<Mutex<Vec<Box<dyn DeterministRandomVariable>>>>,
                variable_order: Vec<String>,
                observation_id: String,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ClutterFault {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "ClutterFault",
                        "apparition",
                        &self.apparition,
                        "distributions",
                        &self.distributions,
                        "variable_order",
                        &self.variable_order,
                        "observation_id",
                        &&self.observation_id,
                    )
                }
            }
            impl ClutterFault {
                pub fn from_config(
                    config: &ClutterFaultConfig,
                    va_factory: &DeterministRandomVariableFactory,
                ) -> Self {
                    let distributions = Arc::new(
                        Mutex::new(
                            config
                                .distributions
                                .iter()
                                .map(|conf| va_factory.make_variable(conf.clone()))
                                .collect::<Vec<Box<dyn DeterministRandomVariable>>>(),
                        ),
                    );
                    if config.variable_order.len() != 0 {
                        if !(config.variable_order.len()
                            == distributions
                                .lock()
                                .unwrap()
                                .iter()
                                .map(|d| d.dim())
                                .sum::<usize>())
                        {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "If variable order is given, its length must match the distribution dimension.",
                                    ),
                                );
                            }
                        }
                    }
                    let apparition_distrib = Arc::new(
                        Mutex::new(va_factory.make_variable(config.apparition.clone())),
                    );
                    if !(apparition_distrib.lock().unwrap().dim() == 1) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "The dimension of the apparition distribution should be 1.",
                                ),
                            );
                        }
                    }
                    Self {
                        apparition: apparition_distrib,
                        distributions,
                        variable_order: config.variable_order.clone(),
                        observation_id: config.observation_id.clone(),
                    }
                }
            }
            impl FaultModel for ClutterFault {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    obs_type: SensorObservation,
                ) {
                    let obs_seed_increment = 1. / (100. * period);
                    let mut seed = time;
                    let n_obs = self
                        .apparition
                        .lock()
                        .unwrap()
                        .gen(time)[0]
                        .abs()
                        .floor() as usize;
                    for _ in 0..n_obs {
                        seed += obs_seed_increment;
                        let mut random_sample = Vec::new();
                        for d in self.distributions.lock().unwrap().iter() {
                            random_sample.extend_from_slice(&d.gen(seed));
                        }
                        let mut new_obs = obs_type.clone();
                        match &mut new_obs {
                            SensorObservation::OrientedRobot(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "x" => o.pose.x = random_sample[i],
                                            "y" => o.pose.y = random_sample[i],
                                            "z" | "orientation" => o.pose.z = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [x, y, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an Clutter fault for OrientedRobot observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    o.pose.x = random_sample[0];
                                    o.pose.y = random_sample[1];
                                    o.pose.z = random_sample[2];
                                }
                                o.pose.z = mod2pi(o.pose.z);
                                o.name = self.observation_id.clone();
                            }
                            SensorObservation::GNSS(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "position_x" | "x" => o.position.x = random_sample[i],
                                            "position_y" | "y" => o.position.y = random_sample[i],
                                            "velocity_x" => o.velocity.x = random_sample[i],
                                            "velocity_y" => o.velocity.y = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [position_x | x, position_y | y, velocity_x, velocity_y]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 2) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an Clutter fault for GNSS observation need to be at least of dimension 2 (to 4 for velocities).",
                                                ),
                                            );
                                        }
                                    }
                                    o.position.x = random_sample[0];
                                    o.position.y = random_sample[1];
                                    if random_sample.len() >= 3 {
                                        o.velocity.x = random_sample[2];
                                    }
                                    if random_sample.len() >= 4 {
                                        o.velocity.y = random_sample[3];
                                    }
                                }
                            }
                            SensorObservation::Odometry(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "w" | "angular" | "angular_velocity" => {
                                                o.angular_velocity = random_sample[i];
                                            }
                                            "v" | "linear" | "linear_velocity" => {
                                                o.linear_velocity = random_sample[i];
                                            }
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [w | angular | angular_velocity, v | linear | linear_velocity]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 2) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an Clutter fault for Odometry observation need to be of dimension 2.",
                                                ),
                                            );
                                        }
                                    }
                                    o.angular_velocity = random_sample[0];
                                    o.linear_velocity = random_sample[1];
                                }
                            }
                            SensorObservation::OrientedLandmark(o) => {
                                if self.variable_order.len() > 0 {
                                    for i in 0..self.variable_order.len() {
                                        match self.variable_order[i].as_str() {
                                            "x" => o.pose.x = random_sample[i],
                                            "y" => o.pose.y = random_sample[i],
                                            "z" | "orientation" => o.pose.z = random_sample[i],
                                            &_ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "Unknown variable name: \'{0}\'. Available variable names: [x, y, z | orientation]",
                                                        self.variable_order[i],
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                } else {
                                    if !(random_sample.len() >= 3) {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "The distribution of an Clutter fault for OrientedLandmark observation need to be of dimension 3.",
                                                ),
                                            );
                                        }
                                    }
                                    o.pose.x = random_sample[0];
                                    o.pose.y = random_sample[1];
                                    o.pose.z = random_sample[2];
                                }
                                o.pose.z = mod2pi(o.pose.z);
                                o.id = self.observation_id.parse().unwrap_or(-1);
                            }
                        }
                        obs_list.push(new_obs);
                    }
                }
            }
        }
        pub mod misassociation {
            //! Misassociation faults
            //!
            //! Remark: the order of the application of the random value is alphabetical on the name of the observation variables if no order is specified.
            use std::{ops::Rem, path::Path, sync::{Arc, Mutex}};
            use config_checker::macros::Check;
            use nalgebra::Vector2;
            use rand::prelude::*;
            use rand::seq::SliceRandom;
            use rand_chacha::ChaCha8Rng;
            use serde::{Deserialize, Serialize};
            use serde_json::from_str;
            use crate::{
                sensors::{
                    oriented_landmark_sensor::OrientedLandmarkSensor,
                    sensor::SensorObservation,
                },
                simulator::SimulatorConfig,
                utils::{
                    determinist_random_variable::{
                        DeterministRandomVariable, DeterministRandomVariableFactory,
                        RandomVariableTypeConfig,
                    },
                    distributions::{
                        bernouilli::{
                            BernouilliRandomVariableConfig,
                            DeterministBernouilliRandomVariable,
                        },
                        uniform::UniformRandomVariableConfig,
                    },
                },
            };
            use super::fault_model::FaultModel;
            pub enum Sort {
                None,
                Random,
                #[default]
                Distance,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sort {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Sort::None => "None",
                            Sort::Random => "Random",
                            Sort::Distance => "Distance",
                        },
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Sort {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Sort::None => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Sort",
                                    0u32,
                                    "None",
                                )
                            }
                            Sort::Random => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Sort",
                                    1u32,
                                    "Random",
                                )
                            }
                            Sort::Distance => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Sort",
                                    2u32,
                                    "Distance",
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Sort {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "None" => _serde::__private::Ok(__Field::__field0),
                                    "Random" => _serde::__private::Ok(__Field::__field1),
                                    "Distance" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"None" => _serde::__private::Ok(__Field::__field0),
                                    b"Random" => _serde::__private::Ok(__Field::__field1),
                                    b"Distance" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Sort>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Sort;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Sort",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Sort::None)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Sort::Random)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Sort::Distance)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "None",
                            "Random",
                            "Distance",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Sort",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Sort>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for Sort {
                #[inline]
                fn clone(&self) -> Sort {
                    match self {
                        Sort::None => Sort::None,
                        Sort::Random => Sort::Random,
                        Sort::Distance => Sort::Distance,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Sort {
                #[inline]
                fn default() -> Sort {
                    Self::Distance
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Sort {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Sort {
                #[inline]
                fn eq(&self, other: &Sort) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            pub enum Source {
                Map(String),
                Robots,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Source {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        Source::Map(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Map",
                                &__self_0,
                            )
                        }
                        Source::Robots => ::core::fmt::Formatter::write_str(f, "Robots"),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Source {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Source::Map(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Source",
                                    0u32,
                                    "Map",
                                    __field0,
                                )
                            }
                            Source::Robots => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Source",
                                    1u32,
                                    "Robots",
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Source {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Map" => _serde::__private::Ok(__Field::__field0),
                                    "Robots" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Map" => _serde::__private::Ok(__Field::__field0),
                                    b"Robots" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Source>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Source;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Source",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                String,
                                            >(__variant),
                                            Source::Map,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Source::Robots)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["Map", "Robots"];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Source",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Source>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for Source {
                #[inline]
                fn clone(&self) -> Source {
                    match self {
                        Source::Map(__self_0) => {
                            Source::Map(::core::clone::Clone::clone(__self_0))
                        }
                        Source::Robots => Source::Robots,
                    }
                }
            }
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct MisassociationFaultConfig {
                #[check(eq(self.apparition.probability.len(), 1))]
                pub apparition: BernouilliRandomVariableConfig,
                #[check]
                pub distribution: RandomVariableTypeConfig,
                #[check(
                    if(is_enum(self.source, Source::Robots), !is_enum(Sort::Distance))
                )]
                pub sort: Sort,
                pub source: Source,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MisassociationFaultConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "MisassociationFaultConfig",
                        "apparition",
                        &self.apparition,
                        "distribution",
                        &self.distribution,
                        "sort",
                        &self.sort,
                        "source",
                        &&self.source,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for MisassociationFaultConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "MisassociationFaultConfig",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "apparition",
                            &self.apparition,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "distribution",
                            &self.distribution,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "sort",
                            &self.sort,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "source",
                            &self.source,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for MisassociationFaultConfig
                where
                    MisassociationFaultConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 4",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "apparition" => _serde::__private::Ok(__Field::__field0),
                                    "distribution" => _serde::__private::Ok(__Field::__field1),
                                    "sort" => _serde::__private::Ok(__Field::__field2),
                                    "source" => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"apparition" => _serde::__private::Ok(__Field::__field0),
                                    b"distribution" => _serde::__private::Ok(__Field::__field1),
                                    b"sort" => _serde::__private::Ok(__Field::__field2),
                                    b"source" => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            MisassociationFaultConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                MisassociationFaultConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            MisassociationFaultConfig: _serde::__private::Default,
                        {
                            type Value = MisassociationFaultConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct MisassociationFaultConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    BernouilliRandomVariableConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    RandomVariableTypeConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.distribution,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Sort,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.sort,
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Source,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.source,
                                };
                                _serde::__private::Ok(MisassociationFaultConfig {
                                    apparition: __field0,
                                    distribution: __field1,
                                    sort: __field2,
                                    source: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    BernouilliRandomVariableConfig,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    RandomVariableTypeConfig,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Sort> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Source> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "apparition",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    BernouilliRandomVariableConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "distribution",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RandomVariableTypeConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("sort"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Sort>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Source>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.apparition,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.distribution,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.sort,
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => __default.source,
                                };
                                _serde::__private::Ok(MisassociationFaultConfig {
                                    apparition: __field0,
                                    distribution: __field1,
                                    sort: __field2,
                                    source: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "apparition",
                            "distribution",
                            "sort",
                            "source",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "MisassociationFaultConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    MisassociationFaultConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for MisassociationFaultConfig {
                #[inline]
                fn clone(&self) -> MisassociationFaultConfig {
                    MisassociationFaultConfig {
                        apparition: ::core::clone::Clone::clone(&self.apparition),
                        distribution: ::core::clone::Clone::clone(&self.distribution),
                        sort: ::core::clone::Clone::clone(&self.sort),
                        source: ::core::clone::Clone::clone(&self.source),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for MisassociationFaultConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    if !(self.apparition.probability.len() == 1) {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {3}In field `{1}` of `{2}`\n",
                                    "ERROR:".red(),
                                    "apparition",
                                    "MisassociationFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                        ret = false;
                    }
                    if !::config_checker::__check_config(&self.distribution, depth + 1) {
                        ret = false;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                    "NOTE: ".blue(),
                                    "\u{21b3}",
                                    "distribution",
                                    "MisassociationFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                    }
                    if !((((match self.source {
                        Source::Robots => true,
                        _ => false,
                    })
                        && (match self.sort {
                            Sort::Distance => true,
                            _ => false,
                        }))))
                    {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {3}In field `{1}` of `{2}`\n",
                                    "ERROR:".red(),
                                    "sort",
                                    "MisassociationFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                        ret = false;
                    }
                    ret
                }
            }
            impl Default for MisassociationFaultConfig {
                fn default() -> Self {
                    Self {
                        apparition: BernouilliRandomVariableConfig {
                            probability: <[_]>::into_vec(::alloc::boxed::box_new([0.1])),
                            ..Default::default()
                        },
                        distribution: RandomVariableTypeConfig::Uniform(UniformRandomVariableConfig {
                            max: <[_]>::into_vec(::alloc::boxed::box_new([10.])),
                            min: <[_]>::into_vec(::alloc::boxed::box_new([0.])),
                            ..Default::default()
                        }),
                        sort: Sort::Random,
                        source: Source::Robots,
                    }
                }
            }
            pub struct MisassociationFault {
                apparition: DeterministBernouilliRandomVariable,
                distribution: Arc<Mutex<Box<dyn DeterministRandomVariable>>>,
                sort: Sort,
                id_list: Vec<(String, Vector2<f32>)>,
                _source: Source,
                global_seed: f32,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MisassociationFault {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "apparition",
                        "distribution",
                        "sort",
                        "id_list",
                        "_source",
                        "global_seed",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.apparition,
                        &self.distribution,
                        &self.sort,
                        &self.id_list,
                        &self._source,
                        &&self.global_seed,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "MisassociationFault",
                        names,
                        values,
                    )
                }
            }
            impl MisassociationFault {
                pub fn from_config(
                    config: &MisassociationFaultConfig,
                    global_config: &SimulatorConfig,
                    robot_name: &String,
                    va_factory: &DeterministRandomVariableFactory,
                ) -> Self {
                    let distribution = Arc::new(
                        Mutex::new(va_factory.make_variable(config.distribution.clone())),
                    );
                    if !(distribution.lock().unwrap().dim() == 1) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Misassociation distribution should be of dimension 1 as it will search in a list",
                                ),
                            );
                        }
                    }
                    let id_list = match &config.source {
                        Source::Map(path) => {
                            let path = Path::new(&path);
                            if !path.exists() {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "The correct map path should be given for Misassociation fault (when source is Map)",
                                        ),
                                    );
                                };
                            }
                            let map = OrientedLandmarkSensor::load_map_from_path(path);
                            map.iter()
                                .map(|l| (
                                    l.id.to_string(),
                                    l.pose.fixed_rows::<2>(0).into(),
                                ))
                                .collect()
                        }
                        Source::Robots => {
                            global_config
                                .robots
                                .iter()
                                .map(|r| {
                                    if r.name != *robot_name {
                                        Some((r.name.clone(), Vector2::zeros()))
                                    } else {
                                        None
                                    }
                                })
                                .filter(|x| x.is_some())
                                .map(|x| x.unwrap())
                                .collect()
                        }
                    };
                    Self {
                        apparition: DeterministBernouilliRandomVariable::from_config(
                            va_factory.global_seed,
                            config.apparition.clone(),
                        ),
                        distribution,
                        sort: config.sort.clone(),
                        _source: config.source.clone(),
                        id_list,
                        global_seed: va_factory.global_seed,
                    }
                }
            }
            impl FaultModel for MisassociationFault {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    obs_type: SensorObservation,
                ) {
                    let obs_seed_increment = 1. / (100. * period);
                    let mut seed = time;
                    let mut id_list = self.id_list.clone();
                    match self.sort {
                        Sort::Random => {
                            let mut rng = ChaCha8Rng::seed_from_u64(
                                (self.global_seed + time).to_bits() as u64,
                            );
                            id_list.shuffle(&mut rng);
                        }
                        Sort::Distance => {
                            if let SensorObservation::OrientedRobot(_) = obs_type {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "MisassociationFault: Distance sorting is not implemented for Robot Observation",
                                        ),
                                    );
                                };
                            }
                        }
                        _ => {}
                    }
                    for obs in obs_list {
                        seed += obs_seed_increment;
                        if self.apparition.gen(seed)[0] < 1. {
                            continue;
                        }
                        let random_sample = self.distribution.lock().unwrap().gen(seed);
                        match obs {
                            SensorObservation::OrientedRobot(o) => {
                                let new_id = id_list[(random_sample[0].abs().floor()
                                        as usize)
                                        .rem(id_list.len())]
                                    .0
                                    .clone();
                                o.name = new_id;
                            }
                            SensorObservation::GNSS(_) => {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Not implemented (appropriated for this sensor?)",
                                        ),
                                    );
                                };
                            }
                            SensorObservation::Odometry(_) => {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Not implemented (appropriated for this sensor?)",
                                        ),
                                    );
                                };
                            }
                            SensorObservation::OrientedLandmark(o) => {
                                match self.sort {
                                    Sort::Distance => {
                                        id_list
                                            .sort_by_key(|i| {
                                                ((i.1 - o.pose.fixed_rows::<2>(0)).norm_squared() * 1000.)
                                                    as usize
                                            });
                                    }
                                    _ => {}
                                }
                                let new_id = id_list[(random_sample[0].abs().floor()
                                        as usize)
                                        .rem(id_list.len())]
                                    .0
                                    .clone();
                                o.id = from_str(&new_id)
                                    .expect(
                                        "Unexpected error: id_list should only contain int represented as string",
                                    );
                            }
                        }
                    }
                }
            }
            pub struct MisassociationRecord {}
        }
        pub mod misdetection {
            //! Misdetection faults
            //!
            //! Remark: the order of the application of the random value is alphabetical on the name of the observation variables if no order is specified.
            use config_checker::macros::Check;
            use log::debug;
            use serde::{Deserialize, Serialize};
            use crate::{
                logger::is_enabled, sensors::sensor::SensorObservation,
                utils::{
                    determinist_random_variable::{
                        DeterministRandomVariable, DeterministRandomVariableFactory,
                    },
                    distributions::bernouilli::{
                        BernouilliRandomVariableConfig,
                        DeterministBernouilliRandomVariable,
                    },
                },
            };
            use super::fault_model::FaultModel;
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct MisdetectionFaultConfig {
                #[check(eq(self.apparition.probability.len(), 1))]
                pub apparition: BernouilliRandomVariableConfig,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MisdetectionFaultConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "MisdetectionFaultConfig",
                        "apparition",
                        &&self.apparition,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for MisdetectionFaultConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "MisdetectionFaultConfig",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "apparition",
                            &self.apparition,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for MisdetectionFaultConfig
                where
                    MisdetectionFaultConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 1",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "apparition" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"apparition" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            MisdetectionFaultConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                MisdetectionFaultConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            MisdetectionFaultConfig: _serde::__private::Default,
                        {
                            type Value = MisdetectionFaultConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct MisdetectionFaultConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    BernouilliRandomVariableConfig,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.apparition,
                                };
                                _serde::__private::Ok(MisdetectionFaultConfig {
                                    apparition: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    BernouilliRandomVariableConfig,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "apparition",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    BernouilliRandomVariableConfig,
                                                >(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.apparition,
                                };
                                _serde::__private::Ok(MisdetectionFaultConfig {
                                    apparition: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["apparition"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "MisdetectionFaultConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    MisdetectionFaultConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for MisdetectionFaultConfig {
                #[inline]
                fn clone(&self) -> MisdetectionFaultConfig {
                    MisdetectionFaultConfig {
                        apparition: ::core::clone::Clone::clone(&self.apparition),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for MisdetectionFaultConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    if !(self.apparition.probability.len() == 1) {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0} {3}In field `{1}` of `{2}`\n",
                                    "ERROR:".red(),
                                    "apparition",
                                    "MisdetectionFaultConfig",
                                    depth_space,
                                ),
                            );
                        };
                        ret = false;
                    }
                    ret
                }
            }
            impl Default for MisdetectionFaultConfig {
                fn default() -> Self {
                    Self {
                        apparition: BernouilliRandomVariableConfig {
                            probability: <[_]>::into_vec(::alloc::boxed::box_new([0.1])),
                            ..Default::default()
                        },
                    }
                }
            }
            pub struct MisdetectionFault {
                apparition: DeterministBernouilliRandomVariable,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MisdetectionFault {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "MisdetectionFault",
                        "apparition",
                        &&self.apparition,
                    )
                }
            }
            impl MisdetectionFault {
                pub fn from_config(
                    config: &MisdetectionFaultConfig,
                    va_factory: &DeterministRandomVariableFactory,
                ) -> Self {
                    Self {
                        apparition: DeterministBernouilliRandomVariable::from_config(
                            va_factory.global_seed,
                            config.apparition.clone(),
                        ),
                    }
                }
            }
            impl FaultModel for MisdetectionFault {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    _obs_type: SensorObservation,
                ) {
                    let obs_seed_increment = 1. / (100. * period);
                    let mut seed = time;
                    for i in (0..obs_list.len()).rev() {
                        seed += obs_seed_increment;
                        if self.apparition.gen(seed)[0] > 0. {
                            if is_enabled(
                                crate::logger::InternalLog::SensorManagerDetailed,
                            ) {
                                {
                                    {
                                        let lvl = ::log::Level::Debug;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api::log(
                                                { ::log::__private_api::GlobalLogger },
                                                format_args!("Remove observation {0}", i),
                                                lvl,
                                                &(
                                                    "simba::sensors::fault_models::misdetection",
                                                    "simba::sensors::fault_models::misdetection",
                                                    ::log::__private_api::loc(),
                                                ),
                                                (),
                                            );
                                        }
                                    }
                                };
                            }
                            obs_list.remove(i);
                        }
                    }
                }
            }
            pub struct MisdetectionRecord {}
        }
        pub mod fault_model {
            //! TODO: Lots of code duplication between fault models, need to find a way to factorize
            use std::fmt::Debug;
            use config_checker::macros::Check;
            use serde::{Deserialize, Serialize};
            use crate::{
                sensors::sensor::SensorObservation, simulator::SimulatorConfig,
                utils::determinist_random_variable::DeterministRandomVariableFactory,
            };
            use super::{
                additive_observation_centered_polar::{
                    AdditiveObservationCenteredPolarFault,
                    AdditiveObservationCenteredPolarFaultConfig,
                },
                additive_robot_centered::{
                    AdditiveRobotCenteredFault, AdditiveRobotCenteredFaultConfig,
                },
                additive_robot_centered_polar::{
                    AdditiveRobotCenteredPolarFault,
                    AdditiveRobotCenteredPolarFaultConfig,
                },
                clutter::{ClutterFault, ClutterFaultConfig},
                misassociation::{MisassociationFault, MisassociationFaultConfig},
                misdetection::{MisdetectionFault, MisdetectionFaultConfig},
            };
            #[serde(deny_unknown_fields)]
            pub enum FaultModelConfig {
                AdditiveRobotCentered(AdditiveRobotCenteredFaultConfig),
                AdditiveRobotCenteredPolar(AdditiveRobotCenteredPolarFaultConfig),
                AdditiveObservationCenteredPolar(
                    AdditiveObservationCenteredPolarFaultConfig,
                ),
                Clutter(ClutterFaultConfig),
                Misdetection(MisdetectionFaultConfig),
                Misassociation(MisassociationFaultConfig),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for FaultModelConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        FaultModelConfig::AdditiveRobotCentered(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "AdditiveRobotCentered",
                                &__self_0,
                            )
                        }
                        FaultModelConfig::AdditiveRobotCenteredPolar(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "AdditiveRobotCenteredPolar",
                                &__self_0,
                            )
                        }
                        FaultModelConfig::AdditiveObservationCenteredPolar(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "AdditiveObservationCenteredPolar",
                                &__self_0,
                            )
                        }
                        FaultModelConfig::Clutter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Clutter",
                                &__self_0,
                            )
                        }
                        FaultModelConfig::Misdetection(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Misdetection",
                                &__self_0,
                            )
                        }
                        FaultModelConfig::Misassociation(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Misassociation",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for FaultModelConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            FaultModelConfig::AdditiveRobotCentered(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FaultModelConfig",
                                    0u32,
                                    "AdditiveRobotCentered",
                                    __field0,
                                )
                            }
                            FaultModelConfig::AdditiveRobotCenteredPolar(
                                ref __field0,
                            ) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FaultModelConfig",
                                    1u32,
                                    "AdditiveRobotCenteredPolar",
                                    __field0,
                                )
                            }
                            FaultModelConfig::AdditiveObservationCenteredPolar(
                                ref __field0,
                            ) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FaultModelConfig",
                                    2u32,
                                    "AdditiveObservationCenteredPolar",
                                    __field0,
                                )
                            }
                            FaultModelConfig::Clutter(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FaultModelConfig",
                                    3u32,
                                    "Clutter",
                                    __field0,
                                )
                            }
                            FaultModelConfig::Misdetection(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FaultModelConfig",
                                    4u32,
                                    "Misdetection",
                                    __field0,
                                )
                            }
                            FaultModelConfig::Misassociation(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FaultModelConfig",
                                    5u32,
                                    "Misassociation",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for FaultModelConfig {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 6",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "AdditiveRobotCentered" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "AdditiveRobotCenteredPolar" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "AdditiveObservationCenteredPolar" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "Clutter" => _serde::__private::Ok(__Field::__field3),
                                    "Misdetection" => _serde::__private::Ok(__Field::__field4),
                                    "Misassociation" => _serde::__private::Ok(__Field::__field5),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"AdditiveRobotCentered" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"AdditiveRobotCenteredPolar" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"AdditiveObservationCenteredPolar" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"Clutter" => _serde::__private::Ok(__Field::__field3),
                                    b"Misdetection" => _serde::__private::Ok(__Field::__field4),
                                    b"Misassociation" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<FaultModelConfig>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = FaultModelConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum FaultModelConfig",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                AdditiveRobotCenteredFaultConfig,
                                            >(__variant),
                                            FaultModelConfig::AdditiveRobotCentered,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                AdditiveRobotCenteredPolarFaultConfig,
                                            >(__variant),
                                            FaultModelConfig::AdditiveRobotCenteredPolar,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                AdditiveObservationCenteredPolarFaultConfig,
                                            >(__variant),
                                            FaultModelConfig::AdditiveObservationCenteredPolar,
                                        )
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                ClutterFaultConfig,
                                            >(__variant),
                                            FaultModelConfig::Clutter,
                                        )
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                MisdetectionFaultConfig,
                                            >(__variant),
                                            FaultModelConfig::Misdetection,
                                        )
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                MisassociationFaultConfig,
                                            >(__variant),
                                            FaultModelConfig::Misassociation,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "AdditiveRobotCentered",
                            "AdditiveRobotCenteredPolar",
                            "AdditiveObservationCenteredPolar",
                            "Clutter",
                            "Misdetection",
                            "Misassociation",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "FaultModelConfig",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<FaultModelConfig>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for FaultModelConfig {
                #[inline]
                fn clone(&self) -> FaultModelConfig {
                    match self {
                        FaultModelConfig::AdditiveRobotCentered(__self_0) => {
                            FaultModelConfig::AdditiveRobotCentered(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FaultModelConfig::AdditiveRobotCenteredPolar(__self_0) => {
                            FaultModelConfig::AdditiveRobotCenteredPolar(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FaultModelConfig::AdditiveObservationCenteredPolar(__self_0) => {
                            FaultModelConfig::AdditiveObservationCenteredPolar(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FaultModelConfig::Clutter(__self_0) => {
                            FaultModelConfig::Clutter(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FaultModelConfig::Misdetection(__self_0) => {
                            FaultModelConfig::Misdetection(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FaultModelConfig::Misassociation(__self_0) => {
                            FaultModelConfig::Misassociation(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for FaultModelConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    match &self {
                        FaultModelConfig::AdditiveRobotCentered(o) => {
                            if !::config_checker::__check_config(o, depth + 1) {
                                ret = false;
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                            "NOTE: ".blue(),
                                            "\u{21b3}",
                                            "AdditiveRobotCentered",
                                            "FaultModelConfig",
                                            depth_space,
                                        ),
                                    );
                                };
                            }
                        }
                        FaultModelConfig::AdditiveRobotCenteredPolar(o) => {
                            if !::config_checker::__check_config(o, depth + 1) {
                                ret = false;
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                            "NOTE: ".blue(),
                                            "\u{21b3}",
                                            "AdditiveRobotCenteredPolar",
                                            "FaultModelConfig",
                                            depth_space,
                                        ),
                                    );
                                };
                            }
                        }
                        FaultModelConfig::AdditiveObservationCenteredPolar(o) => {
                            if !::config_checker::__check_config(o, depth + 1) {
                                ret = false;
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                            "NOTE: ".blue(),
                                            "\u{21b3}",
                                            "AdditiveObservationCenteredPolar",
                                            "FaultModelConfig",
                                            depth_space,
                                        ),
                                    );
                                };
                            }
                        }
                        FaultModelConfig::Clutter(o) => {
                            if !::config_checker::__check_config(o, depth + 1) {
                                ret = false;
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                            "NOTE: ".blue(),
                                            "\u{21b3}",
                                            "Clutter",
                                            "FaultModelConfig",
                                            depth_space,
                                        ),
                                    );
                                };
                            }
                        }
                        FaultModelConfig::Misdetection(o) => {
                            if !::config_checker::__check_config(o, depth + 1) {
                                ret = false;
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                            "NOTE: ".blue(),
                                            "\u{21b3}",
                                            "Misdetection",
                                            "FaultModelConfig",
                                            depth_space,
                                        ),
                                    );
                                };
                            }
                        }
                        FaultModelConfig::Misassociation(o) => {
                            if !::config_checker::__check_config(o, depth + 1) {
                                ret = false;
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                            "NOTE: ".blue(),
                                            "\u{21b3}",
                                            "Misassociation",
                                            "FaultModelConfig",
                                            depth_space,
                                        ),
                                    );
                                };
                            }
                        }
                        _ => {}
                    };
                    ret
                }
            }
            pub fn make_fault_model_from_config(
                config: &FaultModelConfig,
                global_config: &SimulatorConfig,
                robot_name: &String,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Box<dyn FaultModel> {
                match &config {
                    FaultModelConfig::AdditiveRobotCentered(cfg) => {
                        Box::new(
                            AdditiveRobotCenteredFault::from_config(&cfg, va_factory),
                        ) as Box<dyn FaultModel>
                    }
                    FaultModelConfig::AdditiveRobotCenteredPolar(cfg) => {
                        Box::new(
                            AdditiveRobotCenteredPolarFault::from_config(
                                &cfg,
                                va_factory,
                            ),
                        ) as Box<dyn FaultModel>
                    }
                    FaultModelConfig::AdditiveObservationCenteredPolar(cfg) => {
                        Box::new(
                            AdditiveObservationCenteredPolarFault::from_config(
                                &cfg,
                                va_factory,
                            ),
                        ) as Box<dyn FaultModel>
                    }
                    FaultModelConfig::Clutter(cfg) => {
                        Box::new(ClutterFault::from_config(&cfg, va_factory))
                            as Box<dyn FaultModel>
                    }
                    FaultModelConfig::Misdetection(cfg) => {
                        Box::new(MisdetectionFault::from_config(&cfg, va_factory))
                            as Box<dyn FaultModel>
                    }
                    FaultModelConfig::Misassociation(cfg) => {
                        Box::new(
                            MisassociationFault::from_config(
                                &cfg,
                                global_config,
                                robot_name,
                                va_factory,
                            ),
                        ) as Box<dyn FaultModel>
                    }
                }
            }
            pub trait FaultModel: Debug + Sync + Send {
                fn add_faults(
                    &self,
                    time: f32,
                    period: f32,
                    obs_list: &mut Vec<SensorObservation>,
                    obs_type: SensorObservation,
                );
            }
        }
    }
}
pub mod simulator {
    /*!
Module serving the [`Simulator`] with the configuration and record structures.

The [`Simulator`] is the primary struct to be called to start the simulator,
the simulator can be used as follows:
```no_run
use std::path::Path;
use simba::simulator::Simulator;

fn main() {
    // Initialize the environment
    Simulator::init_environment();
    println!("Load configuration...");
    let mut simulator = Simulator::from_config_path(
        Path::new("config_example/config.yaml"),
        &None, //<- plugin API, to load external modules
    );

    // Show the simulator loaded configuration
    simulator.show();

    // Run the simulator for the time given in the configuration
    // It also save the results to json
    simulator.run();

    simulator.compute_results();
}

```


*/
    extern crate confy;
    use config_checker::macros::Check;
    use config_checker::ConfigCheckable;
    use egui::Color32;
    use pyo3::prelude::*;
    use serde_derive::{Deserialize, Serialize};
    use simba_macros::ToVec;
    use crate::gui::utils::{enum_combobox, path_finder};
    use crate::gui::UIComponent;
    use crate::utils::enum_tools::ToVec;
    use crate::api::internal_api::NodeClient;
    use crate::constants::TIME_ROUND;
    use crate::errors::{SimbaError, SimbaResult};
    use crate::logger::{init_log, is_enabled, LogLevel, LoggerConfig};
    use crate::networking::network_manager::NetworkManager;
    use crate::networking::service_manager::ServiceManager;
    use crate::node_factory::{
        ComputationUnitConfig, NodeFactory, NodeRecord, RobotConfig,
    };
    use crate::plugin_api::PluginAPI;
    use crate::state_estimators::state_estimator::State;
    use crate::stateful::Stateful;
    use crate::time_analysis::{self, TimeAnalysisConfig};
    use crate::utils::determinist_random_variable::DeterministRandomVariableFactory;
    use crate::node::Node;
    use crate::utils::time_ordered_data::TimeOrderedData;
    use core::f32;
    use std::collections::{BTreeMap, LinkedList};
    use std::path::{Path, PathBuf};
    use std::time::Duration;
    use colored::Colorize;
    use serde_json::{self, Value};
    use std::default::Default;
    use std::fs::{self, File};
    use std::io::prelude::*;
    use std::sync::{mpsc, Arc, Barrier, Condvar, Mutex, RwLock};
    use std::thread::{self, sleep, ThreadId};
    use log::{debug, error, info, warn};
    use pyo3::prepare_freethreaded_python;
    #[serde(default)]
    #[serde(deny_unknown_fields)]
    pub struct ResultConfig {
        /// Filename to save the results, in JSON format. The directory of this
        /// file is used to save the figures if results are computed.
        pub result_path: String,
        /// Show the matplotlib figures
        pub show_figures: bool,
        /// Path to the python analyse scrit.
        /// This script should have the following entry point:
        /// ```def analyse(result_data: Record, figure_path: str, figure_type: str)```
        /// If the option is none, the script is not run
        pub analyse_script: Option<String>,
        pub figures_path: Option<String>,
        pub python_params: Value,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ResultConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ResultConfig",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "result_path",
                    &self.result_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_figures",
                    &self.show_figures,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "analyse_script",
                    &self.analyse_script,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "figures_path",
                    &self.figures_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "python_params",
                    &self.python_params,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ResultConfig
        where
            ResultConfig: _serde::__private::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "result_path" => _serde::__private::Ok(__Field::__field0),
                            "show_figures" => _serde::__private::Ok(__Field::__field1),
                            "analyse_script" => _serde::__private::Ok(__Field::__field2),
                            "figures_path" => _serde::__private::Ok(__Field::__field3),
                            "python_params" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"result_path" => _serde::__private::Ok(__Field::__field0),
                            b"show_figures" => _serde::__private::Ok(__Field::__field1),
                            b"analyse_script" => _serde::__private::Ok(__Field::__field2),
                            b"figures_path" => _serde::__private::Ok(__Field::__field3),
                            b"python_params" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    ResultConfig: _serde::__private::Default,
                {
                    marker: _serde::__private::PhantomData<ResultConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    ResultConfig: _serde::__private::Default,
                {
                    type Value = ResultConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ResultConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.result_path,
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.show_figures,
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.analyse_script,
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.figures_path,
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Value,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.python_params,
                        };
                        _serde::__private::Ok(ResultConfig {
                            result_path: __field0,
                            show_figures: __field1,
                            analyse_script: __field2,
                            figures_path: __field3,
                            python_params: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Value> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "result_path",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_figures",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "analyse_script",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "figures_path",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "python_params",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                    );
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => __default.result_path,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => __default.show_figures,
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => __default.analyse_script,
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => __default.figures_path,
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => __default.python_params,
                        };
                        _serde::__private::Ok(ResultConfig {
                            result_path: __field0,
                            show_figures: __field1,
                            analyse_script: __field2,
                            figures_path: __field3,
                            python_params: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "result_path",
                    "show_figures",
                    "analyse_script",
                    "figures_path",
                    "python_params",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ResultConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ResultConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ResultConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ResultConfig",
                "result_path",
                &self.result_path,
                "show_figures",
                &self.show_figures,
                "analyse_script",
                &self.analyse_script,
                "figures_path",
                &self.figures_path,
                "python_params",
                &&self.python_params,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ResultConfig {
        #[inline]
        fn clone(&self) -> ResultConfig {
            ResultConfig {
                result_path: ::core::clone::Clone::clone(&self.result_path),
                show_figures: ::core::clone::Clone::clone(&self.show_figures),
                analyse_script: ::core::clone::Clone::clone(&self.analyse_script),
                figures_path: ::core::clone::Clone::clone(&self.figures_path),
                python_params: ::core::clone::Clone::clone(&self.python_params),
            }
        }
    }
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for ResultConfig {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            ret
        }
    }
    impl Default for ResultConfig {
        /// Default scenario configuration: no nodes.
        fn default() -> Self {
            Self {
                result_path: String::from("../results.json"),
                show_figures: true,
                analyse_script: None,
                figures_path: None,
                python_params: Value::Null,
            }
        }
    }
    pub enum TimeMode {
        Centralized,
        Decentralized,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TimeMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TimeMode::Centralized => "Centralized",
                    TimeMode::Decentralized => "Decentralized",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TimeMode {
        #[inline]
        fn clone(&self) -> TimeMode {
            match self {
                TimeMode::Centralized => TimeMode::Centralized,
                TimeMode::Decentralized => TimeMode::Decentralized,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TimeMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TimeMode::Centralized => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TimeMode",
                            0u32,
                            "Centralized",
                        )
                    }
                    TimeMode::Decentralized => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TimeMode",
                            1u32,
                            "Decentralized",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TimeMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Centralized" => _serde::__private::Ok(__Field::__field0),
                            "Decentralized" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Centralized" => _serde::__private::Ok(__Field::__field0),
                            b"Decentralized" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TimeMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TimeMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TimeMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TimeMode::Centralized)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TimeMode::Decentralized)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Centralized",
                    "Decentralized",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TimeMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TimeMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TimeMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TimeMode {
        #[inline]
        fn eq(&self, other: &TimeMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    /// Scenario configuration for the simulator.
    /// The Simulator configuration is the root of the scenario configuration.
    ///
    /// This config contains an item, `nodes`, which list the nodes [`NodeConfig`].
    ///
    /// ## Example in yaml:
    /// ```ignore
    /// nodes:
    ///     - NodeConfig 1
    ///     - NodeConfig 2
    /// ```
    ///
    ///
    #[serde(default)]
    #[serde(deny_unknown_fields)]
    pub struct SimulatorConfig {
        #[check]
        pub log: LoggerConfig,
        #[check]
        pub results: Option<ResultConfig>,
        #[serde(skip_serializing, skip_deserializing)]
        pub base_path: Box<Path>,
        pub max_time: f32,
        pub time_mode: TimeMode,
        #[check]
        pub time_analysis: TimeAnalysisConfig,
        pub random_seed: Option<f32>,
        /// List of the robots to run, with their specific configuration.
        #[check]
        pub robots: Vec<RobotConfig>,
        #[check]
        pub computation_units: Vec<ComputationUnitConfig>,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SimulatorConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SimulatorConfig",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "log",
                    &self.log,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "results",
                    &self.results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "max_time",
                    &self.max_time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "time_mode",
                    &self.time_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "time_analysis",
                    &self.time_analysis,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "random_seed",
                    &self.random_seed,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "robots",
                    &self.robots,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "computation_units",
                    &self.computation_units,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SimulatorConfig
        where
            SimulatorConfig: _serde::__private::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field3),
                            3u64 => _serde::__private::Ok(__Field::__field4),
                            4u64 => _serde::__private::Ok(__Field::__field5),
                            5u64 => _serde::__private::Ok(__Field::__field6),
                            6u64 => _serde::__private::Ok(__Field::__field7),
                            7u64 => _serde::__private::Ok(__Field::__field8),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 8",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "log" => _serde::__private::Ok(__Field::__field0),
                            "results" => _serde::__private::Ok(__Field::__field1),
                            "max_time" => _serde::__private::Ok(__Field::__field3),
                            "time_mode" => _serde::__private::Ok(__Field::__field4),
                            "time_analysis" => _serde::__private::Ok(__Field::__field5),
                            "random_seed" => _serde::__private::Ok(__Field::__field6),
                            "robots" => _serde::__private::Ok(__Field::__field7),
                            "computation_units" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"log" => _serde::__private::Ok(__Field::__field0),
                            b"results" => _serde::__private::Ok(__Field::__field1),
                            b"max_time" => _serde::__private::Ok(__Field::__field3),
                            b"time_mode" => _serde::__private::Ok(__Field::__field4),
                            b"time_analysis" => _serde::__private::Ok(__Field::__field5),
                            b"random_seed" => _serde::__private::Ok(__Field::__field6),
                            b"robots" => _serde::__private::Ok(__Field::__field7),
                            b"computation_units" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    SimulatorConfig: _serde::__private::Default,
                {
                    marker: _serde::__private::PhantomData<SimulatorConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    SimulatorConfig: _serde::__private::Default,
                {
                    type Value = SimulatorConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct SimulatorConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            LoggerConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.log,
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ResultConfig>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.results,
                        };
                        let __field2 = __default.base_path;
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            f32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.max_time,
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            TimeMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.time_mode,
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            TimeAnalysisConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.time_analysis,
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<f32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.random_seed,
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Vec<RobotConfig>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.robots,
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Vec<ComputationUnitConfig>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.computation_units,
                        };
                        _serde::__private::Ok(SimulatorConfig {
                            log: __field0,
                            results: __field1,
                            base_path: __field2,
                            max_time: __field3,
                            time_mode: __field4,
                            time_analysis: __field5,
                            random_seed: __field6,
                            robots: __field7,
                            computation_units: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<LoggerConfig> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<ResultConfig>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<f32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<TimeMode> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            TimeAnalysisConfig,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<f32>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Vec<RobotConfig>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<
                            Vec<ComputationUnitConfig>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("log"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            LoggerConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "results",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ResultConfig>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_time",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "time_mode",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TimeMode>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "time_analysis",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TimeAnalysisConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "random_seed",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<f32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("robots"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<RobotConfig>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "computation_units",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ComputationUnitConfig>,
                                        >(&mut __map)?,
                                    );
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => __default.log,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => __default.results,
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => __default.max_time,
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => __default.time_mode,
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => __default.time_analysis,
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => __default.random_seed,
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => __default.robots,
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => __default.computation_units,
                        };
                        _serde::__private::Ok(SimulatorConfig {
                            log: __field0,
                            results: __field1,
                            base_path: __default.base_path,
                            max_time: __field3,
                            time_mode: __field4,
                            time_analysis: __field5,
                            random_seed: __field6,
                            robots: __field7,
                            computation_units: __field8,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "log",
                    "results",
                    "max_time",
                    "time_mode",
                    "time_analysis",
                    "random_seed",
                    "robots",
                    "computation_units",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SimulatorConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SimulatorConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SimulatorConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "log",
                "results",
                "base_path",
                "max_time",
                "time_mode",
                "time_analysis",
                "random_seed",
                "robots",
                "computation_units",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.log,
                &self.results,
                &self.base_path,
                &self.max_time,
                &self.time_mode,
                &self.time_analysis,
                &self.random_seed,
                &self.robots,
                &&self.computation_units,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SimulatorConfig",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SimulatorConfig {
        #[inline]
        fn clone(&self) -> SimulatorConfig {
            SimulatorConfig {
                log: ::core::clone::Clone::clone(&self.log),
                results: ::core::clone::Clone::clone(&self.results),
                base_path: ::core::clone::Clone::clone(&self.base_path),
                max_time: ::core::clone::Clone::clone(&self.max_time),
                time_mode: ::core::clone::Clone::clone(&self.time_mode),
                time_analysis: ::core::clone::Clone::clone(&self.time_analysis),
                random_seed: ::core::clone::Clone::clone(&self.random_seed),
                robots: ::core::clone::Clone::clone(&self.robots),
                computation_units: ::core::clone::Clone::clone(&self.computation_units),
            }
        }
    }
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for SimulatorConfig {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            if !::config_checker::__check_config(&self.log, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "log",
                            "SimulatorConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.results, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "results",
                            "SimulatorConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.time_analysis, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "time_analysis",
                            "SimulatorConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.robots, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "robots",
                            "SimulatorConfig",
                            depth_space,
                        ),
                    );
                };
            }
            if !::config_checker::__check_config(&self.computation_units, depth + 1) {
                ret = false;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {4}  {1} From field `{2}` of `{3}`\n",
                            "NOTE: ".blue(),
                            "\u{21b3}",
                            "computation_units",
                            "SimulatorConfig",
                            depth_space,
                        ),
                    );
                };
            }
            ret
        }
    }
    impl Default for SimulatorConfig {
        /// Default scenario configuration: no nodes.
        fn default() -> Self {
            Self {
                log: LoggerConfig::default(),
                base_path: Box::from(Path::new(".")),
                results: None,
                time_analysis: TimeAnalysisConfig::default(),
                random_seed: None,
                robots: Vec::new(),
                computation_units: Vec::new(),
                max_time: 60.,
                time_mode: TimeMode::Centralized,
            }
        }
    }
    /// One time record of a node. The record is the state of the node with the
    /// associated time.
    ///
    /// This is a line for one node ([`NodeRecord`]) at a given time.
    pub struct Record {
        /// Time of the record.
        pub time: f32,
        /// Record of a node.
        pub node: NodeRecord,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Record {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Record",
                "time",
                &self.time,
                "node",
                &&self.node,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Record {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Record",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "time",
                    &self.time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "node",
                    &self.node,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Record {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "time" => _serde::__private::Ok(__Field::__field0),
                            "node" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"time" => _serde::__private::Ok(__Field::__field0),
                            b"node" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Record>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Record;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Record",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            f32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Record with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            NodeRecord,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Record with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Record {
                            time: __field0,
                            node: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<NodeRecord> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("time"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("node"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<NodeRecord>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("time")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("node")?
                            }
                        };
                        _serde::__private::Ok(Record {
                            time: __field0,
                            node: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["time", "node"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Record",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Record>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Results {
        pub config: SimulatorConfig,
        pub records: Vec<Record>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Results {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Results",
                "config",
                &self.config,
                "records",
                &&self.records,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Results {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Results",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "config",
                    &self.config,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "records",
                    &self.records,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Results {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "config" => _serde::__private::Ok(__Field::__field0),
                            "records" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"config" => _serde::__private::Ok(__Field::__field0),
                            b"records" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Results>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Results;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Results",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            SimulatorConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Results with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<Record>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Results with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Results {
                            config: __field0,
                            records: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<SimulatorConfig> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<Record>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("config"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SimulatorConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "records",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Record>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("config")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("records")?
                            }
                        };
                        _serde::__private::Ok(Results {
                            config: __field0,
                            records: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["config", "records"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Results",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Results>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    static THREAD_IDS: RwLock<Vec<ThreadId>> = RwLock::new(Vec::new());
    static THREAD_NAMES: RwLock<Vec<String>> = RwLock::new(Vec::new());
    static THREAD_TIMES: RwLock<Vec<f32>> = RwLock::new(Vec::new());
    static EXCLUDE_NODES: RwLock<Vec<String>> = RwLock::new(Vec::new());
    static INCLUDE_NODES: RwLock<Vec<String>> = RwLock::new(Vec::new());
    pub struct SimulatorAsyncApi {
        pub current_time: Arc<Mutex<BTreeMap<String, f32>>>,
        pub records: Arc<Mutex<mpsc::Receiver<Record>>>,
    }
    struct SimulatorAsyncApiServer {
        pub current_time: Arc<Mutex<BTreeMap<String, f32>>>,
        pub records: mpsc::Sender<Record>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SimulatorAsyncApiServer {
        #[inline]
        fn clone(&self) -> SimulatorAsyncApiServer {
            SimulatorAsyncApiServer {
                current_time: ::core::clone::Clone::clone(&self.current_time),
                records: ::core::clone::Clone::clone(&self.records),
            }
        }
    }
    pub struct TimeCv {
        pub finished_nodes: Mutex<usize>,
        pub circulating_messages: Mutex<usize>,
        pub condvar: Condvar,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TimeCv {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TimeCv",
                "finished_nodes",
                &self.finished_nodes,
                "circulating_messages",
                &self.circulating_messages,
                "condvar",
                &&self.condvar,
            )
        }
    }
    impl TimeCv {
        pub fn new() -> Self {
            Self {
                finished_nodes: Mutex::new(0),
                circulating_messages: Mutex::new(0),
                condvar: Condvar::new(),
            }
        }
    }
    /// This is the central structure which manages the run of the scenario.
    ///
    /// To run the scenario, there are two mandatory steps:
    /// * Load the config using [`Simulator::from_config_path`] (from a file), or using
    /// [`Simulator::from_config`] with the [`SimulatorConfig`] and [`SimulatorMetaConfig`]
    /// structs directly.
    /// * Run the scenario, once the config is loaded, the scenario can be run using
    /// [`Simulator::run`].
    ///
    /// Optionnal steps are the following:
    /// * Initialize the environment with [`Simulator::init_environment`]. It initialize the logging environment.
    /// * Use [`Simulator::show`] to print in the console the configuration loaded.
    /// * Get the results with [`Simulator::get_results`], providing the full list of all [`Record`]s.
    ///
    /// ## Example
    /// ```no_run
    /// use log::info;
    /// use simba::simulator::Simulator;
    /// use std::path::Path;
    ///
    /// fn main() {
    ///
    ///     // Initialize the environment, essentially the logging part
    ///     Simulator::init_environment();
    ///     info!("Load configuration...");
    ///     let mut simulator = Simulator::from_config_path(
    ///         Path::new("config_example/config.yaml"), //<- configuration path
    ///         &None,                                      //<- plugin API, to load external modules
    ///     );
    ///
    ///     // Show the simulator loaded configuration
    ///     simulator.show();
    ///
    ///     // It also save the results to "result.json",
    ///     simulator.run();
    ///
    ///     // compute the results and show the figures.
    ///     simulator.compute_results();
    ///
    /// }
    ///
    /// ```
    pub struct Simulator {
        /// List of the [`Node`]. Using `Arc` and `RwLock` for multithreading.
        nodes: Vec<Node>,
        /// Scenario configuration.
        config: SimulatorConfig,
        /// Network Manager
        network_manager: NetworkManager,
        /// Factory for components to make random variables generators
        determinist_va_factory: DeterministRandomVariableFactory,
        time_cv: Arc<TimeCv>,
        common_time: Option<Arc<Mutex<f32>>>,
        async_api: Option<Arc<SimulatorAsyncApi>>,
        async_api_server: Option<SimulatorAsyncApiServer>,
        node_apis: BTreeMap<String, NodeClient>,
    }
    impl Simulator {
        /// Create a new [`Simulator`] with no nodes, and empty config.
        pub fn new() -> Simulator {
            let rng = rand::random();
            let time_cv = Arc::new(TimeCv::new());
            Simulator {
                nodes: Vec::new(),
                config: SimulatorConfig::default(),
                network_manager: NetworkManager::new(time_cv.clone()),
                determinist_va_factory: DeterministRandomVariableFactory::new(rng),
                time_cv,
                async_api: None,
                async_api_server: None,
                common_time: Some(Arc::new(Mutex::new(f32::INFINITY))),
                node_apis: BTreeMap::new(),
            }
        }
        /// Load the config from a file compatible with [`confy`]. Initialize the [`Simulator`].
        ///
        /// ## Arguments
        /// * `config_path` - `Path` to the config file (see example in [`config_example/config.yaml`]).
        /// * `plugin_api`  - Provide an implementation of [`PluginAPI`] if you want to use external modules.
        /// * `result_path` - Path to the file to save the results.
        /// * `compute_results` - Enable the computation of the results, using python script.
        /// * `no_gui` - Disable the GUI, and the opening of the figures.
        ///
        /// ## Return
        /// Returns a [`Simulator`] ready to be run.
        pub fn from_config_path(
            config_path: &Path,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
        ) -> Simulator {
            let mut sim = Simulator::new();
            sim.load_config_path(config_path, plugin_api);
            sim
        }
        /// Load the config from structure instance.
        ///
        /// ## Arguments
        /// * `config` - Scenario configuration ([`SimulatorConfig`]).
        /// * `plugin_api`  - Provide an implementation of [`PluginAPI`] if you want to use external modules.
        /// * `meta_config` - Simulator run configuration ([`SimulatorMetaConfig`]).
        ///
        /// ## Return
        /// Returns a [`Simulator`] ready to be run.
        pub fn from_config(
            config: &SimulatorConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
        ) -> Simulator {
            let mut simulator = Simulator::new();
            simulator.load_config(config, plugin_api);
            simulator
        }
        pub fn reset(&mut self, plugin_api: &Option<Box<&dyn PluginAPI>>) {
            self.nodes = Vec::new();
            self.time_cv = Arc::new(TimeCv::new());
            self.network_manager = NetworkManager::new(self.time_cv.clone());
            let config = self.config.clone();
            self.common_time = match &config.time_mode {
                TimeMode::Centralized => Some(Arc::new(Mutex::new(f32::INFINITY))),
                TimeMode::Decentralized => None,
            };
            let mut service_managers = BTreeMap::new();
            for robot_config in &config.robots {
                self.add_robot(robot_config, plugin_api, &config);
                let node = self.nodes.last().unwrap();
                service_managers.insert(node.name(), node.service_manager());
            }
            for computation_unit_config in &config.computation_units {
                self.add_computation_unit(computation_unit_config, plugin_api, &config);
                let node = self.nodes.last().unwrap();
                service_managers.insert(node.name(), node.service_manager());
            }
            for node in self.nodes.iter_mut() {
                {
                    ::std::io::_print(
                        format_args!("Finishing initialization of {0}\n", node.name()),
                    );
                };
                self.node_apis
                    .insert(node.name(), node.post_creation_init(&service_managers));
            }
        }
        pub fn load_config_path(
            &mut self,
            config_path: &Path,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
        ) {
            {
                ::std::io::_print(
                    format_args!("Load configuration from {0:?}\n", config_path),
                );
            };
            let mut config: SimulatorConfig = match confy::load_path(config_path) {
                Ok(config) => config,
                Err(error) => {
                    {
                        ::std::io::_print(
                            format_args!(
                                "ERROR: Error from Confy while loading the config file : {0}\n",
                                error,
                            ),
                        );
                    };
                    return;
                }
            };
            config.base_path = Box::from(config_path.parent().unwrap());
            config.time_analysis.output_path = config
                .base_path
                .as_ref()
                .join(&config.time_analysis.output_path)
                .to_str()
                .unwrap()
                .to_string();
            self.load_config(&config, plugin_api);
        }
        pub fn load_config(
            &mut self,
            config: &SimulatorConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
        ) {
            {
                ::std::io::_print(format_args!("Checking configuration:\n"));
            };
            if config.check() {
                let mut network_0 = false;
                for robot in &config.robots {
                    if robot.network.reception_delay == 0. {
                        network_0 = true;
                        break;
                    }
                }
                if !network_0 {
                    for cu in &config.computation_units {
                        if cu.network.reception_delay == 0. {
                            network_0 = true;
                            break;
                        }
                    }
                }
                if network_0 {
                    {
                        ::std::io::_print(
                            format_args!(
                                "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nWARNING: Network with 0 reception delay is not stable yet: messages can be treated later or deadlock can occur.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
                            ),
                        );
                    };
                }
                {
                    ::std::io::_print(format_args!("Config valid\n"));
                };
            } else {
                {
                    ::core::panicking::panic_fmt(format_args!("Error in config"));
                };
            }
            Self::init_log(&config.log);
            self.config = config.clone();
            if let Some(seed) = config.random_seed {
                self.determinist_va_factory.global_seed = seed;
            } else {
                self.config.random_seed = Some(self.determinist_va_factory.global_seed);
            }
            time_analysis::init_from_config(&self.config.time_analysis);
            self.reset(plugin_api);
        }
        pub fn config(&self) -> SimulatorConfig {
            self.config.clone()
        }
        /// Initialize the simulator environment.
        ///
        /// - start the logging environment.
        /// - Time analysis setup
        pub fn init_environment() {
            time_analysis::set_node_name("simulator".to_string());
        }
        fn init_log(log_config: &LoggerConfig) {
            init_log(log_config);
            THREAD_IDS.write().unwrap().push(thread::current().id());
            THREAD_NAMES.write().unwrap().push("simulator".to_string());
            THREAD_TIMES.write().unwrap().push(0.);
            EXCLUDE_NODES.write().unwrap().clone_from(&log_config.excluded_nodes);
            INCLUDE_NODES.write().unwrap().clone_from(&log_config.included_nodes);
            if log_config.included_nodes.len() > 0 {
                INCLUDE_NODES.write().unwrap().push("simulator".to_string());
            }
            if env_logger::builder()
                .target(env_logger::Target::Stdout)
                .format(|buf, record| {
                    let thread_idx = THREAD_IDS
                        .read()
                        .unwrap()
                        .iter()
                        .position(|&x| x == thread::current().id())
                        .unwrap_or(0);
                    let thread_name = THREAD_NAMES.read().unwrap()[thread_idx].clone();
                    if EXCLUDE_NODES.read().unwrap().contains(&thread_name) {
                        return Ok(());
                    }
                    let included_nodes = INCLUDE_NODES.read().unwrap();
                    if included_nodes.len() > 0 && !included_nodes.contains(&thread_name)
                    {
                        return Ok(());
                    }
                    drop(included_nodes);
                    let mut time = "".to_string();
                    if thread_idx != 0 {
                        let time_f32 = THREAD_TIMES.read().unwrap()[thread_idx];
                        time = ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("{0:.4}", time_f32),
                            );
                            res
                        }) + ", ";
                    }
                    buf.write_fmt(
                        format_args!(
                            "[{0:5}][{1}{2}] {3}\n",
                            match record.level() {
                                log::Level::Error => "ERROR".red(),
                                log::Level::Warn => "WARN".yellow(),
                                log::Level::Info => "INFO".green(),
                                log::Level::Debug => "DEBUG".blue(),
                                log::Level::Trace => "TRACE".black(),
                            },
                            time,
                            &thread_name,
                            record.args(),
                        ),
                    )
                })
                .format_timestamp(None)
                .format_module_path(false)
                .format_target(false)
                .filter_level(log_config.log_level.clone().into())
                .try_init()
                .is_err()
            {
                {
                    ::std::io::_print(
                        format_args!("ERROR during log initialization!\n"),
                    );
                };
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "Logging initialized at level: {0}\n",
                            log_config.log_level,
                        ),
                    );
                };
            }
        }
        /// Add a [`Node`] of type [`Robot`](NodeType::Robot) to the [`Simulator`].
        ///
        /// This function add the [`Node`] to the [`Simulator`] list and to the [`NetworkManager`].
        /// It also adds the [`NetworkManager`] to the new [`Node`].
        ///
        /// ## Argumants
        /// * `robot_config` - Configuration of the [`Node`].
        /// * `plugin_api` - Implementation of [`PluginAPI`] for the use of external modules.
        /// * `meta_config` - Configuration of the simulation run.
        fn add_robot(
            &mut self,
            robot_config: &RobotConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
        ) {
            self.nodes
                .push(
                    NodeFactory::make_robot(
                        robot_config,
                        plugin_api,
                        &global_config,
                        &self.determinist_va_factory,
                        self.time_cv.clone(),
                    ),
                );
            self.network_manager.register_node_network(self.nodes.last_mut().unwrap());
        }
        fn add_computation_unit(
            &mut self,
            computation_unit_config: &ComputationUnitConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
        ) {
            self.nodes
                .push(
                    NodeFactory::make_computation_unit(
                        computation_unit_config,
                        plugin_api,
                        &global_config,
                        &self.determinist_va_factory,
                        self.time_cv.clone(),
                    ),
                );
            self.network_manager.register_node_network(self.nodes.last_mut().unwrap());
        }
        /// Simply print the Simulator state, using the info channel and the debug print.
        pub fn show(&self) {
            {
                ::std::io::_print(format_args!("Simulator:\n"));
            };
            for node in self.nodes.iter() {
                {
                    ::std::io::_print(format_args!("- {0:?}\n", node));
                };
            }
        }
        pub fn set_max_time(&mut self, max_time: f32) {
            self.config.max_time = max_time;
        }
        /// Run the scenario until the given time.
        ///
        /// This function starts one thread by [`Node`]. It waits that the thread finishes.
        ///
        /// After the scenario is done, the results are saved, and they are analysed, following
        /// the configuration give ([`SimulatorMetaConfig`]).
        pub fn run(&mut self) {
            let mut handles = ::alloc::vec::Vec::new();
            let max_time = self.config.max_time;
            let nb_nodes = self.nodes.len();
            let barrier = Arc::new(Barrier::new(nb_nodes));
            let finishing_cv = Arc::new((Mutex::new(0usize), Condvar::new()));
            while let Some(node) = self.nodes.pop() {
                let i = self.nodes.len();
                let new_max_time = max_time.clone();
                let time_cv = self.time_cv.clone();
                let async_api_server = self.async_api_server.clone();
                let common_time = match &self.common_time {
                    Some(ct) => Some(ct.clone()),
                    None => None,
                };
                let finishing_cv_clone = finishing_cv.clone();
                let barrier_clone = barrier.clone();
                let handle = thread::spawn(move || -> SimbaResult<Node> {
                    let ret = Self::run_one_node(
                        node,
                        new_max_time,
                        nb_nodes,
                        i,
                        time_cv,
                        async_api_server,
                        common_time,
                        barrier_clone,
                    );
                    *finishing_cv_clone.0.lock().unwrap() += 1;
                    finishing_cv_clone.1.notify_all();
                    ret
                });
                handles.push(handle);
            }
            self.simulator_spin(finishing_cv, nb_nodes);
            for handle in handles {
                self.nodes.push(handle.join().unwrap().expect("Node not returned"));
            }
            self.save_results();
        }
        /// Returns the list of all [`Record`]s produced by [`Simulator::run`].
        pub fn get_results(&self) -> Vec<Record> {
            let mut records = Vec::new();
            for node in self.nodes.iter() {
                let node_history = node.record_history();
                for (time, record) in node_history.iter() {
                    records
                        .push(Record {
                            time: time.clone(),
                            node: record.clone(),
                        });
                }
            }
            records
        }
        /// Save the results to the file given during the configuration.
        ///
        /// If the configuration of the [`Simulator`] do not contain a result path, no results are saved.
        fn save_results(&mut self) {
            if self.config.results.is_none() {
                return;
            }
            let result_config = self.config.results.clone().unwrap();
            let filename = result_config.result_path;
            let filename = self.config.base_path.as_ref().join(filename);
            time_analysis::save_results();
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Saving results to {0}",
                                filename.to_str().unwrap_or_default(),
                            ),
                            lvl,
                            &(
                                "simba::simulator",
                                "simba::simulator",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let mut recording_file = File::create(filename)
                .expect("Impossible to create record file");
            recording_file.write(b"{\"config\": ").unwrap();
            serde_json::to_writer(&recording_file, &self.config)
                .expect("Error during json serialization");
            recording_file.write(b",\n\"records\": [\n").unwrap();
            let results = self.get_results();
            let mut first_row = true;
            for row in &results {
                if first_row {
                    first_row = false;
                } else {
                    recording_file.write(b",\n").unwrap();
                }
                serde_json::to_writer(
                        &recording_file,
                        &Record {
                            time: row.time.clone(),
                            node: row.node.clone(),
                        },
                    )
                    .expect("Error during json serialization");
            }
            recording_file.write(b"\n]}").unwrap();
        }
        pub fn load_results_and_analyse(&mut self) {
            if self.config.results.is_none() {
                return;
            }
            let result_config = self.config.results.clone().unwrap();
            let filename = result_config.result_path;
            let filename = self.config.base_path.as_ref().join(filename);
            let mut recording_file = File::open(filename)
                .expect("Impossible to open record file");
            let mut content = String::new();
            recording_file
                .read_to_string(&mut content)
                .expect("Impossible to read record file");
            let results: Results = serde_json::from_str(&content)
                .expect("Error during json parsing");
            self._compute_results(results.records, &results.config);
        }
        /// Wait the end of the simulation. If other node send messages, the simulation
        /// will go back to the time of the last message received.
        fn wait_the_end(
            node: &Node,
            max_time: f32,
            time_cv: &TimeCv,
            nb_nodes: usize,
        ) -> bool {
            let mut lk = time_cv.finished_nodes.lock().unwrap();
            *lk += 1;
            if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Increase finished nodes: {0}", *lk),
                                lvl,
                                &(
                                    "simba::simulator",
                                    "simba::simulator",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            if *lk == nb_nodes {
                time_cv.condvar.notify_all();
                *lk = 0;
                return true;
            }
            loop {
                let buffered_msgs = node.process_messages();
                if buffered_msgs > 0 {
                    *lk -= 1;
                    if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "[wait_the_end] Messages to process: continue",
                                        ),
                                        lvl,
                                        &(
                                            "simba::simulator",
                                            "simba::simulator",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    return false;
                }
                if is_enabled(crate::logger::InternalLog::NodeRunningDetailed) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("[wait_the_end] Wait for others"),
                                    lvl,
                                    &(
                                        "simba::simulator",
                                        "simba::simulator",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                lk = time_cv.condvar.wait(lk).unwrap();
                let circulating_messages = time_cv.circulating_messages.lock().unwrap();
                if *lk == nb_nodes && *circulating_messages == 0 {
                    return true;
                } else {
                    *lk -= 1;
                    node.process_messages();
                    let next_time = node.next_time_step().0;
                    if next_time < max_time {
                        return false;
                    }
                    *lk += 1;
                }
            }
        }
        /// Run the loop for the given `node` until reaching `max_time`.
        ///
        /// ## Arguments
        /// * `node` - Node to be run.
        /// * `max_time` - Time to stop the loop.
        fn run_one_node(
            mut node: Node,
            max_time: f32,
            nb_nodes: usize,
            node_idx: usize,
            time_cv: Arc<TimeCv>,
            async_api_server: Option<SimulatorAsyncApiServer>,
            common_time: Option<Arc<Mutex<f32>>>,
            barrier: Arc<Barrier>,
        ) -> SimbaResult<Node> {
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Start thread of node {0}", node.name()),
                            lvl,
                            &(
                                "simba::simulator",
                                "simba::simulator",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let mut thread_ids = THREAD_IDS.write().unwrap();
            thread_ids.push(thread::current().id());
            let thread_idx = thread_ids.len() - 1;
            THREAD_NAMES.write().unwrap().push(node.name());
            THREAD_TIMES.write().unwrap().push(0.);
            drop(thread_ids);
            time_analysis::set_node_name(node.name());
            let mut previous_time = 0.;
            loop {
                let (mut next_time, mut read_only) = node.next_time_step();
                if let Some(api) = &async_api_server {
                    api.current_time.lock().unwrap().insert(node.name(), next_time);
                }
                if let Some(common_time_arc) = &common_time {
                    {
                        if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "Get common time (next_time is {0})",
                                                next_time,
                                            ),
                                            lvl,
                                            &(
                                                "simba::simulator",
                                                "simba::simulator",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                        let mut unlocked_common_time = common_time_arc.lock().unwrap();
                        if *unlocked_common_time > next_time {
                            *unlocked_common_time = next_time;
                            if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                                {
                                    {
                                        let lvl = ::log::Level::Debug;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api::log(
                                                { ::log::__private_api::GlobalLogger },
                                                format_args!("Set common time"),
                                                lvl,
                                                &(
                                                    "simba::simulator",
                                                    "simba::simulator",
                                                    ::log::__private_api::loc(),
                                                ),
                                                (),
                                            );
                                        }
                                    }
                                };
                            }
                        }
                    }
                    let mut lk = time_cv.finished_nodes.lock().unwrap();
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Got CV lock"),
                                        lvl,
                                        &(
                                            "simba::simulator",
                                            "simba::simulator",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    *lk += 1;
                    time_cv.condvar.notify_all();
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Waiting for others... (next_time is {0})",
                                            next_time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::simulator",
                                            "simba::simulator",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    loop {
                        let buffered_msgs = node.process_messages();
                        if buffered_msgs > 0 {
                            *lk -= 1;
                            node.handle_messages(previous_time);
                            (next_time, read_only) = node.next_time_step();
                            {
                                let mut unlocked_common_time = common_time_arc
                                    .lock()
                                    .unwrap();
                                if *unlocked_common_time > next_time {
                                    *unlocked_common_time = next_time;
                                    if is_enabled(
                                        crate::logger::InternalLog::NodeSyncDetailed,
                                    ) {
                                        {
                                            {
                                                let lvl = ::log::Level::Debug;
                                                if lvl <= ::log::STATIC_MAX_LEVEL
                                                    && lvl <= ::log::max_level()
                                                {
                                                    ::log::__private_api::log(
                                                        { ::log::__private_api::GlobalLogger },
                                                        format_args!("Set common time at {0}", next_time),
                                                        lvl,
                                                        &(
                                                            "simba::simulator",
                                                            "simba::simulator",
                                                            ::log::__private_api::loc(),
                                                        ),
                                                        (),
                                                    );
                                                }
                                            }
                                        };
                                    }
                                }
                            }
                            *lk += 1;
                            time_cv.condvar.notify_all();
                        }
                        let circulating_messages = time_cv
                            .circulating_messages
                            .lock()
                            .unwrap();
                        if *lk == nb_nodes && *circulating_messages == 0 {
                            break;
                        } else if is_enabled(
                            crate::logger::InternalLog::NodeSyncDetailed,
                        ) {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "Finished nodes = {0}/{2} and circulating messages = {1}",
                                                *lk,
                                                *circulating_messages,
                                                nb_nodes,
                                            ),
                                            lvl,
                                            &(
                                                "simba::simulator",
                                                "simba::simulator",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                        std::mem::drop(circulating_messages);
                        if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Wait CV"),
                                            lvl,
                                            &(
                                                "simba::simulator",
                                                "simba::simulator",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                        lk = time_cv.condvar.wait(lk).unwrap();
                        if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("End of CV wait"),
                                            lvl,
                                            &(
                                                "simba::simulator",
                                                "simba::simulator",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                    }
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Wait finished -- Release CV lock"),
                                        lvl,
                                        &(
                                            "simba::simulator",
                                            "simba::simulator",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    std::mem::drop(lk);
                    next_time = *common_time_arc.lock().unwrap();
                    if is_enabled(crate::logger::InternalLog::NodeSyncDetailed) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Barrier... final next_time is {0}",
                                            next_time,
                                        ),
                                        lvl,
                                        &(
                                            "simba::simulator",
                                            "simba::simulator",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    barrier.wait();
                    *common_time_arc.lock().unwrap() = f32::INFINITY;
                    *time_cv.finished_nodes.lock().unwrap() = 0;
                    barrier.wait();
                    if next_time > max_time {
                        break;
                    }
                } else if next_time > max_time {
                    if Self::wait_the_end(&node, max_time, &time_cv, nb_nodes) {
                        break;
                    }
                    (next_time, _) = node.next_time_step();
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Return to time {0}", next_time),
                                    lvl,
                                    &(
                                        "simba::simulator",
                                        "simba::simulator",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let (own_next_time, own_read_only) = node.next_time_step();
                THREAD_TIMES.write().unwrap()[thread_idx] = next_time;
                if (own_next_time - next_time).abs() < TIME_ROUND {
                    node.run_next_time_step(next_time, own_read_only);
                    if own_read_only {
                        node.set_in_state(previous_time);
                    } else {
                        if let Some(api) = &async_api_server {
                            let record = Record {
                                time: next_time,
                                node: node.record(),
                            };
                            api.records.send(record).unwrap();
                        }
                        previous_time = next_time;
                    }
                } else {
                    previous_time = next_time;
                }
            }
            Ok(node)
        }
        fn simulator_spin(
            &mut self,
            finishing_cv: Arc<(Mutex<usize>, Condvar)>,
            nb_nodes: usize,
        ) {
            let mut node_states: BTreeMap<String, TimeOrderedData<State>> = BTreeMap::new();
            for (k, _) in self.node_apis.iter() {
                node_states.insert(k.clone(), TimeOrderedData::<State>::new());
            }
            loop {
                for (node_name, node_api) in self.node_apis.iter() {
                    if let Some(state_update) = &node_api.state_update {
                        if let Ok((time, state)) = state_update.try_recv() {
                            node_states
                                .get_mut(node_name)
                                .expect(
                                    ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!("Unknown node {0}", node_name),
                                            );
                                            res
                                        })
                                        .as_str(),
                                )
                                .insert(time, state, true);
                        }
                    }
                }
                self.network_manager.process_messages(&node_states);
                if *finishing_cv.0.lock().unwrap() == nb_nodes {
                    return;
                }
            }
        }
        pub fn compute_results(&self) {
            let results = self.get_results();
            self._compute_results(results, &self.config);
        }
        /// Compute the results from the file where it was saved before.
        ///
        /// If the [`Simulator`] config disabled the computation of the results, this function
        /// does nothing.
        fn _compute_results(&self, results: Vec<Record>, config: &SimulatorConfig) {
            if self.config.results.is_none()
                || self.config.results.as_ref().unwrap().analyse_script.is_none()
            {
                return;
            }
            let result_config = self.config.results.clone().unwrap();
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Starting result analyse..."),
                            lvl,
                            &(
                                "simba::simulator",
                                "simba::simulator",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let show_figures = result_config.show_figures;
            prepare_freethreaded_python();
            let json_results = serde_json::to_string(&results)
                .expect("Error during converting results to json");
            let json_config = serde_json::to_string(&config)
                .expect("Error during converting results to json");
            let show_figure_py = r#"
import matplotlib.pyplot as plt

def show():
    plt.show()
"#;
            let convert_to_dict = r#"
import json
class NoneDict(dict):
    """ dict subclass that returns a value of None for missing keys instead
        of raising a KeyError. Note: doesn't add item to dictionary.
    """
    def __missing__(self, key):
        return None


def converter(decoded_dict):
    """ Convert any None values in decoded dict into empty NoneDict's. """
    return {k: NoneDict() if v is None else v for k,v in decoded_dict.items()}

def convert(records):
    return json.loads(records, object_hook=converter)
"#;
            let script_path = self
                .config
                .base_path
                .as_ref()
                .join(&result_config.analyse_script.unwrap());
            let python_script = fs::read_to_string(script_path.clone())
                .expect(
                    ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "File not found: {0}",
                                    script_path.to_str().unwrap(),
                                ),
                            );
                            res
                        })
                        .as_str(),
                );
            let res = Python::with_gil(|py| -> PyResult<()> {
                let script = PyModule::from_code_bound(py, &convert_to_dict, "", "")?;
                let convert_fn: Py<PyAny> = script.getattr("convert")?.into();
                let result_dict = convert_fn.call_bound(py, (json_results,), None)?;
                let config_dict = convert_fn.call_bound(py, (json_config,), None)?;
                let param_dict = convert_fn
                    .call_bound(py, (&result_config.python_params.to_string(),), None)?;
                let script = PyModule::from_code_bound(py, &python_script, "", "")?;
                let analyse_fn: Py<PyAny> = script.getattr("analyse")?.into();
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Analyse the results..."),
                                lvl,
                                &(
                                    "simba::simulator",
                                    "simba::simulator",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let figure_path;
                if let Some(p) = &result_config.figures_path {
                    figure_path = self.config.base_path.as_ref().join(p);
                    fs::create_dir_all(&figure_path)
                        .expect(
                            ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Impossible to create figure directory ({0:#?})",
                                            &figure_path,
                                        ),
                                    );
                                    res
                                })
                                .as_str(),
                        );
                } else {
                    figure_path = PathBuf::new();
                }
                let res = analyse_fn
                    .call_bound(
                        py,
                        (result_dict, config_dict, figure_path, ".pdf", param_dict),
                        None,
                    );
                if let Err(err) = res {
                    err.display(py);
                    return Err(err);
                }
                if show_figures {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Showing figures..."),
                                    lvl,
                                    &(
                                        "simba::simulator",
                                        "simba::simulator",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let show_script = PyModule::from_code_bound(
                        py,
                        &show_figure_py,
                        "",
                        "",
                    )?;
                    let show_fn: Py<PyAny> = show_script.getattr("show")?.into();
                    show_fn.call_bound(py, (), None)?;
                }
                Ok(())
            });
            if let Some(err) = res.err() {
                {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("{0}", err),
                                lvl,
                                &(
                                    "simba::simulator",
                                    "simba::simulator",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
        }
        pub fn get_async_api(&mut self) -> Arc<SimulatorAsyncApi> {
            if self.async_api_server.is_none() {
                let map = Arc::new(Mutex::new(BTreeMap::new()));
                let (records_tx, records_rx) = mpsc::channel();
                self.async_api_server = Some(SimulatorAsyncApiServer {
                    current_time: Arc::clone(&map),
                    records: records_tx,
                });
                self.async_api = Some(
                    Arc::new(SimulatorAsyncApi {
                        current_time: Arc::clone(&map),
                        records: Arc::new(Mutex::new(records_rx)),
                    }),
                );
            }
            self.async_api.as_ref().unwrap().clone()
        }
    }
}
pub mod state_estimators {
    /*!
Module providing different strategies for the state estimation.

To use an external state estimator (in Rust), use [`external_estimator`]
and implement a specification for [`PluginAPI`](crate::plugin_api::PluginAPI).

## How to create a new (internal) state estimation strategy
To create a new state estimation strategy, here are the required steps.

1) **Make a configuration**
Your new strategy should define a Config struct, such as
[`PerfectEstimator`](crate::state_estimators::perfect_estimator::PerfectEstimator),
with Serialize, Deserialize, Debug, Clone and Default traits.  Add this new Config to
[`StateEstimatorConfig`](state_estimator::StateEstimatorConfig) enumeration, and to the match
patterns in [`make_state_estimator_from_config`](state_estimator::make_state_estimator_from_config)
so that the right strategy is created.

2) **Make a new Record**
Your new strategy should define a Record struct, such as
[`PerfectEstimator`](crate::state_estimators::perfect_estimator::PerfectEstimator),
with Serialize, Deserialize, Debug and Clone traits.

3) **Implement the Trait**
Implement the trait methods.

4) **Implement the Stateful trait**
Don't forget to implement the [`Stateful`](crate::stateful::Stateful) trait, with the newly created
Record struct as generic type.
*/
    pub mod external_estimator {
        /*!
Module providing the interface to use external [`StateEstimator`].

To make your own external state estimation strategy, the simulator should
be used as a library (see [dedicated page](crate::plugin_api)).

Your own external state estimation strategy is made using the
[`PluginAPI::get_state_estimator`] function.

For the [`Stateful`] trait, the generic type is [`StateEstimatorRecord`],
and your implementation should return a [`StateEstimatorRecord::External`]
type. The value inside is a [`serde_json::Value`]. Use [`serde_json::to_value`]
and [`serde_json::from_value`] to make the bridge to your own Record struct.
*/
        use config_checker::macros::Check;
        use pyo3::{pyclass, pymethods};
        use serde_json::Value;
        use super::state_estimator::{State, StateEstimator};
        use crate::constants::TIME_ROUND;
        use crate::simulator::SimulatorConfig;
        use crate::stateful::Stateful;
        use crate::utils::maths::round_precision;
        use crate::{
            plugin_api::PluginAPI,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use super::state_estimator::StateEstimatorRecord;
        use crate::sensors::sensor::{Observation, SensorObservation};
        use serde_derive::{Deserialize, Serialize};
        /// Config for the external state estimation (generic).
        ///
        /// The config for [`ExternalEstimator`] uses a [`serde_json::Value`] to
        /// integrate your own configuration inside the full simulator config.
        ///
        /// In the yaml file, the config could be:
        /// ```YAML
        /// state_estimator:
        ///     External:
        ///         parameter_of_my_own_estimator: true
        /// ```
        #[serde(default)]
        pub struct ExternalEstimatorConfig {
            /// Config serialized.
            #[serde(flatten)]
            pub config: Value,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalEstimatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.config,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalEstimatorConfig
            where
                ExternalEstimatorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        ExternalEstimatorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<ExternalEstimatorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        ExternalEstimatorConfig: _serde::__private::Default,
                    {
                        type Value = ExternalEstimatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalEstimatorConfig",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalEstimatorConfig {
                                config: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalEstimatorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalEstimatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalEstimatorConfig",
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalEstimatorConfig {
            #[inline]
            fn clone(&self) -> ExternalEstimatorConfig {
                ExternalEstimatorConfig {
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for ExternalEstimatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                ret
            }
        }
        impl Default for ExternalEstimatorConfig {
            fn default() -> Self {
                Self { config: Value::Null }
            }
        }
        /// Record for the external state estimation (generic).
        ///
        /// Like [`ExternalEstimatorConfig`], [`ExternalEstimator`] uses a [`serde_json::Value`]
        /// to take every record.
        ///
        /// The record is not automatically cast to your own type, the cast should be done
        /// in [`Stateful::from_record`] and [`Stateful::record`] implementations.
        pub struct ExternalEstimatorRecord {
            /// Record serialized.
            #[serde(flatten)]
            pub record: Value,
        }
        impl ::pyo3::types::DerefToPyAny for ExternalEstimatorRecord {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for ExternalEstimatorRecord {
            const NAME: &'static str = "ExternalEstimatorRecord";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <ExternalEstimatorRecord as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for ExternalEstimatorRecord {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a ExternalEstimatorRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRef<'py, ExternalEstimatorRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut ExternalEstimatorRecord {
            type Holder = ::std::option::Option<
                ::pyo3::PyRefMut<'py, ExternalEstimatorRecord>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for ExternalEstimatorRecord {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for ExternalEstimatorRecord {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                ExternalEstimatorRecord,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <ExternalEstimatorRecord as ::pyo3::PyTypeInfo>::NAME,
                                c"Record for the external state estimation (generic).\n\nLike [`ExternalEstimatorConfig`], [`ExternalEstimator`] uses a [`serde_json::Value`]\nto take every record.\n\nThe record is not automatically cast to your own type, the cast should be done\nin [`Stateful::from_record`] and [`Stateful::record`] implementations.",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<ExternalEstimatorRecord> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalEstimatorRecord {}
        impl ExternalEstimatorRecord {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalEstimatorRecord {}
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ExternalEstimatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_map(
                        __serializer,
                        _serde::__private::None,
                    )?;
                    _serde::Serialize::serialize(
                        &&self.record,
                        _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                    )?;
                    _serde::ser::SerializeMap::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ExternalEstimatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field<'de> {
                        __other(_serde::__private::de::Content<'de>),
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field<'de>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_bool<__E>(
                            self,
                            __value: bool,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Bool(__value),
                                ),
                            )
                        }
                        fn visit_i8<__E>(
                            self,
                            __value: i8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I8(__value),
                                ),
                            )
                        }
                        fn visit_i16<__E>(
                            self,
                            __value: i16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I16(__value),
                                ),
                            )
                        }
                        fn visit_i32<__E>(
                            self,
                            __value: i32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I32(__value),
                                ),
                            )
                        }
                        fn visit_i64<__E>(
                            self,
                            __value: i64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::I64(__value),
                                ),
                            )
                        }
                        fn visit_u8<__E>(
                            self,
                            __value: u8,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U8(__value),
                                ),
                            )
                        }
                        fn visit_u16<__E>(
                            self,
                            __value: u16,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U16(__value),
                                ),
                            )
                        }
                        fn visit_u32<__E>(
                            self,
                            __value: u32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U32(__value),
                                ),
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::U64(__value),
                                ),
                            )
                        }
                        fn visit_f32<__E>(
                            self,
                            __value: f32,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F32(__value),
                                ),
                            )
                        }
                        fn visit_f64<__E>(
                            self,
                            __value: f64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::F64(__value),
                                ),
                            )
                        }
                        fn visit_char<__E>(
                            self,
                            __value: char,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(
                                    _serde::__private::de::Content::Char(__value),
                                ),
                            )
                        }
                        fn visit_unit<__E>(
                            self,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::__private::Ok(
                                __Field::__other(_serde::__private::de::Content::Unit),
                            )
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::String(
                                        _serde::__private::ToString::to_string(__value),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::ByteBuf(
                                        __value.to_vec(),
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_str<__E>(
                            self,
                            __value: &'de str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Str(__value);
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                        fn visit_borrowed_bytes<__E>(
                            self,
                            __value: &'de [u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = _serde::__private::de::Content::Bytes(
                                        __value,
                                    );
                                    _serde::__private::Ok(__Field::__other(__value))
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ExternalEstimatorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ExternalEstimatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ExternalEstimatorRecord",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __collect = _serde::__private::Vec::<
                                _serde::__private::Option<
                                    (
                                        _serde::__private::de::Content,
                                        _serde::__private::de::Content,
                                    ),
                                >,
                            >::new();
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__other(__name) => {
                                        __collect
                                            .push(
                                                _serde::__private::Some((
                                                    __name,
                                                    _serde::de::MapAccess::next_value(&mut __map)?,
                                                )),
                                            );
                                    }
                                }
                            }
                            let __field0: Value = _serde::de::Deserialize::deserialize(
                                _serde::__private::de::FlatMapDeserializer(
                                    &mut __collect,
                                    _serde::__private::PhantomData,
                                ),
                            )?;
                            _serde::__private::Ok(ExternalEstimatorRecord {
                                record: __field0,
                            })
                        }
                    }
                    _serde::Deserializer::deserialize_map(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ExternalEstimatorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ExternalEstimatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExternalEstimatorRecord",
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExternalEstimatorRecord {
            #[inline]
            fn clone(&self) -> ExternalEstimatorRecord {
                ExternalEstimatorRecord {
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        impl Default for ExternalEstimatorRecord {
            fn default() -> Self {
                Self { record: Value::Null }
            }
        }
        impl ExternalEstimatorRecord {
            fn record(&self) -> String {
                self.record.to_string()
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<ExternalEstimatorRecord>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<ExternalEstimatorRecord> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                            ::pyo3::class::PyMethodDefType::Getter(
                                ::pyo3::class::PyGetterDef::new(
                                    c"record",
                                    ExternalEstimatorRecord::__pymethod_get_record__,
                                    c"",
                                ),
                            ),
                        ),
                    ],
                    slots: &[],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl ExternalEstimatorRecord {
            unsafe fn __pymethod_get_record__(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let result = ::pyo3::callback::convert(
                    py,
                    ExternalEstimatorRecord::record(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            ExternalEstimatorRecord,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_0,
                        )?,
                    ),
                );
                result
            }
        }
        use crate::node::Node;
        /// External estimator strategy, which does the bridge with your own strategy.
        pub struct ExternalEstimator {
            /// External state estimator.
            state_estimator: Box<dyn StateEstimator>,
        }
        impl ExternalEstimator {
            /// Creates a new [`ExternalEstimator`]
            pub fn new() -> Self {
                Self::from_config(
                    &ExternalEstimatorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Creates a new [`ExternalEstimator`] from the given config.
            ///
            /// <div class="warning">The `plugin_api` is required here !</div>
            ///
            ///  ## Arguments
            /// * `config` -- Scenario config of the External estimator.
            /// * `plugin_api` -- Required [`PluginAPI`] implementation.
            /// * `global_config` -- Simulator config.
            /// * `_va_factory` -- Factory for Determinists random variables.
            pub fn from_config(
                config: &ExternalEstimatorConfig,
                plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                {
                    ::std::io::_print(format_args!("Config given: {0:?}\n", config));
                };
                Self {
                    state_estimator: plugin_api
                        .as_ref()
                        .expect("Plugin API not set!")
                        .get_state_estimator(&config.config, global_config),
                }
            }
        }
        impl std::fmt::Debug for ExternalEstimator {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("ExternalEstimator {{}}"))
            }
        }
        impl StateEstimator for ExternalEstimator {
            fn prediction_step(&mut self, node: &mut Node, time: f32) {
                if (time - self.next_time_step()).abs() > TIME_ROUND / 2. {
                    {
                        ::std::io::_print(
                            format_args!("Error trying to update estimate too soon !\n"),
                        );
                    };
                    return;
                }
                self.state_estimator.prediction_step(node, time);
            }
            fn correction_step(
                &mut self,
                node: &mut Node,
                observations: &Vec<Observation>,
                time: f32,
            ) {
                self.state_estimator.correction_step(node, observations, time);
            }
            fn state(&self) -> State {
                self.state_estimator.state()
            }
            fn next_time_step(&self) -> f32 {
                round_precision(self.state_estimator.next_time_step(), TIME_ROUND)
                    .unwrap()
            }
        }
        impl Stateful<StateEstimatorRecord> for ExternalEstimator {
            fn record(&self) -> StateEstimatorRecord {
                self.state_estimator.record()
            }
            fn from_record(&mut self, record: StateEstimatorRecord) {
                self.state_estimator.from_record(record);
            }
        }
    }
    pub mod perfect_estimator {
        /*!
Module providing the [`PerfectEstimator`] strategy. This strategy uses directly
the groundtruth to provide the estimation. It can be used when the state used
by the controller should be perfect.
*/
        use std::collections::BTreeMap;
        use super::state_estimator::{State, StateRecord};
        use crate::constants::TIME_ROUND;
        use crate::sensors::sensor::{Observation, SensorObservation};
        use crate::simulator::SimulatorConfig;
        use crate::stateful::Stateful;
        use crate::utils::maths::round_precision;
        use crate::{
            plugin_api::PluginAPI,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use config_checker::macros::Check;
        use log::{debug, error, info};
        use serde_derive::{Deserialize, Serialize};
        /// Configuration for [`PerfectEstimator`].
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct PerfectEstimatorConfig {
            /// Prediction period.
            #[check(ge(0.))]
            pub prediction_period: f32,
            pub targets: Vec<String>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PerfectEstimatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PerfectEstimatorConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "prediction_period",
                        &self.prediction_period,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "targets",
                        &self.targets,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PerfectEstimatorConfig
            where
                PerfectEstimatorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "prediction_period" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "targets" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"prediction_period" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"targets" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        PerfectEstimatorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<PerfectEstimatorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        PerfectEstimatorConfig: _serde::__private::Default,
                    {
                        type Value = PerfectEstimatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PerfectEstimatorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.prediction_period,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.targets,
                            };
                            _serde::__private::Ok(PerfectEstimatorConfig {
                                prediction_period: __field0,
                                targets: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "prediction_period",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "targets",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.prediction_period,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.targets,
                            };
                            _serde::__private::Ok(PerfectEstimatorConfig {
                                prediction_period: __field0,
                                targets: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "prediction_period",
                        "targets",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PerfectEstimatorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PerfectEstimatorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PerfectEstimatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PerfectEstimatorConfig",
                    "prediction_period",
                    &self.prediction_period,
                    "targets",
                    &&self.targets,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerfectEstimatorConfig {
            #[inline]
            fn clone(&self) -> PerfectEstimatorConfig {
                PerfectEstimatorConfig {
                    prediction_period: ::core::clone::Clone::clone(
                        &self.prediction_period,
                    ),
                    targets: ::core::clone::Clone::clone(&self.targets),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for PerfectEstimatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.prediction_period >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "prediction_period",
                                "PerfectEstimatorConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                ret
            }
        }
        impl Default for PerfectEstimatorConfig {
            fn default() -> Self {
                Self {
                    prediction_period: 0.1,
                    targets: <[_]>::into_vec(
                        ::alloc::boxed::box_new(["self".to_string()]),
                    ),
                }
            }
        }
        /// Record for [`PerfectEstimator`].
        pub struct PerfectEstimatorRecord {
            /// Current state estimated
            pub states: Vec<(String, StateRecord)>,
            /// Last change of state
            pub last_time_update: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PerfectEstimatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PerfectEstimatorRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "states",
                        &self.states,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_time_update",
                        &self.last_time_update,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PerfectEstimatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "states" => _serde::__private::Ok(__Field::__field0),
                                "last_time_update" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"states" => _serde::__private::Ok(__Field::__field0),
                                b"last_time_update" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PerfectEstimatorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PerfectEstimatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PerfectEstimatorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<(String, StateRecord)>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PerfectEstimatorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PerfectEstimatorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PerfectEstimatorRecord {
                                states: __field0,
                                last_time_update: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<(String, StateRecord)>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("states"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<(String, StateRecord)>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "last_time_update",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("states")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("last_time_update")?
                                }
                            };
                            _serde::__private::Ok(PerfectEstimatorRecord {
                                states: __field0,
                                last_time_update: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "states",
                        "last_time_update",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PerfectEstimatorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PerfectEstimatorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for PerfectEstimatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PerfectEstimatorRecord",
                    "states",
                    &self.states,
                    "last_time_update",
                    &&self.last_time_update,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerfectEstimatorRecord {
            #[inline]
            fn clone(&self) -> PerfectEstimatorRecord {
                PerfectEstimatorRecord {
                    states: ::core::clone::Clone::clone(&self.states),
                    last_time_update: ::core::clone::Clone::clone(&self.last_time_update),
                }
            }
        }
        /// Estimation strategy without any error.
        pub struct PerfectEstimator {
            /// Estimation of the state on the `last_time_update`.
            states: BTreeMap<String, State>,
            /// Prediction period, in seconds.
            prediction_period: f32,
            /// Last time the state was updated/predicted.
            last_time_update: f32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PerfectEstimator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "PerfectEstimator",
                    "states",
                    &self.states,
                    "prediction_period",
                    &self.prediction_period,
                    "last_time_update",
                    &&self.last_time_update,
                )
            }
        }
        impl PerfectEstimator {
            /// Create a new [`PerfectEstimator`] using default [`PerfectEstimatorConfig`].
            pub fn new() -> Self {
                Self::from_config(
                    &PerfectEstimatorConfig::default(),
                    &None,
                    &SimulatorConfig::default(),
                    &DeterministRandomVariableFactory::default(),
                )
            }
            /// Creates a new [`PerfectEstimator`] from the given `config`.
            pub fn from_config(
                config: &PerfectEstimatorConfig,
                _plugin_api: &Option<Box<&dyn PluginAPI>>,
                _global_config: &SimulatorConfig,
                _va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                let mut states = BTreeMap::new();
                for target in &config.targets {
                    states.insert(target.clone(), State::new());
                }
                Self {
                    prediction_period: config.prediction_period,
                    states,
                    last_time_update: 0.,
                }
            }
        }
        use super::state_estimator::{StateEstimator, StateEstimatorRecord};
        use crate::node::Node;
        impl StateEstimator for PerfectEstimator {
            fn prediction_step(&mut self, node: &mut Node, time: f32) {
                if (time - self.next_time_step()).abs() > TIME_ROUND / 2. {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Error trying to update estimate too soon !"),
                                    lvl,
                                    &(
                                        "simba::state_estimators::perfect_estimator",
                                        "simba::state_estimators::perfect_estimator",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    return;
                }
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Doing prediction step"),
                                lvl,
                                &(
                                    "simba::state_estimators::perfect_estimator",
                                    "simba::state_estimators::perfect_estimator",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                for (target, state) in &mut self.states {
                    if target.to_lowercase() == "self".to_string() {
                        let arc_physic = node
                            .physics()
                            .expect("Node with state_estimator should have physics");
                        let physic = arc_physic.read().unwrap();
                        *state = physic.state(time).clone();
                    } else {
                        *state = node
                            .service_manager()
                            .read()
                            .unwrap()
                            .get_real_state(target, node, time)
                            .expect(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0} does not have physics, no perfect state can be computed!",
                                                target,
                                            ),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                }
                self.last_time_update = time;
            }
            fn correction_step(
                &mut self,
                _node: &mut Node,
                _observations: &Vec<Observation>,
                _time: f32,
            ) {
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Got observations at time {1}: {0:?}",
                                    _observations,
                                    _time,
                                ),
                                lvl,
                                &(
                                    "simba::state_estimators::perfect_estimator",
                                    "simba::state_estimators::perfect_estimator",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            fn state(&self) -> State {
                if self.states.contains_key(&"self".to_string()) {
                    self.states["self"].clone()
                } else {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "PerfectEstimator should contain the target \'self\' to be used in the control loop.",
                            ),
                        );
                    };
                }
            }
            fn next_time_step(&self) -> f32 {
                round_precision(
                        self.last_time_update + self.prediction_period,
                        TIME_ROUND,
                    )
                    .unwrap()
            }
        }
        impl Stateful<StateEstimatorRecord> for PerfectEstimator {
            fn record(&self) -> StateEstimatorRecord {
                let mut state_records = Vec::new();
                for (target, state) in &self.states {
                    state_records.push((target.clone(), state.record()));
                }
                StateEstimatorRecord::Perfect(PerfectEstimatorRecord {
                    states: state_records,
                    last_time_update: self.last_time_update,
                })
            }
            fn from_record(&mut self, record: StateEstimatorRecord) {
                if let StateEstimatorRecord::Perfect(record_state_estimator) = record {
                    for (target, state_record) in &record_state_estimator.states {
                        self.states
                            .get_mut(target)
                            .expect(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Target {0} not found among the PerfectEstimator targets",
                                                target,
                                            ),
                                        );
                                        res
                                    })
                                    .as_str(),
                            )
                            .from_record(state_record.clone());
                        self.last_time_update = record_state_estimator.last_time_update;
                    }
                } else {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Using a StateEstimatorRecord type which does not match the used StateEstimator (PerfectEstimator)",
                                    ),
                                    lvl,
                                    &(
                                        "simba::state_estimators::perfect_estimator",
                                        "simba::state_estimators::perfect_estimator",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
        }
    }
    pub mod pybinds {
        use std::{str::FromStr, sync::{mpsc, Arc, Mutex}};
        use log::debug;
        use pyo3::prelude::*;
        use serde_json::Value;
        use crate::{
            constants::TIME_ROUND, logger::is_enabled, node::Node,
            node_factory::NodeRecord,
            pywrappers::{ObservationWrapper, SensorObservationWrapper, StateWrapper},
            sensors::sensor::{Observation, SensorObservation},
            stateful::Stateful, utils::maths::round_precision,
        };
        use super::{
            external_estimator::ExternalEstimatorRecord,
            state_estimator::{State, StateEstimator, StateEstimatorRecord},
        };
        pub struct PythonStateEstimatorAsyncClient {
            pub prediction_step_request: mpsc::Sender<f32>,
            pub prediction_step_response: Arc<Mutex<mpsc::Receiver<()>>>,
            pub correction_step_request: mpsc::Sender<(Vec<Observation>, f32)>,
            pub correction_step_response: Arc<Mutex<mpsc::Receiver<()>>>,
            pub state_request: mpsc::Sender<()>,
            pub state_response: Arc<Mutex<mpsc::Receiver<State>>>,
            pub next_time_step_request: mpsc::Sender<()>,
            pub next_time_step_response: Arc<Mutex<mpsc::Receiver<f32>>>,
            pub record_request: mpsc::Sender<()>,
            pub record_response: Arc<Mutex<mpsc::Receiver<StateEstimatorRecord>>>,
            pub from_record_request: mpsc::Sender<StateEstimatorRecord>,
            pub from_record_response: Arc<Mutex<mpsc::Receiver<()>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonStateEstimatorAsyncClient {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "prediction_step_request",
                    "prediction_step_response",
                    "correction_step_request",
                    "correction_step_response",
                    "state_request",
                    "state_response",
                    "next_time_step_request",
                    "next_time_step_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.prediction_step_request,
                    &self.prediction_step_response,
                    &self.correction_step_request,
                    &self.correction_step_response,
                    &self.state_request,
                    &self.state_response,
                    &self.next_time_step_request,
                    &self.next_time_step_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonStateEstimatorAsyncClient",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PythonStateEstimatorAsyncClient {
            #[inline]
            fn clone(&self) -> PythonStateEstimatorAsyncClient {
                PythonStateEstimatorAsyncClient {
                    prediction_step_request: ::core::clone::Clone::clone(
                        &self.prediction_step_request,
                    ),
                    prediction_step_response: ::core::clone::Clone::clone(
                        &self.prediction_step_response,
                    ),
                    correction_step_request: ::core::clone::Clone::clone(
                        &self.correction_step_request,
                    ),
                    correction_step_response: ::core::clone::Clone::clone(
                        &self.correction_step_response,
                    ),
                    state_request: ::core::clone::Clone::clone(&self.state_request),
                    state_response: ::core::clone::Clone::clone(&self.state_response),
                    next_time_step_request: ::core::clone::Clone::clone(
                        &self.next_time_step_request,
                    ),
                    next_time_step_response: ::core::clone::Clone::clone(
                        &self.next_time_step_response,
                    ),
                    record_request: ::core::clone::Clone::clone(&self.record_request),
                    record_response: ::core::clone::Clone::clone(&self.record_response),
                    from_record_request: ::core::clone::Clone::clone(
                        &self.from_record_request,
                    ),
                    from_record_response: ::core::clone::Clone::clone(
                        &self.from_record_response,
                    ),
                }
            }
        }
        impl StateEstimator for PythonStateEstimatorAsyncClient {
            fn prediction_step(&mut self, _node: &mut Node, time: f32) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Start prediction step from async client"),
                                lvl,
                                &(
                                    "simba::state_estimators::pybinds",
                                    "simba::state_estimators::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                self.prediction_step_request.send(time).unwrap();
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Start prediction step from async client: Request sent",
                                ),
                                lvl,
                                &(
                                    "simba::state_estimators::pybinds",
                                    "simba::state_estimators::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                self.prediction_step_response.lock().unwrap().recv().unwrap();
            }
            fn correction_step(
                &mut self,
                _node: &mut Node,
                observations: &Vec<Observation>,
                time: f32,
            ) {
                self.correction_step_request.send((observations.clone(), time)).unwrap();
                self.correction_step_response.lock().unwrap().recv().unwrap();
            }
            fn next_time_step(&self) -> f32 {
                self.next_time_step_request.send(()).unwrap();
                self.next_time_step_response
                    .lock()
                    .unwrap()
                    .recv()
                    .expect("Error during call of next_time_step")
            }
            fn state(&self) -> State {
                self.state_request.send(()).unwrap();
                self.state_response
                    .lock()
                    .unwrap()
                    .recv()
                    .expect("Error during call of state")
            }
        }
        impl Stateful<StateEstimatorRecord> for PythonStateEstimatorAsyncClient {
            fn from_record(&mut self, record: StateEstimatorRecord) {
                self.from_record_request.send(record).unwrap();
                self.from_record_response.lock().unwrap().recv().unwrap();
            }
            fn record(&self) -> StateEstimatorRecord {
                self.record_request.send(()).unwrap();
                self.record_response
                    .lock()
                    .unwrap()
                    .recv()
                    .expect("Error during call of record")
            }
        }
        pub struct PythonStateEstimator {
            model: Py<PyAny>,
            client: PythonStateEstimatorAsyncClient,
            prediction_step_request: Arc<Mutex<mpsc::Receiver<f32>>>,
            prediction_step_response: mpsc::Sender<()>,
            correction_step_request: Arc<Mutex<mpsc::Receiver<(Vec<Observation>, f32)>>>,
            correction_step_response: mpsc::Sender<()>,
            state_request: Arc<Mutex<mpsc::Receiver<()>>>,
            state_response: mpsc::Sender<State>,
            next_time_step_request: Arc<Mutex<mpsc::Receiver<()>>>,
            next_time_step_response: mpsc::Sender<f32>,
            record_request: Arc<Mutex<mpsc::Receiver<()>>>,
            record_response: mpsc::Sender<StateEstimatorRecord>,
            from_record_request: Arc<Mutex<mpsc::Receiver<StateEstimatorRecord>>>,
            from_record_response: mpsc::Sender<()>,
        }
        impl ::pyo3::types::DerefToPyAny for PythonStateEstimator {}
        unsafe impl ::pyo3::type_object::PyTypeInfo for PythonStateEstimator {
            const NAME: &'static str = "StateEstimator";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(
                py: ::pyo3::Python<'_>,
            ) -> *mut ::pyo3::ffi::PyTypeObject {
                use ::pyo3::prelude::PyTypeMethods;
                <PythonStateEstimator as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl ::pyo3::PyClass for PythonStateEstimator {
            type Frozen = ::pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a PythonStateEstimator {
            type Holder = ::std::option::Option<
                ::pyo3::PyRef<'py, PythonStateEstimator>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut PythonStateEstimator {
            type Holder = ::std::option::Option<
                ::pyo3::PyRefMut<'py, PythonStateEstimator>,
            >;
            #[inline]
            fn extract(
                obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
                holder: &'a mut Self::Holder,
            ) -> ::pyo3::PyResult<Self> {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl ::pyo3::IntoPy<::pyo3::PyObject> for PythonStateEstimator {
            fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
                ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl ::pyo3::impl_::pyclass::PyClassImpl for PythonStateEstimator {
            const IS_BASETYPE: bool = true;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type BaseType = ::pyo3::PyAny;
            type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
                PythonStateEstimator,
            >;
            type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = ::pyo3::PyAny;
            fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
                use ::pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(
                py: ::pyo3::Python<'_>,
            ) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
                use ::pyo3::impl_::pyclass::*;
                static DOC: ::pyo3::sync::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = ::pyo3::sync::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <PythonStateEstimator as ::pyo3::PyTypeInfo>::NAME,
                                c"",
                                collector.new_text_signature(),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use ::pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<PythonStateEstimator> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonStateEstimator {}
        impl PythonStateEstimator {
            #[doc(hidden)]
            pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonStateEstimator {}
        #[automatically_derived]
        impl ::core::fmt::Debug for PythonStateEstimator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "model",
                    "client",
                    "prediction_step_request",
                    "prediction_step_response",
                    "correction_step_request",
                    "correction_step_response",
                    "state_request",
                    "state_response",
                    "next_time_step_request",
                    "next_time_step_response",
                    "record_request",
                    "record_response",
                    "from_record_request",
                    "from_record_response",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.model,
                    &self.client,
                    &self.prediction_step_request,
                    &self.prediction_step_response,
                    &self.correction_step_request,
                    &self.correction_step_response,
                    &self.state_request,
                    &self.state_response,
                    &self.next_time_step_request,
                    &self.next_time_step_response,
                    &self.record_request,
                    &self.record_response,
                    &self.from_record_request,
                    &&self.from_record_response,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PythonStateEstimator",
                    names,
                    values,
                )
            }
        }
        impl PythonStateEstimator {
            pub fn new(py_model: Py<PyAny>) -> PythonStateEstimator {
                if is_enabled(crate::logger::InternalLog::API) {
                    Python::with_gil(|py| {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Model got: {0}",
                                            py_model.bind(py).dir().unwrap(),
                                        ),
                                        lvl,
                                        &(
                                            "simba::state_estimators::pybinds",
                                            "simba::state_estimators::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    });
                }
                let (prediction_request_tx, prediction_request_rx) = mpsc::channel();
                let (prediction_response_tx, prediction_response_rx) = mpsc::channel();
                let (correction_request_tx, correction_request_rx) = mpsc::channel();
                let (correction_response_tx, correction_response_rx) = mpsc::channel();
                let (state_request_tx, state_request_rx) = mpsc::channel();
                let (state_response_tx, state_response_rx) = mpsc::channel();
                let (next_time_step_request_tx, next_time_step_request_rx) = mpsc::channel();
                let (next_time_step_response_tx, next_time_step_response_rx) = mpsc::channel();
                let (record_request_tx, record_request_rx) = mpsc::channel();
                let (record_response_tx, record_response_rx) = mpsc::channel();
                let (from_record_request_tx, from_record_request_rx) = mpsc::channel();
                let (from_record_response_tx, from_record_response_rx) = mpsc::channel();
                PythonStateEstimator {
                    model: py_model,
                    client: PythonStateEstimatorAsyncClient {
                        prediction_step_request: prediction_request_tx,
                        prediction_step_response: Arc::new(
                            Mutex::new(prediction_response_rx),
                        ),
                        correction_step_request: correction_request_tx,
                        correction_step_response: Arc::new(
                            Mutex::new(correction_response_rx),
                        ),
                        state_request: state_request_tx,
                        state_response: Arc::new(Mutex::new(state_response_rx)),
                        next_time_step_request: next_time_step_request_tx,
                        next_time_step_response: Arc::new(
                            Mutex::new(next_time_step_response_rx),
                        ),
                        record_request: record_request_tx,
                        record_response: Arc::new(Mutex::new(record_response_rx)),
                        from_record_request: from_record_request_tx,
                        from_record_response: Arc::new(
                            Mutex::new(from_record_response_rx),
                        ),
                    },
                    prediction_step_request: Arc::new(Mutex::new(prediction_request_rx)),
                    prediction_step_response: prediction_response_tx,
                    correction_step_request: Arc::new(Mutex::new(correction_request_rx)),
                    correction_step_response: correction_response_tx,
                    state_request: Arc::new(Mutex::new(state_request_rx)),
                    state_response: state_response_tx,
                    next_time_step_request: Arc::new(
                        Mutex::new(next_time_step_request_rx),
                    ),
                    next_time_step_response: next_time_step_response_tx,
                    record_request: Arc::new(Mutex::new(record_request_rx)),
                    record_response: record_response_tx,
                    from_record_request: Arc::new(Mutex::new(from_record_request_rx)),
                    from_record_response: from_record_response_tx,
                }
            }
        }
        #[allow(unknown_lints, non_local_definitions)]
        impl ::pyo3::impl_::pyclass::PyMethods<PythonStateEstimator>
        for ::pyo3::impl_::pyclass::PyClassImplCollector<PythonStateEstimator> {
            fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                    methods: &[],
                    slots: &[
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut ::pyo3::ffi::PyTypeObject,
                                    args: *mut ::pyo3::ffi::PyObject,
                                    kwargs: *mut ::pyo3::ffi::PyObject,
                                ) -> *mut ::pyo3::ffi::PyObject {
                                    use ::pyo3::impl_::pyclass::*;
                                    #[allow(unknown_lints, non_local_definitions)]
                                    impl PyClassNewTextSignature<PythonStateEstimator>
                                    for PyClassImplCollector<PythonStateEstimator> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str> {
                                            ::std::option::Option::Some("(py_model)")
                                        }
                                    }
                                    ::pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        PythonStateEstimator::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as ::pyo3::ffi::newfunc as _,
                        },
                    ],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl PythonStateEstimator {
            unsafe fn __pymethod___new____(
                py: ::pyo3::Python<'_>,
                _slf: *mut ::pyo3::ffi::PyTypeObject,
                _args: *mut ::pyo3::ffi::PyObject,
                _kwargs: *mut ::pyo3::ffi::PyObject,
            ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
                use ::pyo3::callback::IntoPyCallbackOutput;
                let _slf_ref = &_slf;
                let function = PythonStateEstimator::new;
                const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::Some(
                        <PythonStateEstimator as ::pyo3::type_object::PyTypeInfo>::NAME,
                    ),
                    func_name: "__new__",
                    positional_parameter_names: &["py_model"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args, _kwargs) = DESCRIPTION
                    .extract_arguments_tuple_dict::<
                        ::pyo3::impl_::extract_argument::NoVarargs,
                        ::pyo3::impl_::extract_argument::NoVarkeywords,
                    >(py, _args, _kwargs, &mut output)?;
                #[allow(clippy::let_unit_value)]
                let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
                let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
                let result = PythonStateEstimator::new(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "py_model",
                        )?,
                        &gil_refs_checker_0,
                    ),
                );
                let initializer: ::pyo3::PyClassInitializer<PythonStateEstimator> = result
                    .convert(py)?;
                gil_refs_checker_0.function_arg();
                ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
            }
        }
        impl PythonStateEstimator {
            pub fn get_client(&self) -> PythonStateEstimatorAsyncClient {
                self.client.clone()
            }
            pub fn check_requests(&mut self) {
                if let Ok(time) = self
                    .prediction_step_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Request for prediction step received"),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    self.prediction_step(time);
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Response for prediction step sent"),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    self.prediction_step_response.send(()).unwrap();
                }
                if let Ok((obs, time)) = self
                    .correction_step_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.correction_step(&obs, time);
                    self.correction_step_response.send(()).unwrap();
                }
                if let Ok(()) = self.state_request.clone().lock().unwrap().try_recv() {
                    self.state_response.send(self.state()).unwrap();
                }
                if let Ok(()) = self
                    .next_time_step_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.next_time_step_response.send(self.next_time_step()).unwrap();
                }
                if let Ok(()) = self.record_request.clone().lock().unwrap().try_recv() {
                    self.record_response.send(self.record()).unwrap();
                }
                if let Ok(record) = self
                    .from_record_request
                    .clone()
                    .lock()
                    .unwrap()
                    .try_recv()
                {
                    self.from_record(record);
                    self.from_record_response.send(()).unwrap();
                }
            }
            fn prediction_step(&mut self, time: f32) {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of prediction_step",
                                    ),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("prediction_step", (time,), None)
                        .expect(
                            "Python implementation of PythonStateEstimator does not have a correct 'prediction_step' method",
                        );
                });
            }
            fn correction_step(&mut self, observations: &Vec<Observation>, time: f32) {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of correction_step",
                                    ),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let mut observation_py = Vec::new();
                for obs in observations {
                    observation_py.push(ObservationWrapper::from_rust(obs));
                }
                Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("correction_step", (observation_py, time), None)
                        .expect(
                            "Python implementation of PythonStateEstimator does not have a correct 'correction_step' method",
                        );
                });
            }
            fn state(&self) -> State {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Calling python implementation of state"),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let state = Python::with_gil(|py| -> StateWrapper {
                    self.model
                        .bind(py)
                        .call_method("state", (), None)
                        .expect(
                            "Python implementation of PythonStateEstimator does not have a correct 'state' method",
                        )
                        .extract()
                        .expect(
                            "The 'state' method of PythonStateEstimator does not return a correct state vector",
                        )
                });
                state.to_rust()
            }
            fn next_time_step(&self) -> f32 {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Calling python implementation of next_time_step",
                                    ),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let time = Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("next_time_step", (), None)
                        .expect(
                            "Python implementation of PythonStateEstimator does not have a correct 'next_time_step' method",
                        )
                        .extract()
                        .expect(
                            "The 'next_time_step' method of PythonStateEstimator does not return a correct time for next step",
                        )
                });
                round_precision(time, TIME_ROUND).unwrap()
            }
            fn record(&self) -> StateEstimatorRecord {
                if is_enabled(crate::logger::InternalLog::API) {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Calling python implementation of record"),
                                    lvl,
                                    &(
                                        "simba::state_estimators::pybinds",
                                        "simba::state_estimators::pybinds",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let record_str: String = Python::with_gil(|py| {
                    self.model
                        .bind(py)
                        .call_method("record", (), None)
                        .expect(
                            "Python implementation of PythonStateEstimator does not have a correct 'record' method",
                        )
                        .extract()
                        .expect(
                            "The 'record' method of PythonStateEstimator does not return a valid EstimatorRecord type",
                        )
                });
                let record = ExternalEstimatorRecord {
                    record: Value::from_str(record_str.as_str())
                        .expect(
                            "Impossible to get serde_json::Value from the input serialized python structure",
                        ),
                };
                StateEstimatorRecord::External(record)
            }
            fn from_record(&mut self, record: StateEstimatorRecord) {
                if let StateEstimatorRecord::External(record) = record {
                    if is_enabled(crate::logger::InternalLog::API) {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Calling python implementation of from_record",
                                        ),
                                        lvl,
                                        &(
                                            "simba::state_estimators::pybinds",
                                            "simba::state_estimators::pybinds",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                    Python::with_gil(|py| {
                        self.model
                            .bind(py)
                            .call_method(
                                "from_record",
                                (serde_json::to_string(&record).unwrap(),),
                                None,
                            )
                            .expect(
                                "Python implementation of PythonStateEstimator does not have a correct 'from_record' method",
                            );
                    });
                }
            }
        }
    }
    pub mod state_estimator {
        /*!
Module defining the [`StateEstimator`] trait, which need to be implemented
for the state estimation strategies.
*/
        extern crate nalgebra as na;
        use config_checker::macros::Check;
        use na::SVector;
        extern crate confy;
        use serde_derive::{Deserialize, Serialize};
        /// Configuration for [`State`] in order to load a state from the configuration.
        ///
        /// The pose should contain 3 elements.
        /// TODO: Make a config validation scheme.
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct StateConfig {
            /// Position and orientation of the robot
            pub pose: Vec<f32>,
            /// Linear velocity
            #[check(ge(0.))]
            pub velocity: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StateConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "StateConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pose",
                        &self.pose,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "velocity",
                        &self.velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StateConfig
            where
                StateConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "pose" => _serde::__private::Ok(__Field::__field0),
                                "velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"pose" => _serde::__private::Ok(__Field::__field0),
                                b"velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        StateConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<StateConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        StateConfig: _serde::__private::Default,
                    {
                        type Value = StateConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StateConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<f32>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.pose,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.velocity,
                            };
                            _serde::__private::Ok(StateConfig {
                                pose: __field0,
                                velocity: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Vec<f32>> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pose"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<f32>>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "velocity",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.pose,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.velocity,
                            };
                            _serde::__private::Ok(StateConfig {
                                pose: __field0,
                                velocity: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["pose", "velocity"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StateConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StateConfig>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for StateConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "StateConfig",
                    "pose",
                    &self.pose,
                    "velocity",
                    &&self.velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StateConfig {
            #[inline]
            fn clone(&self) -> StateConfig {
                StateConfig {
                    pose: ::core::clone::Clone::clone(&self.pose),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for StateConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !(self.velocity >= 0.) {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {3}In field `{1}` of `{2}`\n",
                                "ERROR:".red(),
                                "velocity",
                                "StateConfig",
                                depth_space,
                            ),
                        );
                    };
                    ret = false;
                }
                ret
            }
        }
        impl Default for StateConfig {
            fn default() -> Self {
                Self {
                    pose: <[_]>::into_vec(::alloc::boxed::box_new([0., 0., 0.])),
                    velocity: 0.,
                }
            }
        }
        /// Record for [`State`] in order to record a state.
        pub struct StateRecord {
            /// Position and orientation of the robot
            pub pose: [f32; 3],
            /// Linear velocity.
            pub velocity: f32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StateRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "StateRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pose",
                        &self.pose,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "velocity",
                        &self.velocity,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StateRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "pose" => _serde::__private::Ok(__Field::__field0),
                                "velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"pose" => _serde::__private::Ok(__Field::__field0),
                                b"velocity" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StateRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StateRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StateRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                [f32; 3],
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StateRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                f32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct StateRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StateRecord {
                                pose: __field0,
                                velocity: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<[f32; 3]> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pose"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<[f32; 3]>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "velocity",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pose")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("velocity")?
                                }
                            };
                            _serde::__private::Ok(StateRecord {
                                pose: __field0,
                                velocity: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["pose", "velocity"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StateRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StateRecord>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for StateRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "StateRecord",
                    "pose",
                    &self.pose,
                    "velocity",
                    &&self.velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StateRecord {
            #[inline]
            fn clone(&self) -> StateRecord {
                StateRecord {
                    pose: ::core::clone::Clone::clone(&self.pose),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                }
            }
        }
        impl Default for StateRecord {
            fn default() -> Self {
                Self {
                    pose: [0., 0., 0.],
                    velocity: 0.,
                }
            }
        }
        /// State to be estimated.
        pub struct State {
            /// Pose of the robot [x, y, orientation]
            pub pose: SVector<f32, 3>,
            /// Linear velocity of the robot (in the longitudinal direction).
            pub velocity: f32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for State {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "State",
                    "pose",
                    &self.pose,
                    "velocity",
                    &&self.velocity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for State {
            #[inline]
            fn clone(&self) -> State {
                State {
                    pose: ::core::clone::Clone::clone(&self.pose),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                }
            }
        }
        impl State {
            /// Creates a new [`State`], with all values to 0.
            pub fn new() -> Self {
                Self {
                    pose: SVector::<f32, 3>::new(0., 0., 0.),
                    velocity: 0.,
                }
            }
            pub fn from_vector(vec: Vec<f32>) -> Self {
                let mut state = State::new();
                if vec.len() >= 1 {
                    state.pose.x = vec[0];
                }
                if vec.len() >= 2 {
                    state.pose.y = vec[1];
                }
                if vec.len() >= 3 {
                    state.pose.z = vec[2];
                }
                state
            }
            /// Load a [`State`] from the `config` ([`StateConfig`]).
            pub fn from_config(config: &StateConfig) -> Self {
                let mut state = Self::new();
                let mut i: usize = 0;
                for coord in &config.pose {
                    if i >= 3 {
                        break;
                    }
                    state.pose[i] = *coord;
                    i += 1;
                }
                state.velocity = config.velocity;
                state
            }
            pub fn theta_modulo(mut self) -> Self {
                self.pose.z = mod2pi(self.pose.z);
                self
            }
        }
        impl Stateful<StateRecord> for State {
            fn record(&self) -> StateRecord {
                StateRecord {
                    pose: {
                        let mut ve = [0., 0., 0.];
                        for (i, coord) in self.pose.iter().enumerate() {
                            if i > ve.len() {
                                continue;
                            }
                            ve[i] = *coord;
                        }
                        ve
                    },
                    velocity: self.velocity,
                }
            }
            fn from_record(&mut self, record: StateRecord) {
                self.velocity = record.velocity;
                let mut i: usize = 0;
                for coord in &record.pose {
                    self.pose[i] = *coord;
                    i += 1;
                }
            }
        }
        use std::fmt;
        impl fmt::Display for State {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter
                    .write_fmt(
                        format_args!(
                            "pose: [{0}, {1}, {2}], v: {3}\n",
                            self.pose.x,
                            self.pose.y,
                            self.pose.z,
                            self.velocity,
                        ),
                    )?;
                Ok(())
            }
        }
        use super::perfect_estimator::PerfectEstimatorConfig;
        use super::{external_estimator, perfect_estimator};
        use crate::node::Node;
        use crate::simulator::SimulatorConfig;
        use crate::stateful::Stateful;
        use crate::utils::geometry::mod2pi;
        use crate::{
            plugin_api::PluginAPI,
            utils::determinist_random_variable::DeterministRandomVariableFactory,
        };
        use std::sync::{Arc, RwLock};
        /// List the possible configs, to be selected in the global config.
        ///
        /// To select the [`StateEstimatorConfig::Perfect`], the yaml config should be:
        /// ```YAML
        /// state_estimator:
        ///     Perfect:
        ///         prediction_period: 0.01
        /// ```
        #[serde(deny_unknown_fields)]
        pub enum StateEstimatorConfig {
            Perfect(perfect_estimator::PerfectEstimatorConfig),
            External(external_estimator::ExternalEstimatorConfig),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StateEstimatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        StateEstimatorConfig::Perfect(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "StateEstimatorConfig",
                                0u32,
                                "Perfect",
                                __field0,
                            )
                        }
                        StateEstimatorConfig::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "StateEstimatorConfig",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StateEstimatorConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Perfect" => _serde::__private::Ok(__Field::__field0),
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Perfect" => _serde::__private::Ok(__Field::__field0),
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StateEstimatorConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StateEstimatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum StateEstimatorConfig",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            perfect_estimator::PerfectEstimatorConfig,
                                        >(__variant),
                                        StateEstimatorConfig::Perfect,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            external_estimator::ExternalEstimatorConfig,
                                        >(__variant),
                                        StateEstimatorConfig::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Perfect", "External"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "StateEstimatorConfig",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                StateEstimatorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for StateEstimatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    StateEstimatorConfig::Perfect(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Perfect",
                            &__self_0,
                        )
                    }
                    StateEstimatorConfig::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StateEstimatorConfig {
            #[inline]
            fn clone(&self) -> StateEstimatorConfig {
                match self {
                    StateEstimatorConfig::Perfect(__self_0) => {
                        StateEstimatorConfig::Perfect(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    StateEstimatorConfig::External(__self_0) => {
                        StateEstimatorConfig::External(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for StateEstimatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                match &self {
                    StateEstimatorConfig::Perfect(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Perfect",
                                        "StateEstimatorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    StateEstimatorConfig::External(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "External",
                                        "StateEstimatorConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    _ => {}
                };
                ret
            }
        }
        /// List the possible records.
        pub enum StateEstimatorRecord {
            Perfect(perfect_estimator::PerfectEstimatorRecord),
            External(external_estimator::ExternalEstimatorRecord),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StateEstimatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        StateEstimatorRecord::Perfect(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "StateEstimatorRecord",
                                0u32,
                                "Perfect",
                                __field0,
                            )
                        }
                        StateEstimatorRecord::External(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "StateEstimatorRecord",
                                1u32,
                                "External",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StateEstimatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Perfect" => _serde::__private::Ok(__Field::__field0),
                                "External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Perfect" => _serde::__private::Ok(__Field::__field0),
                                b"External" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StateEstimatorRecord>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StateEstimatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum StateEstimatorRecord",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            perfect_estimator::PerfectEstimatorRecord,
                                        >(__variant),
                                        StateEstimatorRecord::Perfect,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            external_estimator::ExternalEstimatorRecord,
                                        >(__variant),
                                        StateEstimatorRecord::External,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Perfect", "External"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "StateEstimatorRecord",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                StateEstimatorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for StateEstimatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    StateEstimatorRecord::Perfect(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Perfect",
                            &__self_0,
                        )
                    }
                    StateEstimatorRecord::External(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "External",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StateEstimatorRecord {
            #[inline]
            fn clone(&self) -> StateEstimatorRecord {
                match self {
                    StateEstimatorRecord::Perfect(__self_0) => {
                        StateEstimatorRecord::Perfect(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    StateEstimatorRecord::External(__self_0) => {
                        StateEstimatorRecord::External(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        /**
 * Make the right [`StateEstimator`] from the configuration given.
 */
        pub fn make_state_estimator_from_config(
            config: &StateEstimatorConfig,
            plugin_api: &Option<Box<&dyn PluginAPI>>,
            global_config: &SimulatorConfig,
            va_factory: &DeterministRandomVariableFactory,
        ) -> Box<dyn StateEstimator> {
            return match config {
                StateEstimatorConfig::Perfect(c) => {
                    Box::new(
                        perfect_estimator::PerfectEstimator::from_config(
                            c,
                            plugin_api,
                            global_config,
                            va_factory,
                        ),
                    ) as Box<dyn StateEstimator>
                }
                StateEstimatorConfig::External(c) => {
                    Box::new(
                        external_estimator::ExternalEstimator::from_config(
                            c,
                            plugin_api,
                            global_config,
                            va_factory,
                        ),
                    ) as Box<dyn StateEstimator>
                }
            };
        }
        use crate::sensors::sensor::{Observation, SensorObservation};
        pub trait StateEstimator: std::fmt::Debug + std::marker::Send + std::marker::Sync + Stateful<
                StateEstimatorRecord,
            > {
            /// Prediction step of the state estimator.
            ///
            /// The prediction step should be able to compute the state of the robot at the given time.
            ///
            /// ## Arguments
            /// * `robot` -- mutable reference on the current [`Robot`] to be able to interact with
            /// other modules.
            /// * `time` -- Time to reach.
            fn prediction_step(&mut self, robot: &mut Node, time: f32);
            /// Correction step of the state estimator.
            ///
            /// The correction step processes the observations. The received observations can be of every
            /// types, the implementation should not assert a specific type.
            ///
            /// ## Arguments
            /// * `robot` -- mutable reference on the current [`Robot`] to be able to interact with
            /// other modules.
            /// * `observations` -- Observation vector.
            /// * `time` -- Current time.
            fn correction_step(
                &mut self,
                robot: &mut Node,
                observations: &Vec<Observation>,
                time: f32,
            );
            /// Return the current estimated state.
            fn state(&self) -> State;
            /// Return the next prediction step time. The correction step
            /// is called for each observation.
            fn next_time_step(&self) -> f32;
        }
        pub struct CentralStateEstimatorRecord {
            pub name: String,
            pub estimator: StateEstimatorRecord,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CentralStateEstimatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "CentralStateEstimatorRecord",
                    "name",
                    &self.name,
                    "estimator",
                    &&self.estimator,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CentralStateEstimatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "CentralStateEstimatorRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "estimator",
                        &self.estimator,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CentralStateEstimatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "estimator" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"estimator" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            CentralStateEstimatorRecord,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CentralStateEstimatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CentralStateEstimatorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CentralStateEstimatorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                StateEstimatorRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct CentralStateEstimatorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(CentralStateEstimatorRecord {
                                name: __field0,
                                estimator: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                StateEstimatorRecord,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "estimator",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateEstimatorRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("estimator")?
                                }
                            };
                            _serde::__private::Ok(CentralStateEstimatorRecord {
                                name: __field0,
                                estimator: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name", "estimator"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CentralStateEstimatorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                CentralStateEstimatorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for CentralStateEstimatorRecord {
            #[inline]
            fn clone(&self) -> CentralStateEstimatorRecord {
                CentralStateEstimatorRecord {
                    name: ::core::clone::Clone::clone(&self.name),
                    estimator: ::core::clone::Clone::clone(&self.estimator),
                }
            }
        }
        pub struct CentralStateEstimatorConfig {
            pub name: String,
            pub robots: Vec<String>,
            #[check]
            pub config: StateEstimatorConfig,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CentralStateEstimatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "CentralStateEstimatorConfig",
                    "name",
                    &self.name,
                    "robots",
                    &self.robots,
                    "config",
                    &&self.config,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CentralStateEstimatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "CentralStateEstimatorConfig",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "robots",
                        &self.robots,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "config",
                        &self.config,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CentralStateEstimatorConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "robots" => _serde::__private::Ok(__Field::__field1),
                                "config" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"robots" => _serde::__private::Ok(__Field::__field1),
                                b"config" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            CentralStateEstimatorConfig,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CentralStateEstimatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CentralStateEstimatorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CentralStateEstimatorConfig with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct CentralStateEstimatorConfig with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                StateEstimatorConfig,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct CentralStateEstimatorConfig with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(CentralStateEstimatorConfig {
                                name: __field0,
                                robots: __field1,
                                config: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                StateEstimatorConfig,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("robots"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("config"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateEstimatorConfig,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("robots")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("config")?
                                }
                            };
                            _serde::__private::Ok(CentralStateEstimatorConfig {
                                name: __field0,
                                robots: __field1,
                                config: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "name",
                        "robots",
                        "config",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CentralStateEstimatorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                CentralStateEstimatorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for CentralStateEstimatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !::config_checker::__check_config(&self.config, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "config",
                                "CentralStateEstimatorConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CentralStateEstimatorConfig {
            #[inline]
            fn clone(&self) -> CentralStateEstimatorConfig {
                CentralStateEstimatorConfig {
                    name: ::core::clone::Clone::clone(&self.name),
                    robots: ::core::clone::Clone::clone(&self.robots),
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        impl Default for CentralStateEstimatorConfig {
            fn default() -> Self {
                Self {
                    name: "central_state_estimator".to_string(),
                    robots: Vec::new(),
                    config: StateEstimatorConfig::Perfect(
                        PerfectEstimatorConfig::default(),
                    ),
                }
            }
        }
        pub struct CentralStateEstimator {
            pub name: String,
            pub robots: Vec<String>,
            pub estimator: Box<dyn StateEstimator>,
        }
        impl CentralStateEstimator {
            pub fn from_config(
                config: &CentralStateEstimatorConfig,
                plugin_api: &Option<Box<&dyn PluginAPI>>,
                global_config: &SimulatorConfig,
                va_factory: &DeterministRandomVariableFactory,
            ) -> Self {
                Self {
                    name: config.name.clone(),
                    robots: config.robots.clone(),
                    estimator: make_state_estimator_from_config(
                        &config.config,
                        plugin_api,
                        global_config,
                        va_factory,
                    ),
                }
            }
            pub fn next_time_step(&self) -> f32 {
                self.estimator.next_time_step()
            }
        }
        impl Stateful<CentralStateEstimatorRecord> for CentralStateEstimator {
            fn from_record(&mut self, record: CentralStateEstimatorRecord) {
                self.estimator.from_record(record.estimator);
            }
            fn record(&self) -> CentralStateEstimatorRecord {
                CentralStateEstimatorRecord {
                    name: self.name.clone(),
                    estimator: self.estimator.record(),
                }
            }
        }
        #[serde(default)]
        #[serde(deny_unknown_fields)]
        pub struct BenchStateEstimatorConfig {
            pub name: String,
            #[check]
            pub config: StateEstimatorConfig,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BenchStateEstimatorConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BenchStateEstimatorConfig",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "config",
                        &self.config,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for BenchStateEstimatorConfig
            where
                BenchStateEstimatorConfig: _serde::__private::Default,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "config" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"config" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_field(__value, FIELDS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de>
                    where
                        BenchStateEstimatorConfig: _serde::__private::Default,
                    {
                        marker: _serde::__private::PhantomData<
                            BenchStateEstimatorConfig,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                    where
                        BenchStateEstimatorConfig: _serde::__private::Default,
                    {
                        type Value = BenchStateEstimatorConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct BenchStateEstimatorConfig",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.name,
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                StateEstimatorConfig,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => __default.config,
                            };
                            _serde::__private::Ok(BenchStateEstimatorConfig {
                                name: __field0,
                                config: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                StateEstimatorConfig,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("config"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateEstimatorConfig,
                                            >(&mut __map)?,
                                        );
                                    }
                                }
                            }
                            let __default: Self::Value = _serde::__private::Default::default();
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => __default.name,
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => __default.config,
                            };
                            _serde::__private::Ok(BenchStateEstimatorConfig {
                                name: __field0,
                                config: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name", "config"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "BenchStateEstimatorConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                BenchStateEstimatorConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for BenchStateEstimatorConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "BenchStateEstimatorConfig",
                    "name",
                    &self.name,
                    "config",
                    &&self.config,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BenchStateEstimatorConfig {
            #[inline]
            fn clone(&self) -> BenchStateEstimatorConfig {
                BenchStateEstimatorConfig {
                    name: ::core::clone::Clone::clone(&self.name),
                    config: ::core::clone::Clone::clone(&self.config),
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for BenchStateEstimatorConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                if !::config_checker::__check_config(&self.config, depth + 1) {
                    ret = false;
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                "NOTE: ".blue(),
                                "\u{21b3}",
                                "config",
                                "BenchStateEstimatorConfig",
                                depth_space,
                            ),
                        );
                    };
                }
                ret
            }
        }
        impl Default for BenchStateEstimatorConfig {
            fn default() -> Self {
                Self {
                    name: String::from("bench_state_estimator"),
                    config: StateEstimatorConfig::Perfect(
                        perfect_estimator::PerfectEstimatorConfig::default(),
                    ),
                }
            }
        }
        pub struct BenchStateEstimatorRecord {
            pub name: String,
            pub record: StateEstimatorRecord,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BenchStateEstimatorRecord {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "BenchStateEstimatorRecord",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "record",
                        &self.record,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for BenchStateEstimatorRecord {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "record" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"record" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            BenchStateEstimatorRecord,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = BenchStateEstimatorRecord;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct BenchStateEstimatorRecord",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct BenchStateEstimatorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                StateEstimatorRecord,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct BenchStateEstimatorRecord with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(BenchStateEstimatorRecord {
                                name: __field0,
                                record: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                StateEstimatorRecord,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("record"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                StateEstimatorRecord,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("record")?
                                }
                            };
                            _serde::__private::Ok(BenchStateEstimatorRecord {
                                name: __field0,
                                record: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["name", "record"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "BenchStateEstimatorRecord",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                BenchStateEstimatorRecord,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for BenchStateEstimatorRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "BenchStateEstimatorRecord",
                    "name",
                    &self.name,
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BenchStateEstimatorRecord {
            #[inline]
            fn clone(&self) -> BenchStateEstimatorRecord {
                BenchStateEstimatorRecord {
                    name: ::core::clone::Clone::clone(&self.name),
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        pub struct BenchStateEstimator {
            pub name: String,
            pub state_estimator: Arc<RwLock<Box<dyn StateEstimator>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BenchStateEstimator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "BenchStateEstimator",
                    "name",
                    &self.name,
                    "state_estimator",
                    &&self.state_estimator,
                )
            }
        }
    }
}
pub mod stateful {
    /*!
The Stateful module defines the [`Stateful`] trait which provides method
to save the state of a struct, and to set the struct in a given state.
*/
    /// Trait providing save and resume state method.
    ///
    /// The generic `RecordType` is the Record which is produced and taken.
    /// See structs like [`RobotRecord`](crate::robot::RobotRecord),
    /// [`StateEstimatorRecord`](crate::state_estimators::state_estimator::StateEstimatorRecord) or
    /// [`PIDRecord`](crate::controllers::pid::PIDRecord).
    ///
    /// The Record should contain the dynamic elements of the struct, to set
    /// the attributes to a previous record. The static elements are not meant to
    /// be in the Record struct.
    ///
    /// Furthermore, the Record is also used to analyse the results. Save inside
    /// the values you want to see in the result log.
    pub trait Stateful<RecordType> {
        /// Generate the current state Record.
        fn record(&self) -> RecordType;
        /// Set the struct in the given `record` state.
        fn from_record(&mut self, record: RecordType);
    }
}
pub mod utils {
    /*!
Module providing different function tools and data structures.
*/
    pub mod determinist_random_variable {
        /*!
# Determinist Random Variable

This module provides a way to create random variables with a deterministic behavior. This is
useful to have a reproducible behavior.

This module proposes a factory to create random variables with a deterministic behavior. The
factory is created with a global seed, and each random variable created with this factory will
have a unique seed, to have a different series of random numbers.

The random variables can be of different types:
- Fixed: always return the same value
- Uniform: return a random value between a min and a max, with a uniform distribution
- Normal: return a random value following a normal distribution
Other types can be added in the future.

 */
        use config_checker::macros::Check;
        use serde::{Deserialize, Serialize};
        use super::distributions::{
            exponential::{
                DeterministExponentialRandomVariable, ExponentialRandomVariableConfig,
            },
            fixed::{DeterministFixedRandomVariable, FixedRandomVariableConfig},
            normal::{DeterministNormalRandomVariable, NormalRandomVariableConfig},
            poisson::{DeterministPoissonRandomVariable, PoissonRandomVariableConfig},
            uniform::{DeterministUniformRandomVariable, UniformRandomVariableConfig},
        };
        /// Factory to create random variables with a deterministic behavior, using a global seed.
        pub struct DeterministRandomVariableFactory {
            /// Global run seed.
            pub global_seed: f32,
        }
        impl DeterministRandomVariableFactory {
            /// Create a new factory with the given `global_seed`.
            pub fn new(global_seed: f32) -> Self {
                Self { global_seed }
            }
            /// Create a new random variable with the given configuration.
            pub fn make_variable(
                &self,
                config: RandomVariableTypeConfig,
            ) -> Box<dyn DeterministRandomVariable> {
                match config {
                    RandomVariableTypeConfig::None => {
                        Box::new(
                            DeterministFixedRandomVariable::from_config(
                                self.global_seed,
                                FixedRandomVariableConfig::default(),
                            ),
                        )
                    }
                    RandomVariableTypeConfig::Fixed(c) => {
                        Box::new(
                            DeterministFixedRandomVariable::from_config(
                                self.global_seed,
                                c,
                            ),
                        )
                    }
                    RandomVariableTypeConfig::Uniform(c) => {
                        Box::new(
                            DeterministUniformRandomVariable::from_config(
                                self.global_seed,
                                c,
                            ),
                        )
                    }
                    RandomVariableTypeConfig::Normal(c) => {
                        Box::new(
                            DeterministNormalRandomVariable::from_config(
                                self.global_seed,
                                c,
                            ),
                        )
                    }
                    RandomVariableTypeConfig::Poisson(c) => {
                        Box::new(
                            DeterministPoissonRandomVariable::from_config(
                                self.global_seed,
                                c,
                            ),
                        )
                    }
                    RandomVariableTypeConfig::Exponential(c) => {
                        Box::new(
                            DeterministExponentialRandomVariable::from_config(
                                self.global_seed,
                                c,
                            ),
                        )
                    }
                }
            }
        }
        impl Default for DeterministRandomVariableFactory {
            fn default() -> Self {
                Self { global_seed: 0. }
            }
        }
        /// Trait for a random variable with a deterministic behavior.
        pub trait DeterministRandomVariable: std::fmt::Debug + std::marker::Send + std::marker::Sync {
            fn gen(&self, time: f32) -> Vec<f32>;
            fn dim(&self) -> usize;
        }
        /// Configuration of the random variable: fixed, uniform or normal.
        #[serde(deny_unknown_fields)]
        pub enum RandomVariableTypeConfig {
            /// No random variable
            None,
            /// Fixed value
            Fixed(FixedRandomVariableConfig),
            /// Uniform distribution
            Uniform(UniformRandomVariableConfig),
            /// Normal distribution
            Normal(NormalRandomVariableConfig),
            Poisson(PoissonRandomVariableConfig),
            Exponential(ExponentialRandomVariableConfig),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RandomVariableTypeConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        RandomVariableTypeConfig::None => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "RandomVariableTypeConfig",
                                0u32,
                                "None",
                            )
                        }
                        RandomVariableTypeConfig::Fixed(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "RandomVariableTypeConfig",
                                1u32,
                                "Fixed",
                                __field0,
                            )
                        }
                        RandomVariableTypeConfig::Uniform(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "RandomVariableTypeConfig",
                                2u32,
                                "Uniform",
                                __field0,
                            )
                        }
                        RandomVariableTypeConfig::Normal(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "RandomVariableTypeConfig",
                                3u32,
                                "Normal",
                                __field0,
                            )
                        }
                        RandomVariableTypeConfig::Poisson(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "RandomVariableTypeConfig",
                                4u32,
                                "Poisson",
                                __field0,
                            )
                        }
                        RandomVariableTypeConfig::Exponential(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "RandomVariableTypeConfig",
                                5u32,
                                "Exponential",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RandomVariableTypeConfig {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 6",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "None" => _serde::__private::Ok(__Field::__field0),
                                "Fixed" => _serde::__private::Ok(__Field::__field1),
                                "Uniform" => _serde::__private::Ok(__Field::__field2),
                                "Normal" => _serde::__private::Ok(__Field::__field3),
                                "Poisson" => _serde::__private::Ok(__Field::__field4),
                                "Exponential" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"None" => _serde::__private::Ok(__Field::__field0),
                                b"Fixed" => _serde::__private::Ok(__Field::__field1),
                                b"Uniform" => _serde::__private::Ok(__Field::__field2),
                                b"Normal" => _serde::__private::Ok(__Field::__field3),
                                b"Poisson" => _serde::__private::Ok(__Field::__field4),
                                b"Exponential" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RandomVariableTypeConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RandomVariableTypeConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum RandomVariableTypeConfig",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(RandomVariableTypeConfig::None)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            FixedRandomVariableConfig,
                                        >(__variant),
                                        RandomVariableTypeConfig::Fixed,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            UniformRandomVariableConfig,
                                        >(__variant),
                                        RandomVariableTypeConfig::Uniform,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            NormalRandomVariableConfig,
                                        >(__variant),
                                        RandomVariableTypeConfig::Normal,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            PoissonRandomVariableConfig,
                                        >(__variant),
                                        RandomVariableTypeConfig::Poisson,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ExponentialRandomVariableConfig,
                                        >(__variant),
                                        RandomVariableTypeConfig::Exponential,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "None",
                        "Fixed",
                        "Uniform",
                        "Normal",
                        "Poisson",
                        "Exponential",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "RandomVariableTypeConfig",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                RandomVariableTypeConfig,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for RandomVariableTypeConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    RandomVariableTypeConfig::None => {
                        ::core::fmt::Formatter::write_str(f, "None")
                    }
                    RandomVariableTypeConfig::Fixed(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Fixed",
                            &__self_0,
                        )
                    }
                    RandomVariableTypeConfig::Uniform(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Uniform",
                            &__self_0,
                        )
                    }
                    RandomVariableTypeConfig::Normal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Normal",
                            &__self_0,
                        )
                    }
                    RandomVariableTypeConfig::Poisson(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Poisson",
                            &__self_0,
                        )
                    }
                    RandomVariableTypeConfig::Exponential(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Exponential",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RandomVariableTypeConfig {
            #[inline]
            fn clone(&self) -> RandomVariableTypeConfig {
                match self {
                    RandomVariableTypeConfig::None => RandomVariableTypeConfig::None,
                    RandomVariableTypeConfig::Fixed(__self_0) => {
                        RandomVariableTypeConfig::Fixed(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RandomVariableTypeConfig::Uniform(__self_0) => {
                        RandomVariableTypeConfig::Uniform(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RandomVariableTypeConfig::Normal(__self_0) => {
                        RandomVariableTypeConfig::Normal(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RandomVariableTypeConfig::Poisson(__self_0) => {
                        RandomVariableTypeConfig::Poisson(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RandomVariableTypeConfig::Exponential(__self_0) => {
                        RandomVariableTypeConfig::Exponential(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::config_checker::ConfigCheckable for RandomVariableTypeConfig {
            fn check(&self) -> bool {
                self.__check(0)
            }
            fn __check(&self, depth: usize) -> bool {
                use colored::Colorize;
                let depth_space = String::from_utf8(
                        ::alloc::vec::from_elem(b' ', depth * 2),
                    )
                    .unwrap();
                let mut ret = true;
                match &self {
                    RandomVariableTypeConfig::Fixed(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Fixed",
                                        "RandomVariableTypeConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    RandomVariableTypeConfig::Uniform(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Uniform",
                                        "RandomVariableTypeConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    RandomVariableTypeConfig::Normal(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Normal",
                                        "RandomVariableTypeConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    RandomVariableTypeConfig::Poisson(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Poisson",
                                        "RandomVariableTypeConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    RandomVariableTypeConfig::Exponential(o) => {
                        if !::config_checker::__check_config(o, depth + 1) {
                            ret = false;
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {4}  {1} From field `{2}` of `{3}`\n",
                                        "NOTE: ".blue(),
                                        "\u{21b3}",
                                        "Exponential",
                                        "RandomVariableTypeConfig",
                                        depth_space,
                                    ),
                                );
                            };
                        }
                    }
                    _ => {}
                };
                ret
            }
        }
    }
    pub mod distributions {
        pub mod bernouilli {
            use config_checker::macros::Check;
            use rand::prelude::*;
            use rand_chacha::ChaCha8Rng;
            use serde::{Deserialize, Serialize};
            use crate::utils::determinist_random_variable::DeterministRandomVariable;
            /// Configuration for a uniform random variable.
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct BernouilliRandomVariableConfig {
                /// Random seed for this random variable.
                pub unique_seed: f32,
                /// Probabilities of the random variable
                pub probability: Vec<f32>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for BernouilliRandomVariableConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "BernouilliRandomVariableConfig",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unique_seed",
                            &self.unique_seed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "probability",
                            &self.probability,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for BernouilliRandomVariableConfig
                where
                    BernouilliRandomVariableConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    "probability" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    b"probability" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            BernouilliRandomVariableConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                BernouilliRandomVariableConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            BernouilliRandomVariableConfig: _serde::__private::Default,
                        {
                            type Value = BernouilliRandomVariableConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct BernouilliRandomVariableConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f32>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.probability,
                                };
                                _serde::__private::Ok(BernouilliRandomVariableConfig {
                                    unique_seed: __field0,
                                    probability: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f32>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "unique_seed",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "probability",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f32>>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.probability,
                                };
                                _serde::__private::Ok(BernouilliRandomVariableConfig {
                                    unique_seed: __field0,
                                    probability: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "unique_seed",
                            "probability",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "BernouilliRandomVariableConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    BernouilliRandomVariableConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for BernouilliRandomVariableConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "BernouilliRandomVariableConfig",
                        "unique_seed",
                        &self.unique_seed,
                        "probability",
                        &&self.probability,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for BernouilliRandomVariableConfig {
                #[inline]
                fn clone(&self) -> BernouilliRandomVariableConfig {
                    BernouilliRandomVariableConfig {
                        unique_seed: ::core::clone::Clone::clone(&self.unique_seed),
                        probability: ::core::clone::Clone::clone(&self.probability),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for BernouilliRandomVariableConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    ret
                }
            }
            impl Default for BernouilliRandomVariableConfig {
                fn default() -> Self {
                    Self {
                        unique_seed: 0.,
                        probability: <[_]>::into_vec(::alloc::boxed::box_new([1.])),
                    }
                }
            }
            pub struct DeterministBernouilliRandomVariable {
                /// Seed used, which is the global seed from the factory + the unique seed from the configuration.
                global_seed: f32,
                /// Probability of the bernouilli distribution.
                probability: Vec<f32>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DeterministBernouilliRandomVariable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "DeterministBernouilliRandomVariable",
                        "global_seed",
                        &self.global_seed,
                        "probability",
                        &&self.probability,
                    )
                }
            }
            impl DeterministBernouilliRandomVariable {
                pub fn from_config(
                    global_seed: f32,
                    config: BernouilliRandomVariableConfig,
                ) -> Self {
                    if !config.probability.iter().all(|x| *x <= 1.) {
                        ::core::panicking::panic(
                            "assertion failed: config.probability.iter().all(|x| *x <= 1.)",
                        )
                    }
                    if !config.probability.iter().all(|x| *x >= 0.) {
                        ::core::panicking::panic(
                            "assertion failed: config.probability.iter().all(|x| *x >= 0.)",
                        )
                    }
                    Self {
                        global_seed: global_seed + config.unique_seed,
                        probability: config.probability,
                    }
                }
            }
            impl DeterministRandomVariable for DeterministBernouilliRandomVariable {
                fn gen(&self, time: f32) -> Vec<f32> {
                    let mut rng = ChaCha8Rng::seed_from_u64(
                        (self.global_seed + time).to_bits() as u64,
                    );
                    let mut v = Vec::new();
                    for p in &self.probability {
                        v.push(if rng.gen::<f32>() <= *p { 1. } else { 0. });
                    }
                    v
                }
                fn dim(&self) -> usize {
                    self.probability.len()
                }
            }
        }
        pub mod exponential {
            use config_checker::macros::Check;
            use rand::prelude::*;
            use rand_chacha::ChaCha8Rng;
            use serde::{Deserialize, Serialize};
            use statrs::distribution::Exp;
            use crate::utils::determinist_random_variable::DeterministRandomVariable;
            /// Configuration for a uniform random variable.
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct ExponentialRandomVariableConfig {
                /// Random seed for this random variable.
                pub unique_seed: f32,
                /// Probabilities of the random variable
                pub lambda: Vec<f64>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ExponentialRandomVariableConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ExponentialRandomVariableConfig",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unique_seed",
                            &self.unique_seed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lambda",
                            &self.lambda,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ExponentialRandomVariableConfig
                where
                    ExponentialRandomVariableConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    "lambda" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    b"lambda" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            ExponentialRandomVariableConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                ExponentialRandomVariableConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            ExponentialRandomVariableConfig: _serde::__private::Default,
                        {
                            type Value = ExponentialRandomVariableConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ExponentialRandomVariableConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.lambda,
                                };
                                _serde::__private::Ok(ExponentialRandomVariableConfig {
                                    unique_seed: __field0,
                                    lambda: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "unique_seed",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("lambda"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.lambda,
                                };
                                _serde::__private::Ok(ExponentialRandomVariableConfig {
                                    unique_seed: __field0,
                                    lambda: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "unique_seed",
                            "lambda",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ExponentialRandomVariableConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ExponentialRandomVariableConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ExponentialRandomVariableConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ExponentialRandomVariableConfig",
                        "unique_seed",
                        &self.unique_seed,
                        "lambda",
                        &&self.lambda,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ExponentialRandomVariableConfig {
                #[inline]
                fn clone(&self) -> ExponentialRandomVariableConfig {
                    ExponentialRandomVariableConfig {
                        unique_seed: ::core::clone::Clone::clone(&self.unique_seed),
                        lambda: ::core::clone::Clone::clone(&self.lambda),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for ExponentialRandomVariableConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    ret
                }
            }
            impl Default for ExponentialRandomVariableConfig {
                fn default() -> Self {
                    Self {
                        unique_seed: 0.,
                        lambda: <[_]>::into_vec(::alloc::boxed::box_new([1.])),
                    }
                }
            }
            pub struct DeterministExponentialRandomVariable {
                /// Seed used, which is the global seed from the factory + the unique seed from the configuration.
                global_seed: f32,
                /// Probability of the Exponential distribution.
                exponential: Vec<Exp>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DeterministExponentialRandomVariable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "DeterministExponentialRandomVariable",
                        "global_seed",
                        &self.global_seed,
                        "exponential",
                        &&self.exponential,
                    )
                }
            }
            impl DeterministExponentialRandomVariable {
                pub fn from_config(
                    global_seed: f32,
                    config: ExponentialRandomVariableConfig,
                ) -> Self {
                    if !config.lambda.iter().all(|x| *x >= 0.) {
                        ::core::panicking::panic(
                            "assertion failed: config.lambda.iter().all(|x| *x >= 0.)",
                        )
                    }
                    Self {
                        global_seed: global_seed + config.unique_seed,
                        exponential: config
                            .lambda
                            .iter()
                            .map(|lambda| Exp::new(*lambda).unwrap())
                            .collect(),
                    }
                }
            }
            impl DeterministRandomVariable for DeterministExponentialRandomVariable {
                fn gen(&self, time: f32) -> Vec<f32> {
                    let mut rng = ChaCha8Rng::seed_from_u64(
                        (self.global_seed + time).to_bits() as u64,
                    );
                    let mut v = Vec::new();
                    for p in &self.exponential {
                        v.push(p.sample(&mut rng) as f32);
                    }
                    v
                }
                fn dim(&self) -> usize {
                    self.exponential.len()
                }
            }
        }
        pub mod fixed {
            use config_checker::macros::Check;
            use serde::{Deserialize, Serialize};
            use crate::utils::determinist_random_variable::DeterministRandomVariable;
            /// Configuration for a fixed random variable.
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct FixedRandomVariableConfig {
                /// Fixed value to return.
                values: Vec<f32>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for FixedRandomVariableConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "FixedRandomVariableConfig",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "values",
                            &self.values,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for FixedRandomVariableConfig
                where
                    FixedRandomVariableConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 1",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "values" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"values" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            FixedRandomVariableConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                FixedRandomVariableConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            FixedRandomVariableConfig: _serde::__private::Default,
                        {
                            type Value = FixedRandomVariableConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct FixedRandomVariableConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f32>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.values,
                                };
                                _serde::__private::Ok(FixedRandomVariableConfig {
                                    values: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Vec<f32>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("values"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f32>>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.values,
                                };
                                _serde::__private::Ok(FixedRandomVariableConfig {
                                    values: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["values"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "FixedRandomVariableConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    FixedRandomVariableConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for FixedRandomVariableConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "FixedRandomVariableConfig",
                        "values",
                        &&self.values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for FixedRandomVariableConfig {
                #[inline]
                fn clone(&self) -> FixedRandomVariableConfig {
                    FixedRandomVariableConfig {
                        values: ::core::clone::Clone::clone(&self.values),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for FixedRandomVariableConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    ret
                }
            }
            impl Default for FixedRandomVariableConfig {
                fn default() -> Self {
                    Self {
                        values: <[_]>::into_vec(::alloc::boxed::box_new([0.])),
                    }
                }
            }
            /// Random variable which always return the same value.
            pub struct DeterministFixedRandomVariable {
                values: Vec<f32>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DeterministFixedRandomVariable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "DeterministFixedRandomVariable",
                        "values",
                        &&self.values,
                    )
                }
            }
            impl DeterministFixedRandomVariable {
                pub fn from_config(
                    _global_seed: f32,
                    config: FixedRandomVariableConfig,
                ) -> Self {
                    Self { values: config.values }
                }
            }
            impl DeterministRandomVariable for DeterministFixedRandomVariable {
                fn gen(&self, _time: f32) -> Vec<f32> {
                    self.values.clone()
                }
                fn dim(&self) -> usize {
                    self.values.len()
                }
            }
        }
        pub mod normal {
            use config_checker::macros::Check;
            use rand::prelude::*;
            use rand_chacha::ChaCha8Rng;
            use serde::{Deserialize, Serialize};
            use statrs::{distribution::MultivariateNormal, statistics::MeanN};
            use crate::utils::determinist_random_variable::DeterministRandomVariable;
            /// Configuration for a normal random variable.
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct NormalRandomVariableConfig {
                /// Random seed for this random variable.
                unique_seed: f32,
                /// Mean of the normal distribution.
                mean: Vec<f64>,
                /// Variance of the normal distribution.
                covariance: Vec<f64>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for NormalRandomVariableConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "NormalRandomVariableConfig",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unique_seed",
                            &self.unique_seed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mean",
                            &self.mean,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "covariance",
                            &self.covariance,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for NormalRandomVariableConfig
                where
                    NormalRandomVariableConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    "mean" => _serde::__private::Ok(__Field::__field1),
                                    "covariance" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    b"mean" => _serde::__private::Ok(__Field::__field1),
                                    b"covariance" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            NormalRandomVariableConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                NormalRandomVariableConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            NormalRandomVariableConfig: _serde::__private::Default,
                        {
                            type Value = NormalRandomVariableConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct NormalRandomVariableConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.mean,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.covariance,
                                };
                                _serde::__private::Ok(NormalRandomVariableConfig {
                                    unique_seed: __field0,
                                    mean: __field1,
                                    covariance: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<f64>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "unique_seed",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("mean"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "covariance",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.mean,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.covariance,
                                };
                                _serde::__private::Ok(NormalRandomVariableConfig {
                                    unique_seed: __field0,
                                    mean: __field1,
                                    covariance: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "unique_seed",
                            "mean",
                            "covariance",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "NormalRandomVariableConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    NormalRandomVariableConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for NormalRandomVariableConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NormalRandomVariableConfig",
                        "unique_seed",
                        &self.unique_seed,
                        "mean",
                        &self.mean,
                        "covariance",
                        &&self.covariance,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NormalRandomVariableConfig {
                #[inline]
                fn clone(&self) -> NormalRandomVariableConfig {
                    NormalRandomVariableConfig {
                        unique_seed: ::core::clone::Clone::clone(&self.unique_seed),
                        mean: ::core::clone::Clone::clone(&self.mean),
                        covariance: ::core::clone::Clone::clone(&self.covariance),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for NormalRandomVariableConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    ret
                }
            }
            impl Default for NormalRandomVariableConfig {
                fn default() -> Self {
                    Self {
                        unique_seed: 0.,
                        mean: <[_]>::into_vec(::alloc::boxed::box_new([0.])),
                        covariance: <[_]>::into_vec(::alloc::boxed::box_new([1.])),
                    }
                }
            }
            /// Random variable which return a random value following a normal distribution.
            pub struct DeterministNormalRandomVariable {
                /// Seed used, which is the global seed from the factory + the unique seed from the configuration.
                global_seed: f32,
                /// Normal distribution.
                nd: MultivariateNormal,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DeterministNormalRandomVariable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "DeterministNormalRandomVariable",
                        "global_seed",
                        &self.global_seed,
                        "nd",
                        &&self.nd,
                    )
                }
            }
            impl DeterministNormalRandomVariable {
                pub fn from_config(
                    global_seed: f32,
                    config: NormalRandomVariableConfig,
                ) -> Self {
                    if !(config.mean.len().pow(2) == config.covariance.len()) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "The length of the covariance vector should be the square of the means\' one.",
                                ),
                            );
                        }
                    }
                    Self {
                        global_seed: global_seed + config.unique_seed,
                        nd: MultivariateNormal::new(config.mean, config.covariance)
                            .expect("Impossible to create the normal distribution"),
                    }
                }
            }
            impl DeterministRandomVariable for DeterministNormalRandomVariable {
                fn gen(&self, time: f32) -> Vec<f32> {
                    let mut rng = ChaCha8Rng::seed_from_u64(
                        (self.global_seed + time).to_bits() as u64,
                    );
                    self.nd.sample(&mut rng).iter().map(|x| *x as f32).collect()
                }
                fn dim(&self) -> usize {
                    self.nd.mean().unwrap().len()
                }
            }
        }
        pub mod poisson {
            use config_checker::macros::Check;
            use rand::prelude::*;
            use rand_chacha::ChaCha8Rng;
            use serde::{Deserialize, Serialize};
            use statrs::distribution::Poisson;
            use crate::utils::determinist_random_variable::DeterministRandomVariable;
            /// Configuration for a uniform random variable.
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct PoissonRandomVariableConfig {
                /// Random seed for this random variable.
                pub unique_seed: f32,
                /// Probabilities of the random variable
                pub lambda: Vec<f64>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PoissonRandomVariableConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PoissonRandomVariableConfig",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unique_seed",
                            &self.unique_seed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lambda",
                            &self.lambda,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PoissonRandomVariableConfig
                where
                    PoissonRandomVariableConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    "lambda" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    b"lambda" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            PoissonRandomVariableConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                PoissonRandomVariableConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            PoissonRandomVariableConfig: _serde::__private::Default,
                        {
                            type Value = PoissonRandomVariableConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PoissonRandomVariableConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.lambda,
                                };
                                _serde::__private::Ok(PoissonRandomVariableConfig {
                                    unique_seed: __field0,
                                    lambda: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f64>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "unique_seed",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("lambda"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f64>>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.lambda,
                                };
                                _serde::__private::Ok(PoissonRandomVariableConfig {
                                    unique_seed: __field0,
                                    lambda: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "unique_seed",
                            "lambda",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PoissonRandomVariableConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PoissonRandomVariableConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PoissonRandomVariableConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PoissonRandomVariableConfig",
                        "unique_seed",
                        &self.unique_seed,
                        "lambda",
                        &&self.lambda,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PoissonRandomVariableConfig {
                #[inline]
                fn clone(&self) -> PoissonRandomVariableConfig {
                    PoissonRandomVariableConfig {
                        unique_seed: ::core::clone::Clone::clone(&self.unique_seed),
                        lambda: ::core::clone::Clone::clone(&self.lambda),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for PoissonRandomVariableConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    ret
                }
            }
            impl Default for PoissonRandomVariableConfig {
                fn default() -> Self {
                    Self {
                        unique_seed: 0.,
                        lambda: <[_]>::into_vec(::alloc::boxed::box_new([1.])),
                    }
                }
            }
            pub struct DeterministPoissonRandomVariable {
                /// Seed used, which is the global seed from the factory + the unique seed from the configuration.
                global_seed: f32,
                /// Probability of the Poisson distribution.
                poisson: Vec<Poisson>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DeterministPoissonRandomVariable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "DeterministPoissonRandomVariable",
                        "global_seed",
                        &self.global_seed,
                        "poisson",
                        &&self.poisson,
                    )
                }
            }
            impl DeterministPoissonRandomVariable {
                pub fn from_config(
                    global_seed: f32,
                    config: PoissonRandomVariableConfig,
                ) -> Self {
                    if !config.lambda.iter().all(|x| *x >= 0.) {
                        ::core::panicking::panic(
                            "assertion failed: config.lambda.iter().all(|x| *x >= 0.)",
                        )
                    }
                    Self {
                        global_seed: global_seed + config.unique_seed,
                        poisson: config
                            .lambda
                            .iter()
                            .map(|lambda| Poisson::new(*lambda).unwrap())
                            .collect(),
                    }
                }
            }
            impl DeterministRandomVariable for DeterministPoissonRandomVariable {
                fn gen(&self, time: f32) -> Vec<f32> {
                    let mut rng = ChaCha8Rng::seed_from_u64(
                        (self.global_seed + time).to_bits() as u64,
                    );
                    let mut v = Vec::new();
                    for p in &self.poisson {
                        v.push(p.sample(&mut rng) as f32);
                    }
                    v
                }
                fn dim(&self) -> usize {
                    self.poisson.len()
                }
            }
        }
        pub mod uniform {
            use std::iter::zip;
            use config_checker::macros::Check;
            use rand::prelude::*;
            use rand_chacha::ChaCha8Rng;
            use serde::{Deserialize, Serialize};
            use crate::utils::determinist_random_variable::DeterministRandomVariable;
            /// Configuration for a uniform random variable.
            #[serde(default)]
            #[serde(deny_unknown_fields)]
            pub struct UniformRandomVariableConfig {
                /// Random seed for this random variable.
                pub unique_seed: f32,
                /// Minimum value of the uniform distribution.
                pub min: Vec<f32>,
                /// Maximum value of the uniform distribution.
                pub max: Vec<f32>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UniformRandomVariableConfig {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UniformRandomVariableConfig",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unique_seed",
                            &self.unique_seed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "min",
                            &self.min,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "max",
                            &self.max,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UniformRandomVariableConfig
                where
                    UniformRandomVariableConfig: _serde::__private::Default,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"field index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    "min" => _serde::__private::Ok(__Field::__field1),
                                    "max" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unique_seed" => _serde::__private::Ok(__Field::__field0),
                                    b"min" => _serde::__private::Ok(__Field::__field1),
                                    b"max" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_field(__value, FIELDS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de>
                        where
                            UniformRandomVariableConfig: _serde::__private::Default,
                        {
                            marker: _serde::__private::PhantomData<
                                UniformRandomVariableConfig,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                        where
                            UniformRandomVariableConfig: _serde::__private::Default,
                        {
                            type Value = UniformRandomVariableConfig;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UniformRandomVariableConfig",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f32>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.min,
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Vec<f32>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => __default.max,
                                };
                                _serde::__private::Ok(UniformRandomVariableConfig {
                                    unique_seed: __field0,
                                    min: __field1,
                                    max: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<f32>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<f32>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "unique_seed",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("min"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f32>>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("max"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<f32>>(&mut __map)?,
                                            );
                                        }
                                    }
                                }
                                let __default: Self::Value = _serde::__private::Default::default();
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => __default.unique_seed,
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => __default.min,
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => __default.max,
                                };
                                _serde::__private::Ok(UniformRandomVariableConfig {
                                    unique_seed: __field0,
                                    min: __field1,
                                    max: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "unique_seed",
                            "min",
                            "max",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UniformRandomVariableConfig",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UniformRandomVariableConfig,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UniformRandomVariableConfig {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "UniformRandomVariableConfig",
                        "unique_seed",
                        &self.unique_seed,
                        "min",
                        &self.min,
                        "max",
                        &&self.max,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UniformRandomVariableConfig {
                #[inline]
                fn clone(&self) -> UniformRandomVariableConfig {
                    UniformRandomVariableConfig {
                        unique_seed: ::core::clone::Clone::clone(&self.unique_seed),
                        min: ::core::clone::Clone::clone(&self.min),
                        max: ::core::clone::Clone::clone(&self.max),
                    }
                }
            }
            #[automatically_derived]
            impl ::config_checker::ConfigCheckable for UniformRandomVariableConfig {
                fn check(&self) -> bool {
                    self.__check(0)
                }
                fn __check(&self, depth: usize) -> bool {
                    use colored::Colorize;
                    let depth_space = String::from_utf8(
                            ::alloc::vec::from_elem(b' ', depth * 2),
                        )
                        .unwrap();
                    let mut ret = true;
                    ret
                }
            }
            impl Default for UniformRandomVariableConfig {
                fn default() -> Self {
                    Self {
                        unique_seed: 0.,
                        min: <[_]>::into_vec(::alloc::boxed::box_new([-1.])),
                        max: <[_]>::into_vec(::alloc::boxed::box_new([1.])),
                    }
                }
            }
            /// Random variable which return a random value between a min and a max, with a uniform distribution.
            pub struct DeterministUniformRandomVariable {
                /// Seed used, which is the global seed from the factory + the unique seed from the configuration.
                global_seed: f32,
                /// Minimum value of the uniform distribution.
                min: Vec<f32>,
                /// Maximum value of the uniform distribution.
                max: Vec<f32>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DeterministUniformRandomVariable {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "DeterministUniformRandomVariable",
                        "global_seed",
                        &self.global_seed,
                        "min",
                        &self.min,
                        "max",
                        &&self.max,
                    )
                }
            }
            impl DeterministUniformRandomVariable {
                pub fn from_config(
                    global_seed: f32,
                    config: UniformRandomVariableConfig,
                ) -> Self {
                    if !(config.max.len() == config.min.len()) {
                        ::core::panicking::panic(
                            "assertion failed: config.max.len() == config.min.len()",
                        )
                    }
                    for (min, max) in zip(&config.min, &config.max) {
                        if !(min <= max) {
                            ::core::panicking::panic("assertion failed: min <= max")
                        }
                    }
                    Self {
                        global_seed: global_seed + config.unique_seed,
                        min: config.min,
                        max: config.max,
                    }
                }
            }
            impl DeterministRandomVariable for DeterministUniformRandomVariable {
                fn gen(&self, time: f32) -> Vec<f32> {
                    let mut rng = ChaCha8Rng::seed_from_u64(
                        (self.global_seed + time).to_bits() as u64,
                    );
                    let mut v = Vec::new();
                    for (min, max) in zip(&self.min, &self.max) {
                        v.push(min + rng.gen::<f32>() * (max - min));
                    }
                    v
                }
                fn dim(&self) -> usize {
                    self.max.len()
                }
            }
        }
    }
    pub mod geometry {
        /*!
Provide geometry tools.
*/
        extern crate nalgebra as na;
        use std::f32::consts::PI;
        use na::SVector;
        /// Computes the projection of a point on a segment.
        ///
        /// If the projected point is out of the segment, the closest segment point is selected.
        ///
        /// ## Arguments
        /// * `point` -- Point to project.
        /// * `p1` -- Point 1 of the segment.
        /// * `p2` -- Point 2 of the segment.
        ///
        /// ## Return
        /// Projected point.
        pub fn project_point(
            point: SVector<f32, 2>,
            p1: SVector<f32, 2>,
            p2: SVector<f32, 2>,
        ) -> SVector<f32, 2> {
            let x_1 = p1.x;
            let y_1 = p1.y;
            let x_n = p2.x - x_1;
            let y_n = p2.y - y_1;
            let d_n = (x_n * x_n + y_n * y_n).sqrt();
            let x_n = x_n / d_n;
            let y_n = y_n / d_n;
            let projected_point_distance = (point.x - x_1) * x_n + (point.y - y_1) * y_n;
            let projected_point_distance = (0.0f32)
                .max(d_n.min(projected_point_distance));
            SVector::<
                f32,
                2,
            >::new(
                x_1 + projected_point_distance * x_n,
                y_1 + projected_point_distance * y_n,
            )
        }
        pub fn mod2pi(f: f32) -> f32 {
            let mut f = f;
            while f > PI {
                f -= 2. * PI;
            }
            while f <= -PI {
                f += 2. * PI;
            }
            f
        }
        /// Computes the smallest difference between two angles,
        /// i.e. the difference between `a` and `b` in the range `[-PI/2, PI/2]` (a-b).
        pub fn smallest_theta_diff(a: f32, b: f32) -> f32 {
            let mut diff = a - b;
            if diff > PI {
                diff = a - (b + 2. * PI);
            } else if diff <= -PI {
                diff = a + 2. * PI - b;
            }
            diff
        }
    }
    pub mod maths {
        use crate::errors::{SimbaError, SimbaErrorTypes};
        pub fn closest_uint_modulo(
            numerator: f32,
            denumerator: f32,
        ) -> Result<u32, SimbaError> {
            let float_mod = numerator / denumerator;
            if float_mod < 0. {
                return Err(
                    SimbaError::new(
                        SimbaErrorTypes::MathError,
                        "closest_uint_modulo with negative division!",
                    ),
                );
            }
            let floor = float_mod.floor();
            let ceil = float_mod.ceil();
            if float_mod - floor < ceil - float_mod {
                return Ok(floor as u32);
            }
            Ok(ceil as u32)
        }
        pub fn round_precision(number: f32, precision: f32) -> Result<f32, SimbaError> {
            if precision <= 0. {
                return Err(
                    SimbaError::new(
                        SimbaErrorTypes::MathError,
                        "`precision` given to `round_precision` should be strictly positive",
                    ),
                );
            }
            Ok((number / precision).round_ties_even() * precision)
        }
    }
    pub mod rfc {
        use std::sync::{mpsc, Arc, Mutex};
        use crate::errors::SimbaResult;
        pub struct RemoteFunctionCall<ParamType: Clone, ReturnType: Clone> {
            sender: mpsc::Sender<ParamType>,
            receiver: Arc<Mutex<mpsc::Receiver<ReturnType>>>,
        }
        #[automatically_derived]
        impl<
            ParamType: ::core::clone::Clone + Clone,
            ReturnType: ::core::clone::Clone + Clone,
        > ::core::clone::Clone for RemoteFunctionCall<ParamType, ReturnType> {
            #[inline]
            fn clone(&self) -> RemoteFunctionCall<ParamType, ReturnType> {
                RemoteFunctionCall {
                    sender: ::core::clone::Clone::clone(&self.sender),
                    receiver: ::core::clone::Clone::clone(&self.receiver),
                }
            }
        }
        impl<
            ParamType: Clone,
            ReturnType: Clone,
        > RemoteFunctionCall<ParamType, ReturnType> {
            pub fn call(&self, param: ParamType) -> SimbaResult<ReturnType> {
                self.sender.send(param).unwrap();
                let result = self.receiver.lock().unwrap().recv().unwrap();
                Ok(result)
            }
            pub fn async_call(&self, param: ParamType) {
                self.sender.send(param).unwrap();
            }
            /// Blocking
            pub fn wait_result(&self) -> SimbaResult<ReturnType> {
                let result = self.receiver.lock().unwrap().recv().unwrap();
                Ok(result)
            }
            /// Non Blocking
            pub fn try_get_result(&self) -> Option<SimbaResult<ReturnType>> {
                if let Ok(result) = self.receiver.lock().unwrap().try_recv() {
                    Some(Ok(result))
                } else {
                    None
                }
            }
        }
        pub struct RemoteFunctionCallHost<ParamType: Clone, ReturnType: Clone> {
            receiver: Arc<Mutex<mpsc::Receiver<ParamType>>>,
            sender: mpsc::Sender<ReturnType>,
        }
        #[automatically_derived]
        impl<
            ParamType: ::core::clone::Clone + Clone,
            ReturnType: ::core::clone::Clone + Clone,
        > ::core::clone::Clone for RemoteFunctionCallHost<ParamType, ReturnType> {
            #[inline]
            fn clone(&self) -> RemoteFunctionCallHost<ParamType, ReturnType> {
                RemoteFunctionCallHost {
                    receiver: ::core::clone::Clone::clone(&self.receiver),
                    sender: ::core::clone::Clone::clone(&self.sender),
                }
            }
        }
        impl<
            ParamType: Clone,
            ReturnType: Clone,
        > RemoteFunctionCallHost<ParamType, ReturnType> {
            pub fn try_recv_fn(&self, exe: fn(ParamType) -> ReturnType) {
                if let Ok(param) = self.receiver.lock().unwrap().try_recv() {
                    let result = exe(param);
                    self.sender.send(result).unwrap();
                }
            }
            pub fn try_recv_closure(&self, exe: impl Fn(ParamType) -> ReturnType) {
                if let Ok(param) = self.receiver.lock().unwrap().try_recv() {
                    let result = exe(param);
                    self.sender.send(result).unwrap();
                }
            }
            pub fn try_recv_closure_mut(
                &self,
                mut exe: impl FnMut(ParamType) -> ReturnType,
            ) {
                if let Ok(param) = self.receiver.lock().unwrap().try_recv() {
                    let result = exe(param);
                    self.sender.send(result).unwrap();
                }
            }
        }
        pub fn make_pair<ParamType: Clone, ReturnType: Clone>() -> (
            RemoteFunctionCall<ParamType, ReturnType>,
            RemoteFunctionCallHost<ParamType, ReturnType>,
        ) {
            let call_pipe = mpsc::channel();
            let return_pipe = mpsc::channel();
            (
                RemoteFunctionCall {
                    sender: call_pipe.0,
                    receiver: Arc::new(Mutex::new(return_pipe.1)),
                },
                RemoteFunctionCallHost {
                    sender: return_pipe.0,
                    receiver: Arc::new(Mutex::new(call_pipe.1)),
                },
            )
        }
    }
    pub mod time_ordered_data {
        /*!
Module providing a data structure to store data with a timestamp, with
increasing order.
*/
        use core::slice::{Iter, IterMut};
        use std::iter::Skip;
        use std::vec::Vec;
        use crate::constants::TIME_ROUND;
        /// Data structure to store ordered timed data.
        ///
        /// The generic is the Type to be stored. For now, the time is stored
        /// using `f32` without possibility of modifying it.
        ///
        /// ## Example
        /// ```
        /// use simba::utils::time_ordered_data::TimeOrderedData;
        ///
        /// let mut tod = TimeOrderedData::<String>::new();
        /// tod.insert(2.1, String::from("Hello1"), true);
        /// tod.insert(2.9, String::from("Hello2"), true);
        /// tod.insert(2.6, String::from("Hello3"), true);
        ///
        /// for data in tod.iter_from_time(2.2) {
        ///     println!("Time {}: {}", data.0, data.1);
        /// }
        /// ```
        ///
        /// Output:
        /// ```txt
        /// Time 2.6: Hello3
        /// Time 2.9: Hello2
        /// ```
        ///
        pub struct TimeOrderedData<T> {
            /// Data structure. WARNING: the sort is done during the insertion,
            /// and is not checked after !
            data: Vec<(f32, T)>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for TimeOrderedData<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "TimeOrderedData",
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for TimeOrderedData<T> {
            #[inline]
            fn clone(&self) -> TimeOrderedData<T> {
                TimeOrderedData {
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        impl<T> TimeOrderedData<T> {
            /// Creates a new empty data structure.
            pub fn new() -> Self {
                Self { data: Vec::new() }
            }
            /// Find the index equal or just after the required time.
            ///
            /// This function was primarly made for insertion. So the position returned
            /// is the position where to insert a new element.
            ///
            /// ## Arguments
            /// * `time` -- timestamp looked for.
            ///
            /// ## Return
            /// * `usize` -- position of the element with equal time or just after.
            /// * `bool` -- Is the element found is equal (the position is then this element).
            fn find_time_position(&self, time: f32) -> (usize, bool) {
                let mut pos = self.data.len();
                while pos > 0 {
                    let pos_time = self.data[pos - 1].0;
                    if pos_time < time - TIME_ROUND / 2. {
                        return (pos, false);
                    } else if (pos_time - time).abs() < TIME_ROUND / 2. {
                        pos = pos - 1;
                        return (pos, true);
                    }
                    pos = pos - 1;
                }
                return (pos, false);
            }
            /// Insert an element at the given time.
            ///
            /// ## Arguments
            /// * `time` -- Time where to insert the new element.
            /// * `data` -- Element to insert.
            /// * `do_erase` -- Erase or not if an element is already at the same timestamp.
            /// If it does not erase, multiple elements will have the same timestamp.
            ///
            /// TODO: test without erase, if all elements come out by iter.
            pub fn insert(&mut self, time: f32, data: T, do_erase: bool) {
                let (pos, exact) = self.find_time_position(time);
                if exact {
                    if do_erase {
                        self.data[pos] = (time, data);
                    } else {
                        self.data.insert(pos + 1, (time, data));
                    }
                } else {
                    self.data.insert(pos, (time, data));
                }
            }
            /// Get a mutable reference on the data just before or at the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, mutable reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is below the minimal time.
            pub fn get_data_beq_time_mut(
                &mut self,
                mut time: f32,
            ) -> Option<(f32, &mut T)> {
                for (data_time, ref mut data) in self.data.iter_mut().rev() {
                    if data_time <= &mut time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a reference on the data just before or at the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is below the minimal time.
            pub fn get_data_beq_time(&self, time: f32) -> Option<(f32, &T)> {
                for (data_time, data) in self.data.iter().rev() {
                    if data_time <= &time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a mutable reference on the data strictly before the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, mutable reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is below the minimal time.
            pub fn get_data_before_time_mut(
                &mut self,
                mut time: f32,
            ) -> Option<(f32, &mut T)> {
                for (data_time, ref mut data) in self.data.iter_mut().rev() {
                    if data_time < &mut time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a reference on the data strictly before the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is below the minimal time.
            pub fn get_data_before_time(&self, time: f32) -> Option<(f32, &T)> {
                for (data_time, data) in self.data.iter().rev() {
                    if data_time < &time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a mutable reference on the data just after or at the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, mutable reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is after the maximal time.
            pub fn get_data_geq_time_mut(
                &mut self,
                mut time: f32,
            ) -> Option<(f32, &mut T)> {
                for (data_time, ref mut data) in self.data.iter_mut() {
                    if data_time >= &mut time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a reference on the data just after or at the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is after the maximal time.
            pub fn get_data_geq_time(&self, time: f32) -> Option<(f32, &T)> {
                for (data_time, data) in self.data.iter() {
                    if data_time >= &time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a mutable reference on the data strictly after the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, mutable reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is after the maximal time.
            pub fn get_data_after_time_mut(
                &mut self,
                mut time: f32,
            ) -> Option<(f32, &mut T)> {
                for (data_time, ref mut data) in self.data.iter_mut() {
                    if data_time > &mut time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a reference on the data strictly after the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, reference on data)` if a data was found.
            /// * `None` if no data was found, e.g. if `time` is after the maximal time.
            pub fn get_data_after_time(&self, time: f32) -> Option<(f32, &T)> {
                for (data_time, data) in self.data.iter() {
                    if data_time > &time {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a reference on the data strictly (within 1e-15) at the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, reference on data)` if a data was found.
            /// * `None` if no data was found at this `time`.
            pub fn get_data_at_time(&self, time: f32) -> Option<(f32, &T)> {
                for (data_time, data) in self.data.iter() {
                    if (data_time - &time).abs() < TIME_ROUND / 2. {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Get a mutable reference on the data strictly (within 1e-15) at the given `time`.
            ///
            /// ## Return
            /// Return an Option with:
            /// * `Some(time, mutable reference on data)` if a data was found.
            /// * `None` if no data was found at this `time`.
            pub fn get_data_at_time_mut(&mut self, time: f32) -> Option<(f32, &mut T)> {
                for (data_time, ref mut data) in self.data.iter_mut() {
                    if (*data_time - time).abs() < TIME_ROUND / 2. {
                        return Some((time, data));
                    }
                }
                None
            }
            /// Provide an iterator from the given `time`, in the chronological order.
            ///
            /// If `time` is an existent time, the iterator starts at this position.
            pub fn iter_from_time(&self, time: f32) -> Skip<Iter<'_, (f32, T)>> {
                let (mut pos, _) = self.find_time_position(time);
                while pos > 0 && (self.data[pos - 1].0 - time).abs() < TIME_ROUND / 2. {
                    pos -= 1;
                }
                self.data.iter().skip(pos)
            }
            /// Provide an mutable iterator from the given `time`, in the chronological order.
            ///
            /// If `time` is an existent time, the iterator starts at this position.
            pub fn iter_from_time_mut(
                &mut self,
                time: f32,
            ) -> Skip<IterMut<'_, (f32, T)>> {
                let (pos, _) = self.find_time_position(time);
                self.data.iter_mut().skip(pos)
            }
            /// Provide an iterator which goes on all the data in the chronological order.
            pub fn iter(&self) -> impl Iterator<Item = &(f32, T)> {
                self.data.iter()
            }
            /// Remove a data at the given `time` and returns it.
            ///
            /// If there is no data at the given time, `None` is returned.
            pub fn remove(&mut self, time: f32) -> Option<(f32, T)> {
                let (pos, exact) = self.find_time_position(time);
                if !exact {
                    return None;
                }
                Some(self.data.remove(pos))
            }
            /// Size of the data structure.
            pub fn len(&self) -> usize {
                self.data.len()
            }
            /// Minimal time in the data structure.
            pub fn min_time(&self) -> Option<(f32, &T)> {
                if self.len() == 0 {
                    None
                } else {
                    Some((self.data[0].0, &self.data[0].1))
                }
            }
            /// Maximal time in the data structure.
            pub fn max_time(&self) -> Option<(f32, &T)> {
                if self.len() == 0 {
                    None
                } else {
                    Some((self.data[self.len() - 1].0, &self.data[self.len() - 1].1))
                }
            }
        }
    }
    pub mod enum_tools {
        pub trait ToVec<T> {
            fn to_vec() -> Vec<T>;
        }
        pub trait FromString
        where
            Self: Sized,
        {
            fn from_string(str: &String) -> Option<Self>;
        }
    }
}
pub mod plugin_api {
    /*!
Module providing the trait to link the simulator to external implementations.

Example to use an external state estimator:
```ignore
use simba::state_estimators::state_estimator::StateEstimator;
use simba::{plugin_api::PluginAPI, simulator::SimulatorConfig};

use serde_json::Value;

pub struct MyPlugin;

impl PluginAPI for MyPlugin {
    fn get_state_estimator(
        &self,
        config: &Value,
        global_config: &SimulatorConfig,
    ) -> Box<dyn StateEstimator> {
        Box::new(MyFilter::from_config(
            &serde_json::from_value(config.clone())
                .expect("Error during parsing MyFilter config"),
        ))
    }
}
// You should use the simulator as a library. Your main.rs could be:

use simba::simulator::Simulator;
use std::path::Path;

fn main() {
    let plugin = MyPlugin {};

    let config_path = Path::new("configs/simulator_config.yaml");
    let mut simulator = Simulator::from_config_path(
        config_path,
        &Some(Box::new(plugin)),
        );

    simulator.run();


}
```
*/
    use std::sync::{Arc, RwLock};
    use crate::{
        controllers::controller::Controller, navigators::navigator::Navigator,
        networking::message_handler::MessageHandler, node::Node, physics::physic::Physic,
        simulator::SimulatorConfig, state_estimators::state_estimator::StateEstimator,
    };
    use serde_json::Value;
    /// Trait to link the simulator to the external implementation.
    pub trait PluginAPI: Send + Sync {
        /// Return the [`StateEstimator`] to be used by the
        /// [`ExternalEstimator`](`crate::state_estimators::external_estimator::ExternalEstimator`).
        ///
        /// # Arguments
        /// * `config` - Config for the external state estimator. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`StateEstimator`] to use.
        fn get_state_estimator(
            &self,
            _config: &Value,
            _global_config: &SimulatorConfig,
        ) -> Box<dyn StateEstimator> {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "The given PluginAPI does not provide a state estimator",
                    ),
                );
            };
        }
        /// Return the [`Controller`] to be used by the
        /// [`ExternalController`](`crate::controllers::external_controller::ExternalController`).
        ///
        /// # Arguments
        /// * `config` - Config for the external controller. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`Controller`] to use.
        fn get_controller(
            &self,
            _config: &Value,
            _global_config: &SimulatorConfig,
        ) -> Box<dyn Controller> {
            {
                ::core::panicking::panic_fmt(
                    format_args!("The given PluginAPI does not provide a controller"),
                );
            };
        }
        /// Return the [`Navigator`] to be used by the
        /// [`ExternalNavigator`](`crate::navigators::external_navigator::ExternalNavigator`).
        ///
        /// # Arguments
        /// * `config` - Config for the external navigator. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`Navigator`] to use.
        fn get_navigator(
            &self,
            _config: &Value,
            _global_config: &SimulatorConfig,
        ) -> Box<dyn Navigator> {
            {
                ::core::panicking::panic_fmt(
                    format_args!("The given PluginAPI does not provide a navigator"),
                );
            };
        }
        /// Return the [`Physic`] to be used by the
        /// [`ExternalPhysic`](`crate::physics::external_physic::ExternalPhysic`).
        ///
        /// # Arguments
        /// * `config` - Config for the external physic. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`Physic`] to use.
        fn get_physic(
            &self,
            _config: &Value,
            _global_config: &SimulatorConfig,
        ) -> Box<dyn Physic> {
            {
                ::core::panicking::panic_fmt(
                    format_args!("The given PluginAPI does not provide a physic"),
                );
            };
        }
        fn get_message_handlers(
            &self,
            _robot: &Node,
        ) -> Option<Vec<Arc<RwLock<dyn MessageHandler>>>> {
            None
        }
    }
}
pub mod pybinds {
    use log::debug;
    use pyo3::prelude::*;
    use serde_json::Value;
    use crate::{
        controllers::{controller::Controller, pybinds::PythonController},
        logger::is_enabled, navigators::{navigator::Navigator, pybinds::PythonNavigator},
        physics::{physic::Physic, pybinds::PythonPhysic},
        pywrappers::{
            CommandWrapper, ControllerErrorWrapper, GNSSObservationWrapper,
            ObservationWrapper, OdometryObservationWrapper,
            OrientedLandmarkObservationWrapper, OrientedRobotObservationWrapper,
            PluginAPIWrapper, SensorObservationWrapper, SimulatorWrapper, StateWrapper,
        },
        simulator::SimulatorConfig,
        state_estimators::{
            pybinds::PythonStateEstimator, state_estimator::StateEstimator,
        },
    };
    pub fn make_python_bindings(m: &Bound<'_, PyModule>) -> PyResult<()> {
        m.add_class::<SimulatorWrapper>()?;
        m.add_class::<PluginAPIWrapper>()?;
        m.add_class::<ControllerErrorWrapper>()?;
        m.add_class::<PythonPhysic>()?;
        m.add_class::<StateWrapper>()?;
        m.add_class::<PythonStateEstimator>()?;
        m.add_class::<ObservationWrapper>()?;
        m.add_class::<SensorObservationWrapper>()?;
        m.add_class::<GNSSObservationWrapper>()?;
        m.add_class::<OdometryObservationWrapper>()?;
        m.add_class::<OrientedLandmarkObservationWrapper>()?;
        m.add_class::<OrientedRobotObservationWrapper>()?;
        m.add_class::<PythonController>()?;
        m.add_class::<CommandWrapper>()?;
        m.add_class::<PythonNavigator>()?;
        Ok(())
    }
    pub struct PythonAPI {
        api: Py<PyAny>,
        state_estimators: Vec<PythonStateEstimator>,
        controllers: Vec<PythonController>,
        navigators: Vec<PythonNavigator>,
        physics: Vec<PythonPhysic>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PythonAPI {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "PythonAPI",
                "api",
                &self.api,
                "state_estimators",
                &self.state_estimators,
                "controllers",
                &self.controllers,
                "navigators",
                &self.navigators,
                "physics",
                &&self.physics,
            )
        }
    }
    impl PythonAPI {
        pub fn new(m: Py<PyAny>) -> PythonAPI {
            PythonAPI {
                api: m,
                state_estimators: Vec::new(),
                controllers: Vec::new(),
                navigators: Vec::new(),
                physics: Vec::new(),
            }
        }
    }
    impl PythonAPI {
        pub fn check_requests(&mut self) {
            for state_estimator in &mut self.state_estimators {
                state_estimator.check_requests();
            }
            for controller in &mut self.controllers {
                controller.check_requests();
            }
            for navigator in &mut self.navigators {
                navigator.check_requests();
            }
            for physic in &mut self.physics {
                physic.check_requests();
            }
        }
        pub fn get_state_estimator(
            &mut self,
            config: &Value,
            global_config: &SimulatorConfig,
        ) -> Box<dyn StateEstimator> {
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Calling Python API"),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            self.state_estimators
                .push(
                    PythonStateEstimator::new(
                        Python::with_gil(|py| {
                            self.api
                                .bind(py)
                                .call_method(
                                    "get_state_estimator",
                                    (
                                        config.to_string(),
                                        serde_json::to_string(global_config)
                                            .expect("Failed to serialize global_config"),
                                    ),
                                    None,
                                )
                                .expect(
                                    "Error during execution of python method 'get_state_estimator'",
                                )
                                .extract()
                                .expect(
                                    "Expecting function return of PythonStateEstimator but failed",
                                )
                        }),
                    ),
                );
            let st = Box::new(self.state_estimators.last().unwrap().get_client());
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Got api {0:?}", st),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            st
        }
        pub fn get_controller(
            &mut self,
            config: &Value,
            global_config: &SimulatorConfig,
        ) -> Box<dyn Controller> {
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Calling Python API"),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            self.controllers
                .push(
                    PythonController::new(
                        Python::with_gil(|py| {
                            self.api
                                .bind(py)
                                .call_method(
                                    "get_controller",
                                    (
                                        config.to_string(),
                                        serde_json::to_string(global_config)
                                            .expect("Failed to serialize global_config"),
                                    ),
                                    None,
                                )
                                .expect(
                                    "Error during execution of python method 'get_controller'",
                                )
                                .extract()
                                .expect(
                                    "Expecting function return of PythonController but failed",
                                )
                        }),
                    ),
                );
            let st = Box::new(self.controllers.last().unwrap().get_client());
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Got api {0:?}", st),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            st
        }
        pub fn get_navigator(
            &mut self,
            config: &Value,
            global_config: &SimulatorConfig,
        ) -> Box<dyn Navigator> {
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Calling Python API"),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            self.navigators
                .push(
                    PythonNavigator::new(
                        Python::with_gil(|py| {
                            self.api
                                .bind(py)
                                .call_method(
                                    "get_navigator",
                                    (
                                        config.to_string(),
                                        serde_json::to_string(global_config)
                                            .expect("Failed to serialize global_config"),
                                    ),
                                    None,
                                )
                                .expect(
                                    "Error during execution of python method 'get_navigator'",
                                )
                                .extract()
                                .expect(
                                    "Expecting function return of Python?avigator but failed",
                                )
                        }),
                    ),
                );
            let st = Box::new(self.navigators.last().unwrap().get_client());
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Got api {0:?}", st),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            st
        }
        pub fn get_physic(
            &mut self,
            config: &Value,
            global_config: &SimulatorConfig,
        ) -> Box<dyn Physic> {
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Calling Python API"),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            self.physics
                .push(
                    PythonPhysic::new(
                        Python::with_gil(|py| {
                            self.api
                                .bind(py)
                                .call_method(
                                    "get_physic",
                                    (
                                        config.to_string(),
                                        serde_json::to_string(global_config)
                                            .expect("Failed to serialize global_config"),
                                    ),
                                    None,
                                )
                                .expect(
                                    "Error during execution of python method 'get_physic'",
                                )
                                .extract()
                                .expect(
                                    "Expecting function return of PythonPhysic but failed",
                                )
                        }),
                    ),
                );
            let st = Box::new(self.physics.last().unwrap().get_client());
            if is_enabled(crate::logger::InternalLog::API) {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Got api {0:?}", st),
                                lvl,
                                &(
                                    "simba::pybinds",
                                    "simba::pybinds",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            st
        }
    }
}
mod pywrappers {
    use std::sync::{Arc, Mutex};
    use nalgebra::{SVector, Vector2};
    use pyo3::prelude::*;
    use crate::{
        api::async_api::{AsyncApi, AsyncApiRunner, PluginAsyncAPI},
        controllers::{controller::ControllerError, pybinds::PythonController},
        navigators::pybinds::PythonNavigator,
        physics::{physic::Command, pybinds::PythonPhysic},
        plugin_api::PluginAPI, pybinds::PythonAPI,
        sensors::{
            gnss_sensor::GNSSObservation, odometry_sensor::OdometryObservation,
            oriented_landmark_sensor::OrientedLandmarkObservation,
            robot_sensor::OrientedRobotObservation,
            sensor::{Observation, SensorObservation},
        },
        simulator::Simulator,
        state_estimators::{pybinds::PythonStateEstimator, state_estimator::State},
    };
    pub struct ControllerErrorWrapper {
        /// Lateral error.
        pub lateral: f32,
        /// Orientation error.
        pub theta: f32,
        /// Velocity error.
        pub velocity: f32,
    }
    impl ::pyo3::types::DerefToPyAny for ControllerErrorWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for ControllerErrorWrapper {
        const NAME: &'static str = "ControllerError";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <ControllerErrorWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for ControllerErrorWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a ControllerErrorWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, ControllerErrorWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut ControllerErrorWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRefMut<'py, ControllerErrorWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for ControllerErrorWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for ControllerErrorWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            ControllerErrorWrapper,
        >;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ControllerErrorWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    ControllerErrorWrapper,
                                >()
                                    + {
                                        { builtin # offset_of(ControllerErrorWrapper, lateral) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ControllerErrorWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"lateral", c"Lateral error.")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"lateral",
                                ControllerErrorWrapper::__pymethod_set_lateral__,
                                c"Lateral error.",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ControllerErrorWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    ControllerErrorWrapper,
                                >()
                                    + { { builtin # offset_of(ControllerErrorWrapper, theta) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ControllerErrorWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"theta", c"Orientation error.")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"theta",
                                ControllerErrorWrapper::__pymethod_set_theta__,
                                c"Orientation error.",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ControllerErrorWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    ControllerErrorWrapper,
                                >()
                                    + {
                                        { builtin # offset_of(ControllerErrorWrapper, velocity) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ControllerErrorWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"velocity", c"Velocity error.")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"velocity",
                                ControllerErrorWrapper::__pymethod_set_velocity__,
                                c"Velocity error.",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <ControllerErrorWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<ControllerErrorWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl ControllerErrorWrapper {
        unsafe fn __pymethod_set_lateral__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "lateral",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ControllerErrorWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .lateral = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_theta__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "theta",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ControllerErrorWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .theta = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_velocity__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "velocity",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ControllerErrorWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .velocity = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl ControllerErrorWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl ControllerErrorWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for ControllerErrorWrapper {
        #[inline]
        fn clone(&self) -> ControllerErrorWrapper {
            ControllerErrorWrapper {
                lateral: ::core::clone::Clone::clone(&self.lateral),
                theta: ::core::clone::Clone::clone(&self.theta),
                velocity: ::core::clone::Clone::clone(&self.velocity),
            }
        }
    }
    impl ControllerErrorWrapper {
        pub fn new() -> Self {
            Self {
                lateral: 0.,
                theta: 0.,
                velocity: 0.,
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<ControllerErrorWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<ControllerErrorWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<ControllerErrorWrapper>
                                for PyClassImplCollector<ControllerErrorWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    ControllerErrorWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl ControllerErrorWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = ControllerErrorWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <ControllerErrorWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = ControllerErrorWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<ControllerErrorWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl ControllerErrorWrapper {
        pub fn from_rust(ce: &ControllerError) -> Self {
            Self {
                lateral: ce.lateral,
                theta: ce.theta,
                velocity: ce.velocity,
            }
        }
        pub fn to_rust(&self) -> ControllerError {
            ControllerError {
                lateral: self.lateral,
                theta: self.theta,
                velocity: self.velocity,
            }
        }
    }
    pub struct Pose {
        pub x: f32,
        pub y: f32,
        pub theta: f32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Pose {
        #[inline]
        fn clone(&self) -> Pose {
            Pose {
                x: ::core::clone::Clone::clone(&self.x),
                y: ::core::clone::Clone::clone(&self.y),
                theta: ::core::clone::Clone::clone(&self.theta),
            }
        }
    }
    impl ::pyo3::types::DerefToPyAny for Pose {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for Pose {
        const NAME: &'static str = "Pose";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Pose as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for Pose {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Pose {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Pose>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut Pose {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, Pose>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for Pose {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Pose {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Pose>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<Pose, f32>
                        for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<Pose>()
                                    + { { builtin # offset_of(Pose, x) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            Pose,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"x", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"x",
                                Pose::__pymethod_set_x__,
                                c"",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<Pose, f32>
                        for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<Pose>()
                                    + { { builtin # offset_of(Pose, y) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            Pose,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"y", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"y",
                                Pose::__pymethod_set_y__,
                                c"",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<Pose, f32>
                        for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<Pose>()
                                    + { { builtin # offset_of(Pose, theta) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            Pose,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"theta", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"theta",
                                Pose::__pymethod_set_theta__,
                                c"",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Pose as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Pose> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Pose {
        unsafe fn __pymethod_set_x__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "x",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    Pose,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .x = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_y__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "y",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    Pose,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .y = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_theta__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "theta",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    Pose,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .theta = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl Pose {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Pose {}
    pub struct StateWrapper {
        /// Position and orientation of the robot
        pub pose: Pose,
        /// Linear velocity.
        pub velocity: f32,
    }
    impl ::pyo3::types::DerefToPyAny for StateWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for StateWrapper {
        const NAME: &'static str = "State";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <StateWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for StateWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a StateWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, StateWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut StateWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, StateWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for StateWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for StateWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<StateWrapper>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            StateWrapper,
                            Pose,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<StateWrapper>()
                                    + { { builtin # offset_of(StateWrapper, pose) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            StateWrapper,
                            Pose,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<Pose>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<Pose>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR
                                .generate(c"pose", c"Position and orientation of the robot")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"pose",
                                StateWrapper::__pymethod_set_pose__,
                                c"Position and orientation of the robot",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            StateWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<StateWrapper>()
                                    + { { builtin # offset_of(StateWrapper, velocity) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            StateWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"velocity", c"Linear velocity.")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"velocity",
                                StateWrapper::__pymethod_set_velocity__,
                                c"Linear velocity.",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <StateWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<StateWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl StateWrapper {
        unsafe fn __pymethod_set_pose__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "pose",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    StateWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .pose = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_velocity__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "velocity",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    StateWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .velocity = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl StateWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl StateWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for StateWrapper {
        #[inline]
        fn clone(&self) -> StateWrapper {
            StateWrapper {
                pose: ::core::clone::Clone::clone(&self.pose),
                velocity: ::core::clone::Clone::clone(&self.velocity),
            }
        }
    }
    impl StateWrapper {
        pub fn new() -> Self {
            Self {
                pose: Pose { x: 0., y: 0., theta: 0. },
                velocity: 0.,
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<StateWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<StateWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<StateWrapper>
                                for PyClassImplCollector<StateWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    StateWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl StateWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = StateWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <StateWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = StateWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<StateWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl StateWrapper {
        pub fn from_rust(s: &State) -> Self {
            Self {
                pose: Pose {
                    x: s.pose[0],
                    y: s.pose[1],
                    theta: s.pose[2],
                },
                velocity: s.velocity,
            }
        }
        pub fn to_rust(&self) -> State {
            State {
                pose: SVector::from_vec(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            self.pose.x,
                            self.pose.y,
                            self.pose.theta,
                        ]),
                    ),
                ),
                velocity: self.velocity,
            }
        }
    }
    pub struct OrientedLandmarkObservationWrapper {
        /// Id of the landmark
        pub id: i32,
        /// Pose of the landmark
        pub pose: Pose,
    }
    impl ::pyo3::types::DerefToPyAny for OrientedLandmarkObservationWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for OrientedLandmarkObservationWrapper {
        const NAME: &'static str = "OrientedLandmarkObservation";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <OrientedLandmarkObservationWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for OrientedLandmarkObservationWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a OrientedLandmarkObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, OrientedLandmarkObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut OrientedLandmarkObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRefMut<'py, OrientedLandmarkObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for OrientedLandmarkObservationWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for OrientedLandmarkObservationWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            OrientedLandmarkObservationWrapper,
        >;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            OrientedLandmarkObservationWrapper,
                            i32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    OrientedLandmarkObservationWrapper,
                                >()
                                    + {
                                        {
                                            builtin # offset_of(OrientedLandmarkObservationWrapper, id)
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            OrientedLandmarkObservationWrapper,
                            i32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<i32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<i32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"id", c"Id of the landmark")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"id",
                                OrientedLandmarkObservationWrapper::__pymethod_set_id__,
                                c"Id of the landmark",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            OrientedLandmarkObservationWrapper,
                            Pose,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    OrientedLandmarkObservationWrapper,
                                >()
                                    + {
                                        {
                                            builtin # offset_of(
                                                OrientedLandmarkObservationWrapper, pose
                                            )
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            OrientedLandmarkObservationWrapper,
                            Pose,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<Pose>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<Pose>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"pose", c"Pose of the landmark")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"pose",
                                OrientedLandmarkObservationWrapper::__pymethod_set_pose__,
                                c"Pose of the landmark",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <OrientedLandmarkObservationWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<OrientedLandmarkObservationWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OrientedLandmarkObservationWrapper {
        unsafe fn __pymethod_set_id__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "id",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    OrientedLandmarkObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .id = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_pose__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "pose",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    OrientedLandmarkObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .pose = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl OrientedLandmarkObservationWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OrientedLandmarkObservationWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for OrientedLandmarkObservationWrapper {
        #[inline]
        fn clone(&self) -> OrientedLandmarkObservationWrapper {
            OrientedLandmarkObservationWrapper {
                id: ::core::clone::Clone::clone(&self.id),
                pose: ::core::clone::Clone::clone(&self.pose),
            }
        }
    }
    impl OrientedLandmarkObservationWrapper {
        pub fn new() -> Self {
            Self {
                id: 0,
                pose: Pose { x: 0., y: 0., theta: 0. },
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<OrientedLandmarkObservationWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<
        OrientedLandmarkObservationWrapper,
    > {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<
                                    OrientedLandmarkObservationWrapper,
                                >
                                for PyClassImplCollector<
                                    OrientedLandmarkObservationWrapper,
                                > {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    OrientedLandmarkObservationWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OrientedLandmarkObservationWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = OrientedLandmarkObservationWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <OrientedLandmarkObservationWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = OrientedLandmarkObservationWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<
                OrientedLandmarkObservationWrapper,
            > = result.convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl OrientedLandmarkObservationWrapper {
        pub fn from_rust(s: &OrientedLandmarkObservation) -> Self {
            Self {
                id: s.id,
                pose: Pose {
                    x: s.pose[0],
                    y: s.pose[1],
                    theta: s.pose[2],
                },
            }
        }
        pub fn to_rust(&self) -> OrientedLandmarkObservation {
            OrientedLandmarkObservation {
                id: self.id,
                pose: SVector::from_vec(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            self.pose.x,
                            self.pose.y,
                            self.pose.theta,
                        ]),
                    ),
                ),
            }
        }
    }
    pub struct OdometryObservationWrapper {
        pub linear_velocity: f32,
        pub angular_velocity: f32,
    }
    impl ::pyo3::types::DerefToPyAny for OdometryObservationWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for OdometryObservationWrapper {
        const NAME: &'static str = "OdometryObservation";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <OdometryObservationWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for OdometryObservationWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a OdometryObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, OdometryObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut OdometryObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRefMut<'py, OdometryObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for OdometryObservationWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for OdometryObservationWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            OdometryObservationWrapper,
        >;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            OdometryObservationWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    OdometryObservationWrapper,
                                >()
                                    + {
                                        {
                                            builtin # offset_of(
                                                OdometryObservationWrapper, linear_velocity
                                            )
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            OdometryObservationWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"linear_velocity", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"linear_velocity",
                                OdometryObservationWrapper::__pymethod_set_linear_velocity__,
                                c"",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            OdometryObservationWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    OdometryObservationWrapper,
                                >()
                                    + {
                                        {
                                            builtin # offset_of(
                                                OdometryObservationWrapper, angular_velocity
                                            )
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            OdometryObservationWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"angular_velocity", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"angular_velocity",
                                OdometryObservationWrapper::__pymethod_set_angular_velocity__,
                                c"",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <OdometryObservationWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<OdometryObservationWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OdometryObservationWrapper {
        unsafe fn __pymethod_set_linear_velocity__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "linear_velocity",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    OdometryObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .linear_velocity = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_angular_velocity__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "angular_velocity",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    OdometryObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .angular_velocity = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl OdometryObservationWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OdometryObservationWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for OdometryObservationWrapper {
        #[inline]
        fn clone(&self) -> OdometryObservationWrapper {
            OdometryObservationWrapper {
                linear_velocity: ::core::clone::Clone::clone(&self.linear_velocity),
                angular_velocity: ::core::clone::Clone::clone(&self.angular_velocity),
            }
        }
    }
    impl OdometryObservationWrapper {
        pub fn new() -> Self {
            Self {
                linear_velocity: 0.,
                angular_velocity: 0.,
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<OdometryObservationWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<OdometryObservationWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<OdometryObservationWrapper>
                                for PyClassImplCollector<OdometryObservationWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    OdometryObservationWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OdometryObservationWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = OdometryObservationWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <OdometryObservationWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = OdometryObservationWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<OdometryObservationWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl OdometryObservationWrapper {
        pub fn from_rust(s: &OdometryObservation) -> Self {
            Self {
                linear_velocity: s.linear_velocity,
                angular_velocity: s.angular_velocity,
            }
        }
        pub fn to_rust(&self) -> OdometryObservation {
            OdometryObservation {
                linear_velocity: self.linear_velocity,
                angular_velocity: self.angular_velocity,
            }
        }
    }
    pub struct GNSSObservationWrapper {
        pub position: [f32; 2],
        pub velocity: [f32; 2],
    }
    impl ::pyo3::types::DerefToPyAny for GNSSObservationWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for GNSSObservationWrapper {
        const NAME: &'static str = "GNSSObservation";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <GNSSObservationWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for GNSSObservationWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a GNSSObservationWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, GNSSObservationWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut GNSSObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRefMut<'py, GNSSObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for GNSSObservationWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for GNSSObservationWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            GNSSObservationWrapper,
        >;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            GNSSObservationWrapper,
                            [f32; 2],
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    GNSSObservationWrapper,
                                >()
                                    + {
                                        { builtin # offset_of(GNSSObservationWrapper, position) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            GNSSObservationWrapper,
                            [f32; 2],
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<[f32; 2]>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<[f32; 2]>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"position", c"")
                        })
                    },
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            GNSSObservationWrapper,
                            [f32; 2],
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    GNSSObservationWrapper,
                                >()
                                    + {
                                        { builtin # offset_of(GNSSObservationWrapper, velocity) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            GNSSObservationWrapper,
                            [f32; 2],
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<[f32; 2]>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<[f32; 2]>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"velocity", c"")
                        })
                    },
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <GNSSObservationWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<GNSSObservationWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl GNSSObservationWrapper {}
    impl GNSSObservationWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl GNSSObservationWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for GNSSObservationWrapper {
        #[inline]
        fn clone(&self) -> GNSSObservationWrapper {
            GNSSObservationWrapper {
                position: ::core::clone::Clone::clone(&self.position),
                velocity: ::core::clone::Clone::clone(&self.velocity),
            }
        }
    }
    impl GNSSObservationWrapper {
        pub fn new() -> Self {
            Self {
                position: [0., 0.],
                velocity: [0., 0.],
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<GNSSObservationWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<GNSSObservationWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<GNSSObservationWrapper>
                                for PyClassImplCollector<GNSSObservationWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    GNSSObservationWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl GNSSObservationWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = GNSSObservationWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <GNSSObservationWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = GNSSObservationWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<GNSSObservationWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl GNSSObservationWrapper {
        pub fn from_rust(s: &GNSSObservation) -> Self {
            Self {
                position: s.position.into(),
                velocity: s.velocity.into(),
            }
        }
        pub fn to_rust(&self) -> GNSSObservation {
            GNSSObservation {
                position: Vector2::from(self.position),
                velocity: Vector2::from(self.velocity),
            }
        }
    }
    pub struct OrientedRobotObservationWrapper {
        /// Name of the Robot
        pub name: String,
        /// Pose of the Robot
        pub pose: Pose,
    }
    impl ::pyo3::types::DerefToPyAny for OrientedRobotObservationWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for OrientedRobotObservationWrapper {
        const NAME: &'static str = "OrientedRobotObservation";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <OrientedRobotObservationWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for OrientedRobotObservationWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a OrientedRobotObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, OrientedRobotObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut OrientedRobotObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRefMut<'py, OrientedRobotObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for OrientedRobotObservationWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for OrientedRobotObservationWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            OrientedRobotObservationWrapper,
        >;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            OrientedRobotObservationWrapper,
                            String,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    OrientedRobotObservationWrapper,
                                >()
                                    + {
                                        {
                                            builtin # offset_of(OrientedRobotObservationWrapper, name)
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            OrientedRobotObservationWrapper,
                            String,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<String>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<String>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"name", c"Name of the Robot")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"name",
                                OrientedRobotObservationWrapper::__pymethod_set_name__,
                                c"Name of the Robot",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            OrientedRobotObservationWrapper,
                            Pose,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<
                                    OrientedRobotObservationWrapper,
                                >()
                                    + {
                                        {
                                            builtin # offset_of(OrientedRobotObservationWrapper, pose)
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            OrientedRobotObservationWrapper,
                            Pose,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<Pose>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<Pose>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"pose", c"Pose of the Robot")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"pose",
                                OrientedRobotObservationWrapper::__pymethod_set_pose__,
                                c"Pose of the Robot",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <OrientedRobotObservationWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<OrientedRobotObservationWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OrientedRobotObservationWrapper {
        unsafe fn __pymethod_set_name__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "name",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    OrientedRobotObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .name = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_pose__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "pose",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    OrientedRobotObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .pose = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl OrientedRobotObservationWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OrientedRobotObservationWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for OrientedRobotObservationWrapper {
        #[inline]
        fn clone(&self) -> OrientedRobotObservationWrapper {
            OrientedRobotObservationWrapper {
                name: ::core::clone::Clone::clone(&self.name),
                pose: ::core::clone::Clone::clone(&self.pose),
            }
        }
    }
    impl OrientedRobotObservationWrapper {
        pub fn new() -> Self {
            Self {
                name: "NoName".to_string(),
                pose: Pose { x: 0., y: 0., theta: 0. },
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<OrientedRobotObservationWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<OrientedRobotObservationWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<
                                    OrientedRobotObservationWrapper,
                                >
                                for PyClassImplCollector<OrientedRobotObservationWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    OrientedRobotObservationWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl OrientedRobotObservationWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = OrientedRobotObservationWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <OrientedRobotObservationWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = OrientedRobotObservationWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<
                OrientedRobotObservationWrapper,
            > = result.convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl OrientedRobotObservationWrapper {
        pub fn from_rust(s: &OrientedRobotObservation) -> Self {
            Self {
                name: s.name.clone(),
                pose: Pose {
                    x: s.pose[0],
                    y: s.pose[1],
                    theta: s.pose[2],
                },
            }
        }
        pub fn to_rust(&self) -> OrientedRobotObservation {
            OrientedRobotObservation {
                name: self.name.clone(),
                pose: SVector::from_vec(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            self.pose.x,
                            self.pose.y,
                            self.pose.theta,
                        ]),
                    ),
                ),
            }
        }
    }
    pub enum SensorObservationWrapper {
        OrientedLandmark(OrientedLandmarkObservationWrapper),
        Odometry(OdometryObservationWrapper),
        GNSS(GNSSObservationWrapper),
        OrientedRobot(OrientedRobotObservationWrapper),
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for SensorObservationWrapper {
        const NAME: &'static str = "SensorObservation";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <SensorObservationWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for SensorObservationWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a SensorObservationWrapper {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, SensorObservationWrapper>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for SensorObservationWrapper {
        fn into_py(self, py: ::pyo3::Python) -> ::pyo3::PyObject {
            match self {
                SensorObservationWrapper::OrientedLandmark { .. } => {
                    let pyclass_init = <::pyo3::PyClassInitializer<
                        Self,
                    > as ::std::convert::From<Self>>::from(self)
                        .add_subclass(SensorObservationWrapper_OrientedLandmark);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                SensorObservationWrapper::Odometry { .. } => {
                    let pyclass_init = <::pyo3::PyClassInitializer<
                        Self,
                    > as ::std::convert::From<Self>>::from(self)
                        .add_subclass(SensorObservationWrapper_Odometry);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                SensorObservationWrapper::GNSS { .. } => {
                    let pyclass_init = <::pyo3::PyClassInitializer<
                        Self,
                    > as ::std::convert::From<Self>>::from(self)
                        .add_subclass(SensorObservationWrapper_GNSS);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                SensorObservationWrapper::OrientedRobot { .. } => {
                    let pyclass_init = <::pyo3::PyClassInitializer<
                        Self,
                    > as ::std::convert::From<Self>>::from(self)
                        .add_subclass(SensorObservationWrapper_OrientedRobot);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
            }
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for SensorObservationWrapper {
        const IS_BASETYPE: bool = true;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            SensorObservationWrapper,
        >;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"OrientedLandmark",
                                SensorObservationWrapper::__pymethod_variant_cls_OrientedLandmark__,
                            )
                        }),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"Odometry",
                                SensorObservationWrapper::__pymethod_variant_cls_Odometry__,
                            )
                        }),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"GNSS",
                                SensorObservationWrapper::__pymethod_variant_cls_GNSS__,
                            )
                        }),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"OrientedRobot",
                                SensorObservationWrapper::__pymethod_variant_cls_OrientedRobot__,
                            )
                        }),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <SensorObservationWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<SensorObservationWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper {
        fn __pymethod_variant_cls_OrientedLandmark__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py
                    .get_type_bound::<SensorObservationWrapper_OrientedLandmark>()
                    .into_any()
                    .unbind(),
            )
        }
        fn __pymethod_variant_cls_Odometry__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py
                    .get_type_bound::<SensorObservationWrapper_Odometry>()
                    .into_any()
                    .unbind(),
            )
        }
        fn __pymethod_variant_cls_GNSS__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<SensorObservationWrapper_GNSS>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_OrientedRobot__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py
                    .get_type_bound::<SensorObservationWrapper_OrientedRobot>()
                    .into_any()
                    .unbind(),
            )
        }
    }
    impl SensorObservationWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper {}
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct SensorObservationWrapper_OrientedLandmark;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct SensorObservationWrapper_Odometry;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct SensorObservationWrapper_GNSS;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct SensorObservationWrapper_OrientedRobot;
    unsafe impl ::pyo3::type_object::PyTypeInfo
    for SensorObservationWrapper_OrientedLandmark {
        const NAME: &'static str = "SensorObservationWrapper_OrientedLandmark";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <SensorObservationWrapper_OrientedLandmark as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for SensorObservationWrapper_Odometry {
        const NAME: &'static str = "SensorObservationWrapper_Odometry";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <SensorObservationWrapper_Odometry as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for SensorObservationWrapper_GNSS {
        const NAME: &'static str = "SensorObservationWrapper_GNSS";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <SensorObservationWrapper_GNSS as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo
    for SensorObservationWrapper_OrientedRobot {
        const NAME: &'static str = "SensorObservationWrapper_OrientedRobot";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <SensorObservationWrapper_OrientedRobot as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for SensorObservationWrapper_OrientedLandmark {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a SensorObservationWrapper_OrientedLandmark {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, SensorObservationWrapper_OrientedLandmark>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl
    for SensorObservationWrapper_OrientedLandmark {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = SensorObservationWrapper;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            SensorObservationWrapper_OrientedLandmark,
        >;
        type PyClassMutability = <<SensorObservationWrapper as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Getter(
                            ::pyo3::class::PyGetterDef::new(
                                c"_0",
                                SensorObservationWrapper_OrientedLandmark::__pymethod_get__0__,
                                c"",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"__match_args__",
                                SensorObservationWrapper_OrientedLandmark::__pymethod___match_args____,
                            )
                        }),
                    ),
                ],
                slots: &[
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                        ) -> ::pyo3::ffi::Py_ssize_t {
                            ::pyo3::impl_::trampoline::lenfunc(
                                _slf,
                                SensorObservationWrapper_OrientedLandmark::__pymethod___default___len______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_length,
                            pfunc: trampoline as ::pyo3::ffi::lenfunc as _,
                        }
                    },
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                            arg0: *mut ::pyo3::ffi::PyObject,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::binaryfunc(
                                _slf,
                                arg0,
                                SensorObservationWrapper_OrientedLandmark::__pymethod___default___getitem______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_subscript,
                            pfunc: trampoline as ::pyo3::ffi::binaryfunc as _,
                        }
                    },
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<
                                    SensorObservationWrapper_OrientedLandmark,
                                >
                                for PyClassImplCollector<
                                    SensorObservationWrapper_OrientedLandmark,
                                > {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(_0)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    SensorObservationWrapper_OrientedLandmark::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <SensorObservationWrapper_OrientedLandmark as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<
                SensorObservationWrapper_OrientedLandmark,
            > = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_OrientedLandmark {
        unsafe fn __pymethod_get__0__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                SensorObservationWrapper_OrientedLandmark::_0(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<SensorObservationWrapper_OrientedLandmark>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        fn __pymethod___match_args____(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                ::pyo3::IntoPy::into_py(
                    SensorObservationWrapper_OrientedLandmark::__match_args__,
                    py,
                ),
            )
        }
        unsafe fn __pymethod___default___len______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::pyo3::ffi::Py_ssize_t> {
            let function = SensorObservationWrapper_OrientedLandmark::__len__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let result = SensorObservationWrapper_OrientedLandmark::__len__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_OrientedLandmark>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
            );
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___default___getitem______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
            arg0: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = SensorObservationWrapper_OrientedLandmark::__getitem__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_OrientedLandmark::__getitem__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_OrientedLandmark>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &arg0).0,
                        &mut holder_0,
                        "idx",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = SensorObservationWrapper_OrientedLandmark::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <SensorObservationWrapper_OrientedLandmark as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["_0"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 1usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_OrientedLandmark::__pymethod_constructor__(
                py,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "_0",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<
                SensorObservationWrapper_OrientedLandmark,
            > = result.convert(py)?;
            gil_refs_checker_0.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl SensorObservationWrapper_OrientedLandmark {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for SensorObservationWrapper_Odometry {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a SensorObservationWrapper_Odometry {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, SensorObservationWrapper_Odometry>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for SensorObservationWrapper_Odometry {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = SensorObservationWrapper;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            SensorObservationWrapper_Odometry,
        >;
        type PyClassMutability = <<SensorObservationWrapper as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Getter(
                            ::pyo3::class::PyGetterDef::new(
                                c"_0",
                                SensorObservationWrapper_Odometry::__pymethod_get__0__,
                                c"",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"__match_args__",
                                SensorObservationWrapper_Odometry::__pymethod___match_args____,
                            )
                        }),
                    ),
                ],
                slots: &[
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                        ) -> ::pyo3::ffi::Py_ssize_t {
                            ::pyo3::impl_::trampoline::lenfunc(
                                _slf,
                                SensorObservationWrapper_Odometry::__pymethod___default___len______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_length,
                            pfunc: trampoline as ::pyo3::ffi::lenfunc as _,
                        }
                    },
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                            arg0: *mut ::pyo3::ffi::PyObject,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::binaryfunc(
                                _slf,
                                arg0,
                                SensorObservationWrapper_Odometry::__pymethod___default___getitem______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_subscript,
                            pfunc: trampoline as ::pyo3::ffi::binaryfunc as _,
                        }
                    },
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<
                                    SensorObservationWrapper_Odometry,
                                >
                                for PyClassImplCollector<
                                    SensorObservationWrapper_Odometry,
                                > {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(_0)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    SensorObservationWrapper_Odometry::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <SensorObservationWrapper_Odometry as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<SensorObservationWrapper_Odometry> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_Odometry {
        unsafe fn __pymethod_get__0__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                SensorObservationWrapper_Odometry::_0(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<SensorObservationWrapper_Odometry>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        fn __pymethod___match_args____(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                ::pyo3::IntoPy::into_py(
                    SensorObservationWrapper_Odometry::__match_args__,
                    py,
                ),
            )
        }
        unsafe fn __pymethod___default___len______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::pyo3::ffi::Py_ssize_t> {
            let function = SensorObservationWrapper_Odometry::__len__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let result = SensorObservationWrapper_Odometry::__len__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_Odometry>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
            );
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___default___getitem______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
            arg0: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = SensorObservationWrapper_Odometry::__getitem__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_Odometry::__getitem__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_Odometry>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &arg0).0,
                        &mut holder_0,
                        "idx",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = SensorObservationWrapper_Odometry::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <SensorObservationWrapper_Odometry as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["_0"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 1usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_Odometry::__pymethod_constructor__(
                py,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "_0",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<
                SensorObservationWrapper_Odometry,
            > = result.convert(py)?;
            gil_refs_checker_0.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl SensorObservationWrapper_Odometry {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for SensorObservationWrapper_GNSS {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a SensorObservationWrapper_GNSS {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, SensorObservationWrapper_GNSS>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for SensorObservationWrapper_GNSS {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = SensorObservationWrapper;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            SensorObservationWrapper_GNSS,
        >;
        type PyClassMutability = <<SensorObservationWrapper as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Getter(
                            ::pyo3::class::PyGetterDef::new(
                                c"_0",
                                SensorObservationWrapper_GNSS::__pymethod_get__0__,
                                c"",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"__match_args__",
                                SensorObservationWrapper_GNSS::__pymethod___match_args____,
                            )
                        }),
                    ),
                ],
                slots: &[
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                        ) -> ::pyo3::ffi::Py_ssize_t {
                            ::pyo3::impl_::trampoline::lenfunc(
                                _slf,
                                SensorObservationWrapper_GNSS::__pymethod___default___len______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_length,
                            pfunc: trampoline as ::pyo3::ffi::lenfunc as _,
                        }
                    },
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                            arg0: *mut ::pyo3::ffi::PyObject,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::binaryfunc(
                                _slf,
                                arg0,
                                SensorObservationWrapper_GNSS::__pymethod___default___getitem______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_subscript,
                            pfunc: trampoline as ::pyo3::ffi::binaryfunc as _,
                        }
                    },
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<SensorObservationWrapper_GNSS>
                                for PyClassImplCollector<SensorObservationWrapper_GNSS> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(_0)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    SensorObservationWrapper_GNSS::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <SensorObservationWrapper_GNSS as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<SensorObservationWrapper_GNSS> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_GNSS {
        unsafe fn __pymethod_get__0__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                SensorObservationWrapper_GNSS::_0(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<SensorObservationWrapper_GNSS>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        fn __pymethod___match_args____(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                ::pyo3::IntoPy::into_py(
                    SensorObservationWrapper_GNSS::__match_args__,
                    py,
                ),
            )
        }
        unsafe fn __pymethod___default___len______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::pyo3::ffi::Py_ssize_t> {
            let function = SensorObservationWrapper_GNSS::__len__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let result = SensorObservationWrapper_GNSS::__len__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_GNSS>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
            );
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___default___getitem______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
            arg0: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = SensorObservationWrapper_GNSS::__getitem__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_GNSS::__getitem__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_GNSS>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &arg0).0,
                        &mut holder_0,
                        "idx",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = SensorObservationWrapper_GNSS::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <SensorObservationWrapper_GNSS as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["_0"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 1usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_GNSS::__pymethod_constructor__(
                py,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "_0",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<SensorObservationWrapper_GNSS> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl SensorObservationWrapper_GNSS {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for SensorObservationWrapper_OrientedRobot {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a SensorObservationWrapper_OrientedRobot {
        type Holder = ::std::option::Option<
            ::pyo3::PyRef<'py, SensorObservationWrapper_OrientedRobot>,
        >;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for SensorObservationWrapper_OrientedRobot {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = SensorObservationWrapper;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            SensorObservationWrapper_OrientedRobot,
        >;
        type PyClassMutability = <<SensorObservationWrapper as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Getter(
                            ::pyo3::class::PyGetterDef::new(
                                c"_0",
                                SensorObservationWrapper_OrientedRobot::__pymethod_get__0__,
                                c"",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::ClassAttribute({
                            ::pyo3::class::PyClassAttributeDef::new(
                                c"__match_args__",
                                SensorObservationWrapper_OrientedRobot::__pymethod___match_args____,
                            )
                        }),
                    ),
                ],
                slots: &[
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                        ) -> ::pyo3::ffi::Py_ssize_t {
                            ::pyo3::impl_::trampoline::lenfunc(
                                _slf,
                                SensorObservationWrapper_OrientedRobot::__pymethod___default___len______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_length,
                            pfunc: trampoline as ::pyo3::ffi::lenfunc as _,
                        }
                    },
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                            arg0: *mut ::pyo3::ffi::PyObject,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::binaryfunc(
                                _slf,
                                arg0,
                                SensorObservationWrapper_OrientedRobot::__pymethod___default___getitem______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_mp_subscript,
                            pfunc: trampoline as ::pyo3::ffi::binaryfunc as _,
                        }
                    },
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<
                                    SensorObservationWrapper_OrientedRobot,
                                >
                                for PyClassImplCollector<
                                    SensorObservationWrapper_OrientedRobot,
                                > {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(_0)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    SensorObservationWrapper_OrientedRobot::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <SensorObservationWrapper_OrientedRobot as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<SensorObservationWrapper_OrientedRobot> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_OrientedRobot {
        unsafe fn __pymethod_get__0__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                SensorObservationWrapper_OrientedRobot::_0(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<SensorObservationWrapper_OrientedRobot>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        fn __pymethod___match_args____(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                ::pyo3::IntoPy::into_py(
                    SensorObservationWrapper_OrientedRobot::__match_args__,
                    py,
                ),
            )
        }
        unsafe fn __pymethod___default___len______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::pyo3::ffi::Py_ssize_t> {
            let function = SensorObservationWrapper_OrientedRobot::__len__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let result = SensorObservationWrapper_OrientedRobot::__len__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_OrientedRobot>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
            );
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___default___getitem______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
            arg0: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = SensorObservationWrapper_OrientedRobot::__getitem__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_OrientedRobot::__getitem__(
                ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                    .downcast::<SensorObservationWrapper_OrientedRobot>()
                    .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                    .and_then(
                        #[allow(unknown_lints, clippy::unnecessary_fallible_conversions)]
                        |bound| {
                            ::std::convert::TryFrom::try_from(bound)
                                .map_err(::std::convert::Into::into)
                        },
                    )?,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &arg0).0,
                        &mut holder_0,
                        "idx",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = SensorObservationWrapper_OrientedRobot::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <SensorObservationWrapper_OrientedRobot as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["_0"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 1usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = SensorObservationWrapper_OrientedRobot::__pymethod_constructor__(
                py,
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "_0",
                    )?,
                    &gil_refs_checker_0,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<
                SensorObservationWrapper_OrientedRobot,
            > = result.convert(py)?;
            gil_refs_checker_0.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl SensorObservationWrapper_OrientedRobot {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_OrientedLandmark {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            _0: OrientedLandmarkObservationWrapper,
        ) -> ::pyo3::PyClassInitializer<SensorObservationWrapper_OrientedLandmark> {
            let base_value = SensorObservationWrapper::OrientedLandmark(_0);
            <::pyo3::PyClassInitializer<
                SensorObservationWrapper,
            > as ::std::convert::From<SensorObservationWrapper>>::from(base_value)
                .add_subclass(SensorObservationWrapper_OrientedLandmark)
        }
        fn __len__(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<usize> {
            ::std::result::Result::Ok(1usize)
        }
        fn __getitem__(
            slf: ::pyo3::PyRef<Self>,
            idx: usize,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            let py = slf.py();
            match idx {
                0usize => {
                    ::std::result::Result::Ok(
                        ::pyo3::IntoPy::into_py(
                            SensorObservationWrapper_OrientedLandmark::_0(slf)?,
                            py,
                        ),
                    )
                }
                _ => {
                    ::std::result::Result::Err(
                        ::pyo3::exceptions::PyIndexError::new_err(
                            "tuple index out of range",
                        ),
                    )
                }
            }
        }
        const __match_args__: (&'static str,) = ("_0",);
        fn _0(
            slf: ::pyo3::PyRef<Self>,
        ) -> ::pyo3::PyResult<OrientedLandmarkObservationWrapper> {
            match &*slf.into_super() {
                SensorObservationWrapper::OrientedLandmark(val) => {
                    ::std::result::Result::Ok(::std::clone::Clone::clone(&val))
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_Odometry {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            _0: OdometryObservationWrapper,
        ) -> ::pyo3::PyClassInitializer<SensorObservationWrapper_Odometry> {
            let base_value = SensorObservationWrapper::Odometry(_0);
            <::pyo3::PyClassInitializer<
                SensorObservationWrapper,
            > as ::std::convert::From<SensorObservationWrapper>>::from(base_value)
                .add_subclass(SensorObservationWrapper_Odometry)
        }
        fn __len__(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<usize> {
            ::std::result::Result::Ok(1usize)
        }
        fn __getitem__(
            slf: ::pyo3::PyRef<Self>,
            idx: usize,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            let py = slf.py();
            match idx {
                0usize => {
                    ::std::result::Result::Ok(
                        ::pyo3::IntoPy::into_py(
                            SensorObservationWrapper_Odometry::_0(slf)?,
                            py,
                        ),
                    )
                }
                _ => {
                    ::std::result::Result::Err(
                        ::pyo3::exceptions::PyIndexError::new_err(
                            "tuple index out of range",
                        ),
                    )
                }
            }
        }
        const __match_args__: (&'static str,) = ("_0",);
        fn _0(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<OdometryObservationWrapper> {
            match &*slf.into_super() {
                SensorObservationWrapper::Odometry(val) => {
                    ::std::result::Result::Ok(::std::clone::Clone::clone(&val))
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_GNSS {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            _0: GNSSObservationWrapper,
        ) -> ::pyo3::PyClassInitializer<SensorObservationWrapper_GNSS> {
            let base_value = SensorObservationWrapper::GNSS(_0);
            <::pyo3::PyClassInitializer<
                SensorObservationWrapper,
            > as ::std::convert::From<SensorObservationWrapper>>::from(base_value)
                .add_subclass(SensorObservationWrapper_GNSS)
        }
        fn __len__(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<usize> {
            ::std::result::Result::Ok(1usize)
        }
        fn __getitem__(
            slf: ::pyo3::PyRef<Self>,
            idx: usize,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            let py = slf.py();
            match idx {
                0usize => {
                    ::std::result::Result::Ok(
                        ::pyo3::IntoPy::into_py(
                            SensorObservationWrapper_GNSS::_0(slf)?,
                            py,
                        ),
                    )
                }
                _ => {
                    ::std::result::Result::Err(
                        ::pyo3::exceptions::PyIndexError::new_err(
                            "tuple index out of range",
                        ),
                    )
                }
            }
        }
        const __match_args__: (&'static str,) = ("_0",);
        fn _0(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<GNSSObservationWrapper> {
            match &*slf.into_super() {
                SensorObservationWrapper::GNSS(val) => {
                    ::std::result::Result::Ok(::std::clone::Clone::clone(&val))
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper_OrientedRobot {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            _0: OrientedRobotObservationWrapper,
        ) -> ::pyo3::PyClassInitializer<SensorObservationWrapper_OrientedRobot> {
            let base_value = SensorObservationWrapper::OrientedRobot(_0);
            <::pyo3::PyClassInitializer<
                SensorObservationWrapper,
            > as ::std::convert::From<SensorObservationWrapper>>::from(base_value)
                .add_subclass(SensorObservationWrapper_OrientedRobot)
        }
        fn __len__(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<usize> {
            ::std::result::Result::Ok(1usize)
        }
        fn __getitem__(
            slf: ::pyo3::PyRef<Self>,
            idx: usize,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            let py = slf.py();
            match idx {
                0usize => {
                    ::std::result::Result::Ok(
                        ::pyo3::IntoPy::into_py(
                            SensorObservationWrapper_OrientedRobot::_0(slf)?,
                            py,
                        ),
                    )
                }
                _ => {
                    ::std::result::Result::Err(
                        ::pyo3::exceptions::PyIndexError::new_err(
                            "tuple index out of range",
                        ),
                    )
                }
            }
        }
        const __match_args__: (&'static str,) = ("_0",);
        fn _0(
            slf: ::pyo3::PyRef<Self>,
        ) -> ::pyo3::PyResult<OrientedRobotObservationWrapper> {
            match &*slf.into_super() {
                SensorObservationWrapper::OrientedRobot(val) => {
                    ::std::result::Result::Ok(::std::clone::Clone::clone(&val))
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SensorObservationWrapper {
        #[inline]
        fn clone(&self) -> SensorObservationWrapper {
            match self {
                SensorObservationWrapper::OrientedLandmark(__self_0) => {
                    SensorObservationWrapper::OrientedLandmark(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                SensorObservationWrapper::Odometry(__self_0) => {
                    SensorObservationWrapper::Odometry(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                SensorObservationWrapper::GNSS(__self_0) => {
                    SensorObservationWrapper::GNSS(::core::clone::Clone::clone(__self_0))
                }
                SensorObservationWrapper::OrientedRobot(__self_0) => {
                    SensorObservationWrapper::OrientedRobot(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    impl SensorObservationWrapper {
        pub fn new() -> Self {
            SensorObservationWrapper::GNSS(GNSSObservationWrapper::new())
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<SensorObservationWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<SensorObservationWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<SensorObservationWrapper>
                                for PyClassImplCollector<SensorObservationWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    SensorObservationWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SensorObservationWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = SensorObservationWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <SensorObservationWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = SensorObservationWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<SensorObservationWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl SensorObservationWrapper {
        pub fn from_rust(s: &SensorObservation) -> Self {
            match s {
                SensorObservation::GNSS(o) => {
                    SensorObservationWrapper::GNSS(GNSSObservationWrapper::from_rust(o))
                }
                SensorObservation::Odometry(o) => {
                    SensorObservationWrapper::Odometry(
                        OdometryObservationWrapper::from_rust(o),
                    )
                }
                SensorObservation::OrientedLandmark(o) => {
                    SensorObservationWrapper::OrientedLandmark(
                        OrientedLandmarkObservationWrapper::from_rust(o),
                    )
                }
                SensorObservation::OrientedRobot(o) => {
                    SensorObservationWrapper::OrientedRobot(
                        OrientedRobotObservationWrapper::from_rust(o),
                    )
                }
            }
        }
        pub fn to_rust(&self) -> SensorObservation {
            match self {
                SensorObservationWrapper::GNSS(o) => SensorObservation::GNSS(o.to_rust()),
                SensorObservationWrapper::Odometry(o) => {
                    SensorObservation::Odometry(o.to_rust())
                }
                SensorObservationWrapper::OrientedLandmark(o) => {
                    SensorObservation::OrientedLandmark(o.to_rust())
                }
                SensorObservationWrapper::OrientedRobot(o) => {
                    SensorObservation::OrientedRobot(o.to_rust())
                }
            }
        }
    }
    pub struct ObservationWrapper {
        pub sensor_name: String,
        pub observer: String,
        pub time: f32,
        pub sensor_observation: SensorObservationWrapper,
    }
    impl ::pyo3::types::DerefToPyAny for ObservationWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for ObservationWrapper {
        const NAME: &'static str = "Observation";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <ObservationWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for ObservationWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a ObservationWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, ObservationWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut ObservationWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, ObservationWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for ObservationWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for ObservationWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<ObservationWrapper>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ObservationWrapper,
                            String,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<ObservationWrapper>()
                                    + {
                                        { builtin # offset_of(ObservationWrapper, sensor_name) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ObservationWrapper,
                            String,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<String>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<String>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"sensor_name", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"sensor_name",
                                ObservationWrapper::__pymethod_set_sensor_name__,
                                c"",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ObservationWrapper,
                            String,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<ObservationWrapper>()
                                    + { { builtin # offset_of(ObservationWrapper, observer) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ObservationWrapper,
                            String,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<String>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<String>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"observer", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"observer",
                                ObservationWrapper::__pymethod_set_observer__,
                                c"",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ObservationWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<ObservationWrapper>()
                                    + { { builtin # offset_of(ObservationWrapper, time) } }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ObservationWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"time", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"time",
                                ObservationWrapper::__pymethod_set_time__,
                                c"",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            ObservationWrapper,
                            SensorObservationWrapper,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<ObservationWrapper>()
                                    + {
                                        {
                                            builtin # offset_of(ObservationWrapper, sensor_observation)
                                        }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            ObservationWrapper,
                            SensorObservationWrapper,
                            Offset,
                            {
                                ::pyo3::impl_::pyclass::IsPyT::<
                                    SensorObservationWrapper,
                                >::VALUE
                            },
                            {
                                ::pyo3::impl_::pyclass::IsToPyObject::<
                                    SensorObservationWrapper,
                                >::VALUE
                            },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"sensor_observation", c"")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"sensor_observation",
                                ObservationWrapper::__pymethod_set_sensor_observation__,
                                c"",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <ObservationWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<ObservationWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl ObservationWrapper {
        unsafe fn __pymethod_set_sensor_name__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "sensor_name",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .sensor_name = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_observer__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "observer",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .observer = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_time__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "time",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .time = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_sensor_observation__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "sensor_observation",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    ObservationWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .sensor_observation = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl ObservationWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl ObservationWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for ObservationWrapper {
        #[inline]
        fn clone(&self) -> ObservationWrapper {
            ObservationWrapper {
                sensor_name: ::core::clone::Clone::clone(&self.sensor_name),
                observer: ::core::clone::Clone::clone(&self.observer),
                time: ::core::clone::Clone::clone(&self.time),
                sensor_observation: ::core::clone::Clone::clone(&self.sensor_observation),
            }
        }
    }
    impl ObservationWrapper {
        pub fn new() -> Self {
            Self {
                sensor_name: "some_sensor".to_string(),
                observer: "someone".to_string(),
                time: 0.,
                sensor_observation: SensorObservationWrapper::new(),
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<ObservationWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<ObservationWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<ObservationWrapper>
                                for PyClassImplCollector<ObservationWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    ObservationWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl ObservationWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = ObservationWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <ObservationWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = ObservationWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<ObservationWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl ObservationWrapper {
        pub fn from_rust(s: &Observation) -> Self {
            Self {
                sensor_name: s.sensor_name.clone(),
                observer: s.observer.clone(),
                time: s.time,
                sensor_observation: SensorObservationWrapper::from_rust(
                    &s.sensor_observation,
                ),
            }
        }
        pub fn to_rust(&self) -> Observation {
            Observation {
                sensor_name: self.sensor_name.clone(),
                observer: self.observer.clone(),
                time: self.time,
                sensor_observation: self.sensor_observation.to_rust(),
            }
        }
    }
    pub struct CommandWrapper {
        /// Left wheel speed.
        pub left_wheel_speed: f32,
        /// Right wheel speed.
        pub right_wheel_speed: f32,
    }
    impl ::pyo3::types::DerefToPyAny for CommandWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for CommandWrapper {
        const NAME: &'static str = "Command";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <CommandWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for CommandWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a CommandWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, CommandWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut CommandWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, CommandWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for CommandWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for CommandWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<CommandWrapper>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            CommandWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<CommandWrapper>()
                                    + {
                                        { builtin # offset_of(CommandWrapper, left_wheel_speed) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            CommandWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR.generate(c"left_wheel_speed", c"Left wheel speed.")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"left_wheel_speed",
                                CommandWrapper::__pymethod_set_left_wheel_speed__,
                                c"Left wheel speed.",
                            ),
                        ),
                    ),
                    {
                        #[allow(unused_imports)]
                        use ::pyo3::impl_::pyclass::Probe;
                        struct Offset;
                        unsafe impl ::pyo3::impl_::pyclass::OffsetCalculator<
                            CommandWrapper,
                            f32,
                        > for Offset {
                            fn offset() -> usize {
                                ::pyo3::impl_::pyclass::class_offset::<CommandWrapper>()
                                    + {
                                        { builtin # offset_of(CommandWrapper, right_wheel_speed) }
                                    }
                            }
                        }
                        const GENERATOR: ::pyo3::impl_::pyclass::PyClassGetterGenerator<
                            CommandWrapper,
                            f32,
                            Offset,
                            { ::pyo3::impl_::pyclass::IsPyT::<f32>::VALUE },
                            { ::pyo3::impl_::pyclass::IsToPyObject::<f32>::VALUE },
                        > = unsafe {
                            ::pyo3::impl_::pyclass::PyClassGetterGenerator::new()
                        };
                        ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Runtime(|| {
                            GENERATOR
                                .generate(c"right_wheel_speed", c"Right wheel speed.")
                        })
                    },
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Setter(
                            ::pyo3::class::PySetterDef::new(
                                c"right_wheel_speed",
                                CommandWrapper::__pymethod_set_right_wheel_speed__,
                                c"Right wheel speed.",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <CommandWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<CommandWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl CommandWrapper {
        unsafe fn __pymethod_set_left_wheel_speed__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "left_wheel_speed",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    CommandWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .left_wheel_speed = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod_set_right_wheel_speed__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _value: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<::std::os::raw::c_int> {
            use ::std::convert::Into;
            let _value = ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr_or_opt(
                    py,
                    &_value,
                )
                .ok_or_else(|| {
                    ::pyo3::exceptions::PyAttributeError::new_err(
                        "can't delete attribute",
                    )
                })?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let _val = ::pyo3::impl_::deprecations::inspect_type(
                ::pyo3::impl_::extract_argument::extract_argument(
                    _value.into(),
                    &mut holder_1,
                    "right_wheel_speed",
                )?,
                &gil_refs_checker_0,
            );
            let result = {
                ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                    CommandWrapper,
                >(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                        &mut holder_0,
                    )?
                    .right_wheel_speed = _val;
            };
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl CommandWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl CommandWrapper {}
    #[automatically_derived]
    impl ::core::clone::Clone for CommandWrapper {
        #[inline]
        fn clone(&self) -> CommandWrapper {
            CommandWrapper {
                left_wheel_speed: ::core::clone::Clone::clone(&self.left_wheel_speed),
                right_wheel_speed: ::core::clone::Clone::clone(&self.right_wheel_speed),
            }
        }
    }
    impl CommandWrapper {
        pub fn new() -> CommandWrapper {
            Self {
                left_wheel_speed: 0.,
                right_wheel_speed: 0.,
            }
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<CommandWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<CommandWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<CommandWrapper>
                                for PyClassImplCollector<CommandWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    CommandWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl CommandWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = CommandWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <CommandWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = CommandWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<CommandWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl CommandWrapper {
        pub fn from_rust(s: &Command) -> Self {
            Self {
                left_wheel_speed: s.left_wheel_speed,
                right_wheel_speed: s.right_wheel_speed,
            }
        }
        pub fn to_rust(&self) -> Command {
            Command {
                left_wheel_speed: self.left_wheel_speed,
                right_wheel_speed: self.right_wheel_speed,
            }
        }
    }
    pub struct PluginAPIWrapper {}
    impl ::pyo3::types::DerefToPyAny for PluginAPIWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for PluginAPIWrapper {
        const NAME: &'static str = "PluginAPI";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <PluginAPIWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for PluginAPIWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a PluginAPIWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, PluginAPIWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut PluginAPIWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, PluginAPIWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for PluginAPIWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for PluginAPIWrapper {
        const IS_BASETYPE: bool = true;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<PluginAPIWrapper>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <PluginAPIWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<PluginAPIWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl PluginAPIWrapper {}
    impl PluginAPIWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl PluginAPIWrapper {}
    impl PluginAPIWrapper {
        pub fn new() -> Self {
            Self {}
        }
        /// Return the [`StateEstimator`](`crate::state_estimators::state_estimators::StateEstimator`) to be used by the
        /// [`ExternalEstimator`](`crate::state_estimators::external_estimator::ExternalEstimator`).
        ///
        /// # Arguments
        /// * `config` - Config for the external state estimator. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`StateEstimator`] to use.
        pub fn get_state_estimator(
            &self,
            _config: Py<PyAny>,
            _global_config: Py<PyAny>,
        ) -> PythonStateEstimator {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "The given PluginAPI does not provide a state estimator",
                    ),
                );
            };
        }
        /// Return the [`Controller`] to be used by the
        /// [`ExternalController`](`crate::controllers::external_controller::ExternalController`).
        ///
        /// # Arguments
        /// * `config` - Config for the external controller. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`Controller`] to use.
        pub fn get_controller(
            &self,
            _config: Py<PyAny>,
            _global_config: Py<PyAny>,
        ) -> PythonController {
            {
                ::core::panicking::panic_fmt(
                    format_args!("The given PluginAPI does not provide a controller"),
                );
            };
        }
        /// Return the [`Navigator`] to be used by the
        /// [`ExternalNavigator`](`crate::navigators::external_navigator::ExternalNavigator`).
        ///
        /// # Arguments
        /// * `config` - Config for the external navigator. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`Navigator`] to use.
        pub fn get_navigator(
            &self,
            _config: Py<PyAny>,
            _global_config: Py<PyAny>,
        ) -> PythonNavigator {
            {
                ::core::panicking::panic_fmt(
                    format_args!("The given PluginAPI does not provide a navigator"),
                );
            };
        }
        /// Return the [`Physic`] to be used by the
        /// [`ExternalPhysic`](`crate::physcs::external_physic::ExternalPhysic`).
        ///
        /// # Arguments
        /// * `config` - Config for the external physic. The configuration
        /// is given using [`serde_json::Value`]. It should be converted by the
        /// external plugin to the specific configuration.
        /// * `global_config` - Full configuration of the simulator.
        ///
        /// # Return
        ///
        /// Returns the [`Physic`] to use.
        pub fn get_physic(
            &self,
            _config: Py<PyAny>,
            _global_config: Py<PyAny>,
        ) -> PythonPhysic {
            {
                ::core::panicking::panic_fmt(
                    format_args!("The given PluginAPI does not provide a physic"),
                );
            };
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<PluginAPIWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<PluginAPIWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Method(
                            ::pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                                c"get_state_estimator",
                                {
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut ::pyo3::ffi::PyObject,
                                        _args: *const *mut ::pyo3::ffi::PyObject,
                                        _nargs: ::pyo3::ffi::Py_ssize_t,
                                        _kwnames: *mut ::pyo3::ffi::PyObject,
                                    ) -> *mut ::pyo3::ffi::PyObject {
                                        ::pyo3::impl_::trampoline::fastcall_with_keywords(
                                            _slf,
                                            _args,
                                            _nargs,
                                            _kwnames,
                                            PluginAPIWrapper::__pymethod_get_state_estimator__,
                                        )
                                    }
                                    trampoline
                                },
                                c"get_state_estimator($self, _config, _global_config)\n--\n\nReturn the [`StateEstimator`](`crate::state_estimators::state_estimators::StateEstimator`) to be used by the\n[`ExternalEstimator`](`crate::state_estimators::external_estimator::ExternalEstimator`).\n\n# Arguments\n* `config` - Config for the external state estimator. The configuration\nis given using [`serde_json::Value`]. It should be converted by the\nexternal plugin to the specific configuration.\n* `global_config` - Full configuration of the simulator.\n\n# Return\n\nReturns the [`StateEstimator`] to use.",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Method(
                            ::pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                                c"get_controller",
                                {
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut ::pyo3::ffi::PyObject,
                                        _args: *const *mut ::pyo3::ffi::PyObject,
                                        _nargs: ::pyo3::ffi::Py_ssize_t,
                                        _kwnames: *mut ::pyo3::ffi::PyObject,
                                    ) -> *mut ::pyo3::ffi::PyObject {
                                        ::pyo3::impl_::trampoline::fastcall_with_keywords(
                                            _slf,
                                            _args,
                                            _nargs,
                                            _kwnames,
                                            PluginAPIWrapper::__pymethod_get_controller__,
                                        )
                                    }
                                    trampoline
                                },
                                c"get_controller($self, _config, _global_config)\n--\n\nReturn the [`Controller`] to be used by the\n[`ExternalController`](`crate::controllers::external_controller::ExternalController`).\n\n# Arguments\n* `config` - Config for the external controller. The configuration\nis given using [`serde_json::Value`]. It should be converted by the\nexternal plugin to the specific configuration.\n* `global_config` - Full configuration of the simulator.\n\n# Return\n\nReturns the [`Controller`] to use.",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Method(
                            ::pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                                c"get_navigator",
                                {
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut ::pyo3::ffi::PyObject,
                                        _args: *const *mut ::pyo3::ffi::PyObject,
                                        _nargs: ::pyo3::ffi::Py_ssize_t,
                                        _kwnames: *mut ::pyo3::ffi::PyObject,
                                    ) -> *mut ::pyo3::ffi::PyObject {
                                        ::pyo3::impl_::trampoline::fastcall_with_keywords(
                                            _slf,
                                            _args,
                                            _nargs,
                                            _kwnames,
                                            PluginAPIWrapper::__pymethod_get_navigator__,
                                        )
                                    }
                                    trampoline
                                },
                                c"get_navigator($self, _config, _global_config)\n--\n\nReturn the [`Navigator`] to be used by the\n[`ExternalNavigator`](`crate::navigators::external_navigator::ExternalNavigator`).\n\n# Arguments\n* `config` - Config for the external navigator. The configuration\nis given using [`serde_json::Value`]. It should be converted by the\nexternal plugin to the specific configuration.\n* `global_config` - Full configuration of the simulator.\n\n# Return\n\nReturns the [`Navigator`] to use.",
                            ),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Method(
                            ::pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                                c"get_physic",
                                {
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut ::pyo3::ffi::PyObject,
                                        _args: *const *mut ::pyo3::ffi::PyObject,
                                        _nargs: ::pyo3::ffi::Py_ssize_t,
                                        _kwnames: *mut ::pyo3::ffi::PyObject,
                                    ) -> *mut ::pyo3::ffi::PyObject {
                                        ::pyo3::impl_::trampoline::fastcall_with_keywords(
                                            _slf,
                                            _args,
                                            _nargs,
                                            _kwnames,
                                            PluginAPIWrapper::__pymethod_get_physic__,
                                        )
                                    }
                                    trampoline
                                },
                                c"get_physic($self, _config, _global_config)\n--\n\nReturn the [`Physic`] to be used by the\n[`ExternalPhysic`](`crate::physcs::external_physic::ExternalPhysic`).\n\n# Arguments\n* `config` - Config for the external physic. The configuration\nis given using [`serde_json::Value`]. It should be converted by the\nexternal plugin to the specific configuration.\n* `global_config` - Full configuration of the simulator.\n\n# Return\n\nReturns the [`Physic`] to use.",
                            ),
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<PluginAPIWrapper>
                                for PyClassImplCollector<PluginAPIWrapper> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("()")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    PluginAPIWrapper::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl PluginAPIWrapper {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = PluginAPIWrapper::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <PluginAPIWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &[],
                positional_only_parameters: 0usize,
                required_positional_parameters: 0usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 0usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let result = PluginAPIWrapper::new();
            let initializer: ::pyo3::PyClassInitializer<PluginAPIWrapper> = result
                .convert(py)?;
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
        unsafe fn __pymethod_get_state_estimator__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _args: *const *mut ::pyo3::ffi::PyObject,
            _nargs: ::pyo3::ffi::Py_ssize_t,
            _kwnames: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = PluginAPIWrapper::get_state_estimator;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <PluginAPIWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "get_state_estimator",
                positional_parameter_names: &["_config", "_global_config"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_fastcall::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _nargs, _kwnames, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_2 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = {
                let ret = function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            PluginAPIWrapper,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_2,
                        )?,
                        &gil_refs_checker_2,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "_config",
                        )?,
                        &gil_refs_checker_0,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize].as_deref(),
                            ),
                            &mut holder_1,
                            "_global_config",
                        )?,
                        &gil_refs_checker_1,
                    ),
                );
                ::pyo3::impl_::wrap::map_result_into_ptr(
                    py,
                    ::pyo3::impl_::wrap::OkWrap::wrap(ret)
                        .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
                )
            };
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            result
        }
        unsafe fn __pymethod_get_controller__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _args: *const *mut ::pyo3::ffi::PyObject,
            _nargs: ::pyo3::ffi::Py_ssize_t,
            _kwnames: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = PluginAPIWrapper::get_controller;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <PluginAPIWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "get_controller",
                positional_parameter_names: &["_config", "_global_config"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_fastcall::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _nargs, _kwnames, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_2 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = {
                let ret = function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            PluginAPIWrapper,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_2,
                        )?,
                        &gil_refs_checker_2,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "_config",
                        )?,
                        &gil_refs_checker_0,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize].as_deref(),
                            ),
                            &mut holder_1,
                            "_global_config",
                        )?,
                        &gil_refs_checker_1,
                    ),
                );
                ::pyo3::impl_::wrap::map_result_into_ptr(
                    py,
                    ::pyo3::impl_::wrap::OkWrap::wrap(ret)
                        .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
                )
            };
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            result
        }
        unsafe fn __pymethod_get_navigator__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _args: *const *mut ::pyo3::ffi::PyObject,
            _nargs: ::pyo3::ffi::Py_ssize_t,
            _kwnames: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = PluginAPIWrapper::get_navigator;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <PluginAPIWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "get_navigator",
                positional_parameter_names: &["_config", "_global_config"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_fastcall::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _nargs, _kwnames, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_2 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = {
                let ret = function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            PluginAPIWrapper,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_2,
                        )?,
                        &gil_refs_checker_2,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "_config",
                        )?,
                        &gil_refs_checker_0,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize].as_deref(),
                            ),
                            &mut holder_1,
                            "_global_config",
                        )?,
                        &gil_refs_checker_1,
                    ),
                );
                ::pyo3::impl_::wrap::map_result_into_ptr(
                    py,
                    ::pyo3::impl_::wrap::OkWrap::wrap(ret)
                        .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
                )
            };
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            result
        }
        unsafe fn __pymethod_get_physic__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _args: *const *mut ::pyo3::ffi::PyObject,
            _nargs: ::pyo3::ffi::Py_ssize_t,
            _kwnames: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = PluginAPIWrapper::get_physic;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <PluginAPIWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "get_physic",
                positional_parameter_names: &["_config", "_global_config"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_fastcall::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _nargs, _kwnames, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_2 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = {
                let ret = function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                            PluginAPIWrapper,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_2,
                        )?,
                        &gil_refs_checker_2,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "_config",
                        )?,
                        &gil_refs_checker_0,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize].as_deref(),
                            ),
                            &mut holder_1,
                            "_global_config",
                        )?,
                        &gil_refs_checker_1,
                    ),
                );
                ::pyo3::impl_::wrap::map_result_into_ptr(
                    py,
                    ::pyo3::impl_::wrap::OkWrap::wrap(ret)
                        .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
                )
            };
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            result
        }
    }
    pub struct SimulatorWrapper {
        server: Arc<Mutex<AsyncApiRunner>>,
        api: AsyncApi,
        async_plugin_api: Option<PluginAsyncAPI>,
        python_api: Option<PythonAPI>,
    }
    impl ::pyo3::types::DerefToPyAny for SimulatorWrapper {}
    unsafe impl ::pyo3::type_object::PyTypeInfo for SimulatorWrapper {
        const NAME: &'static str = "Simulator";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <SimulatorWrapper as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for SimulatorWrapper {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a SimulatorWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, SimulatorWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut SimulatorWrapper {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, SimulatorWrapper>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for SimulatorWrapper {
        fn into_py(self, py: ::pyo3::Python<'_>) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for SimulatorWrapper {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<SimulatorWrapper>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <SimulatorWrapper as ::pyo3::PyTypeInfo>::NAME,
                            c"",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<SimulatorWrapper> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SimulatorWrapper {}
    impl SimulatorWrapper {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SimulatorWrapper {}
    impl SimulatorWrapper {
        pub fn from_config(
            config_path: String,
            plugin_api: Option<Py<PyAny>>,
        ) -> SimulatorWrapper {
            Simulator::init_environment();
            let server = Arc::new(Mutex::new(AsyncApiRunner::new()));
            let api = server.lock().unwrap().get_api();
            let mut wrapper = SimulatorWrapper {
                server,
                api,
                async_plugin_api: match &plugin_api {
                    Some(_) => Some(PluginAsyncAPI::new()),
                    None => None,
                },
                python_api: match plugin_api {
                    Some(a) => Some(PythonAPI::new(a)),
                    None => None,
                },
            };
            wrapper
                .server
                .lock()
                .unwrap()
                .run(
                    match &wrapper.async_plugin_api {
                        Some(api) => {
                            Some(
                                Box::<
                                    &dyn PluginAPI,
                                >::new(unsafe {
                                    std::mem::transmute::<
                                        &dyn PluginAPI,
                                        &'static dyn PluginAPI,
                                    >(api)
                                }),
                            )
                        }
                        None => None,
                    },
                );
            wrapper.api.load_config.async_call(config_path);
            if let Some(unwrapped_async_api) = &wrapper.async_plugin_api {
                let api_client = &unwrapped_async_api.client;
                let python_api = wrapper.python_api.as_mut().unwrap();
                while wrapper.api.load_config.try_get_result().is_none() {
                    if let Ok((config, simulator_config)) = api_client
                        .get_state_estimator_request
                        .lock()
                        .unwrap()
                        .try_recv()
                    {
                        let state_estimator = python_api
                            .get_state_estimator(&config, &simulator_config);
                        api_client
                            .get_state_estimator_response
                            .send(state_estimator)
                            .unwrap();
                    }
                    if let Ok((config, simulator_config)) = api_client
                        .get_controller_request
                        .lock()
                        .unwrap()
                        .try_recv()
                    {
                        let controller = python_api
                            .get_controller(&config, &simulator_config);
                        api_client.get_controller_response.send(controller).unwrap();
                    }
                    if let Ok((config, simulator_config)) = api_client
                        .get_navigator_request
                        .lock()
                        .unwrap()
                        .try_recv()
                    {
                        let navigator = python_api
                            .get_navigator(&config, &simulator_config);
                        api_client.get_navigator_response.send(navigator).unwrap();
                    }
                    if let Ok((config, simulator_config)) = api_client
                        .get_physic_request
                        .lock()
                        .unwrap()
                        .try_recv()
                    {
                        let physic = python_api.get_physic(&config, &simulator_config);
                        api_client.get_physic_response.send(physic).unwrap();
                    }
                    python_api.check_requests();
                }
            } else {
                wrapper.api.load_config.wait_result();
            }
            wrapper
        }
        pub fn run(&mut self) {
            self.api.run.call(None);
            if let Some(python_api) = &mut self.python_api {
                while self.api.run.try_get_result().is_none() {
                    python_api.check_requests();
                    if Python::with_gil(|py| py.check_signals()).is_err() {
                        break;
                    }
                }
            } else {
                while self.api.run.try_get_result().is_none() {
                    if Python::with_gil(|py| py.check_signals()).is_err() {
                        break;
                    }
                }
            }
            self.server.lock().unwrap().stop();
            self.server
                .lock()
                .unwrap()
                .get_simulator()
                .lock()
                .unwrap()
                .compute_results();
        }
    }
    #[allow(unknown_lints, non_local_definitions)]
    impl ::pyo3::impl_::pyclass::PyMethods<SimulatorWrapper>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<SimulatorWrapper> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Static(
                            ::pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                                    c"from_config",
                                    {
                                        unsafe extern "C" fn trampoline(
                                            _slf: *mut ::pyo3::ffi::PyObject,
                                            _args: *const *mut ::pyo3::ffi::PyObject,
                                            _nargs: ::pyo3::ffi::Py_ssize_t,
                                            _kwnames: *mut ::pyo3::ffi::PyObject,
                                        ) -> *mut ::pyo3::ffi::PyObject {
                                            ::pyo3::impl_::trampoline::fastcall_with_keywords(
                                                _slf,
                                                _args,
                                                _nargs,
                                                _kwnames,
                                                SimulatorWrapper::__pymethod_from_config__,
                                            )
                                        }
                                        trampoline
                                    },
                                    c"from_config(config_path, plugin_api=None)\n--\n\n",
                                )
                                .flags(::pyo3::ffi::METH_STATIC),
                        ),
                    ),
                    ::pyo3::impl_::pyclass::MaybeRuntimePyMethodDef::Static(
                        ::pyo3::class::PyMethodDefType::Method(
                            ::pyo3::impl_::pymethods::PyMethodDef::noargs(
                                c"run",
                                {
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut ::pyo3::ffi::PyObject,
                                        _args: *mut ::pyo3::ffi::PyObject,
                                    ) -> *mut ::pyo3::ffi::PyObject {
                                        ::pyo3::impl_::trampoline::noargs(
                                            _slf,
                                            _args,
                                            SimulatorWrapper::__pymethod_run__,
                                        )
                                    }
                                    trampoline
                                },
                                c"run($self)\n--\n\n",
                            ),
                        ),
                    ),
                ],
                slots: &[],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl SimulatorWrapper {
        unsafe fn __pymethod_from_config__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
            _args: *const *mut ::pyo3::ffi::PyObject,
            _nargs: ::pyo3::ffi::Py_ssize_t,
            _kwnames: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = SimulatorWrapper::from_config;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <SimulatorWrapper as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "from_config",
                positional_parameter_names: &["config_path", "plugin_api"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 1usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_fastcall::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _nargs, _kwnames, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = {
                let ret = function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "config_path",
                        )?,
                        &gil_refs_checker_0,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_optional_argument(
                            output[1usize].as_deref(),
                            &mut holder_1,
                            "plugin_api",
                            #[allow(clippy::redundant_closure)]
                            { || ::pyo3::impl_::wrap::SomeWrap::wrap(None) },
                        )?,
                        &gil_refs_checker_1,
                    ),
                );
                ::pyo3::impl_::wrap::map_result_into_ptr(
                    py,
                    ::pyo3::impl_::wrap::OkWrap::wrap(ret)
                        .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
                )
            };
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            result
        }
        unsafe fn __pymethod_run__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = SimulatorWrapper::run;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = {
                let ret = function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            SimulatorWrapper,
                        >(
                            ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                .0,
                            &mut holder_0,
                        )?,
                        &gil_refs_checker_0,
                    ),
                );
                ::pyo3::impl_::wrap::map_result_into_ptr(
                    py,
                    ::pyo3::impl_::wrap::OkWrap::wrap(ret)
                        .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
                )
            };
            gil_refs_checker_0.function_arg();
            result
        }
    }
}
pub mod api {
    pub mod async_api {
        use std::{
            os::unix::thread::JoinHandleExt, path::Path, sync::{mpsc, Arc, Mutex},
            thread::{self, sleep, JoinHandle},
            time::Duration,
        };
        use serde_json::Value;
        use crate::{
            controllers::controller::Controller, navigators::navigator::Navigator,
            node_factory::NodeRecord, physics::physic::Physic, plugin_api::PluginAPI,
            simulator::{Record, Simulator, SimulatorAsyncApi, SimulatorConfig},
            state_estimators::state_estimator::StateEstimator, utils::rfc,
        };
        pub struct AsyncApi {
            pub simulator_api: Arc<SimulatorAsyncApi>,
            pub load_config: rfc::RemoteFunctionCall<String, SimulatorConfig>,
            pub run: rfc::RemoteFunctionCall<Option<f32>, ()>,
            pub compute_results: rfc::RemoteFunctionCall<(), ()>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AsyncApi {
            #[inline]
            fn clone(&self) -> AsyncApi {
                AsyncApi {
                    simulator_api: ::core::clone::Clone::clone(&self.simulator_api),
                    load_config: ::core::clone::Clone::clone(&self.load_config),
                    run: ::core::clone::Clone::clone(&self.run),
                    compute_results: ::core::clone::Clone::clone(&self.compute_results),
                }
            }
        }
        pub struct AsyncApiServer {
            pub load_config: rfc::RemoteFunctionCallHost<String, SimulatorConfig>,
            pub run: rfc::RemoteFunctionCallHost<Option<f32>, ()>,
            pub compute_results: rfc::RemoteFunctionCallHost<(), ()>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AsyncApiServer {
            #[inline]
            fn clone(&self) -> AsyncApiServer {
                AsyncApiServer {
                    load_config: ::core::clone::Clone::clone(&self.load_config),
                    run: ::core::clone::Clone::clone(&self.run),
                    compute_results: ::core::clone::Clone::clone(&self.compute_results),
                }
            }
        }
        pub struct AsyncApiRunner {
            public_api: AsyncApi,
            private_api: AsyncApiServer,
            simulator: Arc<Mutex<Simulator>>,
            keep_alive_tx: mpsc::Sender<()>,
            keep_alive_rx: Arc<Mutex<mpsc::Receiver<()>>>,
            thread_handle: Option<JoinHandle<()>>,
        }
        impl AsyncApiRunner {
            pub fn new() -> Self {
                let simulator = Arc::new(Mutex::new(Simulator::new()));
                AsyncApiRunner::new_with_simulator(simulator)
            }
            pub fn new_with_simulator(simulator: Arc<Mutex<Simulator>>) -> Self {
                let (load_config_call, load_config_host) = rfc::make_pair();
                let (run_call, run_host) = rfc::make_pair();
                let (results_call, results_host) = rfc::make_pair();
                let (keep_alive_tx, keep_alive_rx) = mpsc::channel();
                let simulator_api = simulator.lock().unwrap().get_async_api();
                Self {
                    public_api: AsyncApi {
                        simulator_api,
                        load_config: load_config_call,
                        run: run_call,
                        compute_results: results_call,
                    },
                    private_api: AsyncApiServer {
                        load_config: load_config_host,
                        run: run_host,
                        compute_results: results_host,
                    },
                    simulator,
                    keep_alive_rx: Arc::new(Mutex::new(keep_alive_rx)),
                    keep_alive_tx,
                    thread_handle: None,
                }
            }
            pub fn get_api(&self) -> AsyncApi {
                self.public_api.clone()
            }
            pub fn get_simulator(&self) -> Arc<Mutex<Simulator>> {
                self.simulator.clone()
            }
            pub fn stop(&mut self) {
                self.keep_alive_tx.send(()).unwrap();
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Stop requested..."),
                                lvl,
                                &(
                                    "simba::api::async_api",
                                    "simba::api::async_api",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                if let Some(handle) = self.thread_handle.take() {
                    sleep(Duration::new(0, 200000000));
                    if !handle.is_finished() {
                        unsafe {
                            libc::pthread_cancel(handle.as_pthread_t());
                        }
                    }
                    handle
                        .join()
                        .expect("Error while waiting for server thread to join");
                }
            }
            pub fn run(&mut self, plugin_api: Option<Box<&'static dyn PluginAPI>>) {
                let private_api = self.private_api.clone();
                let keep_alive_rx = self.keep_alive_rx.clone();
                let simulator_arc = self.simulator.clone();
                let plugin_api = plugin_api.clone();
                self.thread_handle = Some(
                    thread::spawn(move || {
                        let plugin_api = plugin_api.clone();
                        let mut simulator = simulator_arc.lock().unwrap();
                        let mut need_reset = false;
                        loop {
                            if let Ok(_) = keep_alive_rx.lock().unwrap().try_recv() {
                                break;
                            }
                            private_api
                                .load_config
                                .try_recv_closure_mut(|config_path| {
                                    {
                                        ::std::io::_print(
                                            format_args!("Loading config: {0}\n", config_path),
                                        );
                                    };
                                    let path = Path::new(&config_path);
                                    simulator.load_config_path(path, &plugin_api);
                                    {
                                        ::std::io::_print(format_args!("End loading\n"));
                                    };
                                    simulator.config()
                                });
                            private_api
                                .run
                                .try_recv_closure_mut(|max_time| {
                                    if need_reset {
                                        simulator.reset(&plugin_api);
                                    }
                                    if let Some(max_time) = max_time {
                                        simulator.set_max_time(max_time);
                                    }
                                    simulator.run();
                                    need_reset = true;
                                });
                            private_api
                                .compute_results
                                .try_recv_closure_mut(|_| {
                                    simulator.compute_results();
                                    need_reset = true;
                                });
                        }
                        {
                            {
                                let lvl = ::log::Level::Info;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("AsyncApiRunner thread exited"),
                                        lvl,
                                        &(
                                            "simba::api::async_api",
                                            "simba::api::async_api",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }),
                );
            }
        }
        pub struct PluginAsyncAPI {
            pub client: PluginAsyncAPIClient,
            pub get_state_estimator_request: mpsc::Sender<(Value, SimulatorConfig)>,
            pub get_state_estimator_response: Arc<
                Mutex<mpsc::Receiver<Box<dyn StateEstimator>>>,
            >,
            pub get_controller_request: mpsc::Sender<(Value, SimulatorConfig)>,
            pub get_controller_response: Arc<Mutex<mpsc::Receiver<Box<dyn Controller>>>>,
            pub get_navigator_request: mpsc::Sender<(Value, SimulatorConfig)>,
            pub get_navigator_response: Arc<Mutex<mpsc::Receiver<Box<dyn Navigator>>>>,
            pub get_physic_request: mpsc::Sender<(Value, SimulatorConfig)>,
            pub get_physic_response: Arc<Mutex<mpsc::Receiver<Box<dyn Physic>>>>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PluginAsyncAPI {
            #[inline]
            fn clone(&self) -> PluginAsyncAPI {
                PluginAsyncAPI {
                    client: ::core::clone::Clone::clone(&self.client),
                    get_state_estimator_request: ::core::clone::Clone::clone(
                        &self.get_state_estimator_request,
                    ),
                    get_state_estimator_response: ::core::clone::Clone::clone(
                        &self.get_state_estimator_response,
                    ),
                    get_controller_request: ::core::clone::Clone::clone(
                        &self.get_controller_request,
                    ),
                    get_controller_response: ::core::clone::Clone::clone(
                        &self.get_controller_response,
                    ),
                    get_navigator_request: ::core::clone::Clone::clone(
                        &self.get_navigator_request,
                    ),
                    get_navigator_response: ::core::clone::Clone::clone(
                        &self.get_navigator_response,
                    ),
                    get_physic_request: ::core::clone::Clone::clone(
                        &self.get_physic_request,
                    ),
                    get_physic_response: ::core::clone::Clone::clone(
                        &self.get_physic_response,
                    ),
                }
            }
        }
        impl PluginAsyncAPI {
            pub fn new() -> PluginAsyncAPI {
                let (get_state_estimator_request_tx, get_state_estimator_request_rx) = mpsc::channel();
                let (get_state_estimator_response_tx, get_state_estimator_response_rx) = mpsc::channel();
                let (get_controller_request_tx, get_controller_request_rx) = mpsc::channel();
                let (get_controller_response_tx, get_controller_response_rx) = mpsc::channel();
                let (get_navigator_request_tx, get_navigator_request_rx) = mpsc::channel();
                let (get_navigator_response_tx, get_navigator_response_rx) = mpsc::channel();
                let (get_physic_request_tx, get_physic_request_rx) = mpsc::channel();
                let (get_physic_response_tx, get_physic_response_rx) = mpsc::channel();
                PluginAsyncAPI {
                    client: PluginAsyncAPIClient {
                        get_state_estimator_request: Arc::new(
                            Mutex::new(get_state_estimator_request_rx),
                        ),
                        get_state_estimator_response: get_state_estimator_response_tx,
                        get_controller_request: Arc::new(
                            Mutex::new(get_controller_request_rx),
                        ),
                        get_controller_response: get_controller_response_tx,
                        get_navigator_request: Arc::new(
                            Mutex::new(get_navigator_request_rx),
                        ),
                        get_navigator_response: get_navigator_response_tx,
                        get_physic_request: Arc::new(Mutex::new(get_physic_request_rx)),
                        get_physic_response: get_physic_response_tx,
                    },
                    get_state_estimator_request: get_state_estimator_request_tx,
                    get_state_estimator_response: Arc::new(
                        Mutex::new(get_state_estimator_response_rx),
                    ),
                    get_controller_request: get_controller_request_tx,
                    get_controller_response: Arc::new(
                        Mutex::new(get_controller_response_rx),
                    ),
                    get_navigator_request: get_navigator_request_tx,
                    get_navigator_response: Arc::new(
                        Mutex::new(get_navigator_response_rx),
                    ),
                    get_physic_request: get_physic_request_tx,
                    get_physic_response: Arc::new(Mutex::new(get_physic_response_rx)),
                }
            }
        }
        impl PluginAPI for PluginAsyncAPI {
            fn get_state_estimator(
                &self,
                config: &Value,
                global_config: &SimulatorConfig,
            ) -> Box<dyn StateEstimator> {
                self.get_state_estimator_request
                    .send((config.clone(), global_config.clone()))
                    .unwrap();
                self.get_state_estimator_response.lock().unwrap().recv().unwrap()
            }
            fn get_controller(
                &self,
                config: &Value,
                global_config: &SimulatorConfig,
            ) -> Box<dyn Controller> {
                self.get_controller_request
                    .send((config.clone(), global_config.clone()))
                    .unwrap();
                self.get_controller_response.lock().unwrap().recv().unwrap()
            }
            fn get_navigator(
                &self,
                config: &Value,
                global_config: &SimulatorConfig,
            ) -> Box<dyn Navigator> {
                self.get_navigator_request
                    .send((config.clone(), global_config.clone()))
                    .unwrap();
                self.get_navigator_response.lock().unwrap().recv().unwrap()
            }
            fn get_physic(
                &self,
                config: &Value,
                global_config: &SimulatorConfig,
            ) -> Box<dyn Physic> {
                self.get_physic_request
                    .send((config.clone(), global_config.clone()))
                    .unwrap();
                self.get_physic_response.lock().unwrap().recv().unwrap()
            }
        }
        pub struct PluginAsyncAPIClient {
            pub get_state_estimator_request: Arc<
                Mutex<mpsc::Receiver<(Value, SimulatorConfig)>>,
            >,
            pub get_state_estimator_response: mpsc::Sender<Box<dyn StateEstimator>>,
            pub get_controller_request: Arc<
                Mutex<mpsc::Receiver<(Value, SimulatorConfig)>>,
            >,
            pub get_controller_response: mpsc::Sender<Box<dyn Controller>>,
            pub get_navigator_request: Arc<
                Mutex<mpsc::Receiver<(Value, SimulatorConfig)>>,
            >,
            pub get_navigator_response: mpsc::Sender<Box<dyn Navigator>>,
            pub get_physic_request: Arc<Mutex<mpsc::Receiver<(Value, SimulatorConfig)>>>,
            pub get_physic_response: mpsc::Sender<Box<dyn Physic>>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PluginAsyncAPIClient {
            #[inline]
            fn clone(&self) -> PluginAsyncAPIClient {
                PluginAsyncAPIClient {
                    get_state_estimator_request: ::core::clone::Clone::clone(
                        &self.get_state_estimator_request,
                    ),
                    get_state_estimator_response: ::core::clone::Clone::clone(
                        &self.get_state_estimator_response,
                    ),
                    get_controller_request: ::core::clone::Clone::clone(
                        &self.get_controller_request,
                    ),
                    get_controller_response: ::core::clone::Clone::clone(
                        &self.get_controller_response,
                    ),
                    get_navigator_request: ::core::clone::Clone::clone(
                        &self.get_navigator_request,
                    ),
                    get_navigator_response: ::core::clone::Clone::clone(
                        &self.get_navigator_response,
                    ),
                    get_physic_request: ::core::clone::Clone::clone(
                        &self.get_physic_request,
                    ),
                    get_physic_response: ::core::clone::Clone::clone(
                        &self.get_physic_response,
                    ),
                }
            }
        }
    }
    pub mod internal_api {
        use std::sync::mpsc::{self, Receiver, Sender};
        use crate::{node_factory::NodeType, state_estimators::state_estimator::State};
        pub struct NodeServer {
            pub state_update: Option<Sender<(f32, State)>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NodeServer {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NodeServer",
                    "state_update",
                    &&self.state_update,
                )
            }
        }
        pub struct NodeClient {
            pub state_update: Option<Receiver<(f32, State)>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NodeClient {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NodeClient",
                    "state_update",
                    &&self.state_update,
                )
            }
        }
        pub fn make_node_api(node_type: &NodeType) -> (NodeServer, NodeClient) {
            let state_update = if node_type.has_physics() {
                let (tx, rx) = mpsc::channel();
                (Some(tx), Some(rx))
            } else {
                (None, None)
            };
            (
                NodeServer {
                    state_update: state_update.0,
                },
                NodeClient {
                    state_update: state_update.1,
                },
            )
        }
    }
}
pub mod time_analysis {
    use config_checker::macros::Check;
    use serde::{Deserialize, Serialize};
    use simba_macros::ToVec;
    use std::collections::BTreeMap;
    use std::time;
    use crate::gui::{
        utils::{enum_radio, path_finder, string_combobox},
        UIComponent,
    };
    #[serde(default)]
    #[serde(deny_unknown_fields)]
    #[allow(dead_code, unused_variables)]
    pub struct TimeAnalysisConfig {
        pub exporter: ProfileExporterConfig,
        pub keep_last: bool,
        pub output_path: String,
        #[convert(as_str)]
        #[check(inside("s", "ms", "us", "s", "ns"))]
        pub analysis_unit: String,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TimeAnalysisConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TimeAnalysisConfig",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "exporter",
                    &self.exporter,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "keep_last",
                    &self.keep_last,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "output_path",
                    &self.output_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "analysis_unit",
                    &self.analysis_unit,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TimeAnalysisConfig
        where
            TimeAnalysisConfig: _serde::__private::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "exporter" => _serde::__private::Ok(__Field::__field0),
                            "keep_last" => _serde::__private::Ok(__Field::__field1),
                            "output_path" => _serde::__private::Ok(__Field::__field2),
                            "analysis_unit" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"exporter" => _serde::__private::Ok(__Field::__field0),
                            b"keep_last" => _serde::__private::Ok(__Field::__field1),
                            b"output_path" => _serde::__private::Ok(__Field::__field2),
                            b"analysis_unit" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    TimeAnalysisConfig: _serde::__private::Default,
                {
                    marker: _serde::__private::PhantomData<TimeAnalysisConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    TimeAnalysisConfig: _serde::__private::Default,
                {
                    type Value = TimeAnalysisConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TimeAnalysisConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ProfileExporterConfig,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.exporter,
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.keep_last,
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.output_path,
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => __default.analysis_unit,
                        };
                        _serde::__private::Ok(TimeAnalysisConfig {
                            exporter: __field0,
                            keep_last: __field1,
                            output_path: __field2,
                            analysis_unit: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ProfileExporterConfig,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "exporter",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ProfileExporterConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "keep_last",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "output_path",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "analysis_unit",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => __default.exporter,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => __default.keep_last,
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => __default.output_path,
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => __default.analysis_unit,
                        };
                        _serde::__private::Ok(TimeAnalysisConfig {
                            exporter: __field0,
                            keep_last: __field1,
                            output_path: __field2,
                            analysis_unit: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "exporter",
                    "keep_last",
                    "output_path",
                    "analysis_unit",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TimeAnalysisConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TimeAnalysisConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(dead_code, unused_variables)]
    impl ::core::fmt::Debug for TimeAnalysisConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TimeAnalysisConfig",
                "exporter",
                &self.exporter,
                "keep_last",
                &self.keep_last,
                "output_path",
                &self.output_path,
                "analysis_unit",
                &&self.analysis_unit,
            )
        }
    }
    #[automatically_derived]
    #[allow(dead_code, unused_variables)]
    impl ::core::clone::Clone for TimeAnalysisConfig {
        #[inline]
        fn clone(&self) -> TimeAnalysisConfig {
            TimeAnalysisConfig {
                exporter: ::core::clone::Clone::clone(&self.exporter),
                keep_last: ::core::clone::Clone::clone(&self.keep_last),
                output_path: ::core::clone::Clone::clone(&self.output_path),
                analysis_unit: ::core::clone::Clone::clone(&self.analysis_unit),
            }
        }
    }
    #[automatically_derived]
    impl ::config_checker::ConfigCheckable for TimeAnalysisConfig {
        fn check(&self) -> bool {
            self.__check(0)
        }
        fn __check(&self, depth: usize) -> bool {
            use colored::Colorize;
            let depth_space = String::from_utf8(::alloc::vec::from_elem(b' ', depth * 2))
                .unwrap();
            let mut ret = true;
            if !(<[_]>::into_vec(::alloc::boxed::box_new(["s", "ms", "us", "s", "ns"]))
                .contains(&self.analysis_unit.as_str()))
            {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0} {3}In field `{1}` of `{2}`\n",
                            "ERROR:".red(),
                            "analysis_unit",
                            "TimeAnalysisConfig",
                            depth_space,
                        ),
                    );
                };
                ret = false;
            }
            ret
        }
    }
    impl Default for TimeAnalysisConfig {
        fn default() -> Self {
            TimeAnalysisConfig {
                exporter: ProfileExporterConfig::TraceEventExporter,
                keep_last: true,
                output_path: "time_performance".to_string(),
                analysis_unit: "s".to_string(),
            }
        }
    }
    pub fn init_from_config(_config: &TimeAnalysisConfig) {}
    pub fn set_node_name(_name: String) {}
    pub fn time_analysis(time: f32, name: String) -> TimeAnalysis {
        TimeAnalysis {
            simulated_time: time,
            begin: time::Instant::now(),
            name,
            coordinates: Vec::new(),
        }
    }
    pub fn time_analysis_node_name(
        time: f32,
        name: String,
        _node_name: String,
    ) -> TimeAnalysis {
        TimeAnalysis {
            simulated_time: time,
            begin: time::Instant::now(),
            name,
            coordinates: Vec::new(),
        }
    }
    pub fn finished_time_analysis(_ta: TimeAnalysis) {}
    pub fn save_results() {}
    pub enum ProfileExporterConfig {
        TraceEventExporter,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProfileExporterConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ProfileExporterConfig::TraceEventExporter => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProfileExporterConfig",
                            0u32,
                            "TraceEventExporter",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProfileExporterConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "TraceEventExporter" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"TraceEventExporter" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProfileExporterConfig>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProfileExporterConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ProfileExporterConfig",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    ProfileExporterConfig::TraceEventExporter,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["TraceEventExporter"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ProfileExporterConfig",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProfileExporterConfig>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ProfileExporterConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "TraceEventExporter")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProfileExporterConfig {
        #[inline]
        fn clone(&self) -> ProfileExporterConfig {
            ProfileExporterConfig::TraceEventExporter
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProfileExporterConfig {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProfileExporterConfig {
        #[inline]
        fn eq(&self, other: &ProfileExporterConfig) -> bool {
            true
        }
    }
    #[allow(dead_code, unused_variables)]
    pub struct TimeAnalysis {
        simulated_time: f32,
        begin: time::Instant,
        name: String,
        coordinates: Vec<usize>,
    }
    #[automatically_derived]
    #[allow(dead_code, unused_variables)]
    impl ::core::clone::Clone for TimeAnalysis {
        #[inline]
        fn clone(&self) -> TimeAnalysis {
            TimeAnalysis {
                simulated_time: ::core::clone::Clone::clone(&self.simulated_time),
                begin: ::core::clone::Clone::clone(&self.begin),
                name: ::core::clone::Clone::clone(&self.name),
                coordinates: ::core::clone::Clone::clone(&self.coordinates),
            }
        }
    }
    #[automatically_derived]
    #[allow(dead_code, unused_variables)]
    impl ::core::fmt::Debug for TimeAnalysis {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TimeAnalysis",
                "simulated_time",
                &self.simulated_time,
                "begin",
                &self.begin,
                "name",
                &self.name,
                "coordinates",
                &&self.coordinates,
            )
        }
    }
}
#[allow(clippy::used_underscore_binding)]
fn simba(m: &Bound<'_, PyModule>) -> PyResult<()> {
    let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
    let m = ::pyo3::impl_::deprecations::inspect_type(m, &check_gil_refs);
    check_gil_refs.function_arg();
    pybinds::make_python_bindings(m)?;
    Ok(())
}
#[doc(hidden)]
mod simba {
    #[doc(hidden)]
    pub const __PYO3_NAME: &'static ::std::ffi::CStr = c"simba";
    pub(super) struct MakeDef;
    #[doc(hidden)]
    pub static _PYO3_DEF: ::pyo3::impl_::pymodule::ModuleDef = MakeDef::make_def();
    /// This autogenerated function is called by the python interpreter when importing
    /// the module.
    #[doc(hidden)]
    #[export_name = "PyInit_simba"]
    pub unsafe extern "C" fn __pyo3_init() -> *mut ::pyo3::ffi::PyObject {
        ::pyo3::impl_::trampoline::module_init(|py| _PYO3_DEF.make_module(py))
    }
}
#[allow(unknown_lints, non_local_definitions)]
impl simba::MakeDef {
    const fn make_def() -> ::pyo3::impl_::pymodule::ModuleDef {
        fn __pyo3_pymodule(
            module: &::pyo3::Bound<'_, ::pyo3::types::PyModule>,
        ) -> ::pyo3::PyResult<()> {
            simba(::std::convert::Into::into(::pyo3::impl_::pymethods::BoundRef(module)))
        }
        const INITIALIZER: ::pyo3::impl_::pymodule::ModuleInitializer = ::pyo3::impl_::pymodule::ModuleInitializer(
            __pyo3_pymodule,
        );
        unsafe {
            ::pyo3::impl_::pymodule::ModuleDef::new(simba::__PYO3_NAME, c"", INITIALIZER)
        }
    }
}
pub mod constants {
    /// Round the time values to the millisecond
    pub const TIME_ROUND: f32 = 1e-3;
}
pub mod errors {
    use std::{error::Error, fmt::{Debug, Display}};
    pub enum SimbaErrorTypes {
        UnknwonError,
        MathError,
        ImplementationError,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SimbaErrorTypes {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SimbaErrorTypes::UnknwonError => "UnknwonError",
                    SimbaErrorTypes::MathError => "MathError",
                    SimbaErrorTypes::ImplementationError => "ImplementationError",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SimbaErrorTypes {
        #[inline]
        fn clone(&self) -> SimbaErrorTypes {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SimbaErrorTypes {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SimbaErrorTypes {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SimbaErrorTypes {
        #[inline]
        fn eq(&self, other: &SimbaErrorTypes) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SimbaErrorTypes {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SimbaErrorTypes,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    pub struct SimbaError {
        error_type: SimbaErrorTypes,
        what: String,
    }
    impl SimbaError {
        pub fn new(error_type: SimbaErrorTypes, what: &str) -> Self {
            Self {
                error_type,
                what: what.to_string(),
            }
        }
    }
    impl Display for SimbaError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let error_message = match self.error_type {
                SimbaErrorTypes::UnknwonError | _ => "Unknown error",
            };
            f.write_fmt(format_args!("Simba Error: {0}", error_message))
        }
    }
    impl Debug for SimbaError {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.write_fmt(
                format_args!(
                    "Simba Error of type {0:?}: {1}",
                    self.error_type,
                    self.what,
                ),
            )
        }
    }
    impl Error for SimbaError {}
    pub type SimbaResult<T> = Result<T, SimbaError>;
}
